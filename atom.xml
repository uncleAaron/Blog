<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StormAaron的技术站</title>
  
  
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="https://uncleaaron.github.io/Blog/"/>
  <updated>2018-08-06T07:38:12.982Z</updated>
  <id>https://uncleaaron.github.io/Blog/</id>
  
  <author>
    <name>Aaron.H</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java-IO</title>
    <link href="https://uncleaaron.github.io/Blog/Java-IO/"/>
    <id>https://uncleaaron.github.io/Blog/Java-IO/</id>
    <published>2018-08-06T07:38:12.000Z</published>
    <updated>2018-08-06T07:38:12.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="default1" scheme="https://uncleaaron.github.io/Blog/tags/default1/"/>
    
      <category term="default2" scheme="https://uncleaaron.github.io/Blog/tags/default2/"/>
    
  </entry>
  
  <entry>
    <title>Java-IO</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java-IO/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java-IO/</id>
    <published>2018-08-06T03:29:19.000Z</published>
    <updated>2018-08-06T07:37:31.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Java 的 I/O 大概可以分成以下几类：</p><ul><li>磁盘操作：File</li><li>字节操作：InputStream 和 OutputStream</li><li>字符操作：Reader 和 Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>新的输入/输出：NIO</li></ul><p>参考了CYC2018的博文：<a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Java%20基础.md" target="_blank" rel="noopener">github-CYC2018</a>🖊 </p></blockquote><a id="more"></a><!-- GFM-TOC --><ul><li><a href="#一概览">一、概览</a></li><li><a href="#二磁盘操作">二、磁盘操作</a></li><li><a href="#三字节操作">三、字节操作</a></li><li><a href="#四字符操作">四、字符操作</a></li><li><a href="#五对象操作">五、对象操作</a></li><li><a href="#六网络操作">六、网络操作</a><ul><li><a href="#inetaddress">InetAddress</a></li><li><a href="#url">URL</a></li><li><a href="#sockets">Sockets</a></li><li><a href="#datagram">Datagram</a></li></ul></li><li><a href="#七nio">七、NIO</a><ul><li><a href="#流与块">流与块</a></li><li><a href="#通道与缓冲区">通道与缓冲区</a></li><li><a href="#缓冲区状态变量">缓冲区状态变量</a></li><li><a href="#文件-nio-实例">文件 NIO 实例</a></li><li><a href="#选择器">选择器</a></li><li><a href="#套接字-nio-实例">套接字 NIO 实例</a></li><li><a href="#内存映射文件">内存映射文件</a></li><li><a href="#对比">对比</a></li></ul></li><li><a href="#八参考资料">八、参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>Java 的 I/O 大概可以分成以下几类：</p><ul><li>磁盘操作：File</li><li>字节操作：InputStream 和 OutputStream</li><li>字符操作：Reader 和 Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>新的输入/输出：NIO</li></ul><h1 id="二、磁盘操作"><a href="#二、磁盘操作" class="headerlink" title="二、磁盘操作"></a>二、磁盘操作</h1><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p><p>递归地输出一个目录下所有文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAllFiles</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="keyword">null</span> || !dir.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dir.isFile()) &#123;<span class="comment">// 是文件，输出文件名</span></span><br><span class="line">        System.out.println(dir.getName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles()) &#123;<span class="comment">// 递归遍历文件</span></span><br><span class="line">        listAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、字节操作"><a href="#三、字节操作" class="headerlink" title="三、字节操作"></a>三、字节操作</h1><p>使用字节流操作进行文件复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(dist);</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read() 最多读取 buffer.length 个字节</span></span><br><span class="line">    <span class="comment">// 返回的是实际读取的个数</span></span><br><span class="line">    <span class="comment">// 返回 -1 的时候表示读到 eof，即文件尾</span></span><br><span class="line">    <span class="keyword">while</span> (in.read(buffer, <span class="number">0</span>, buffer.length) != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><div align="center"> <img src="/Blog/Java/Java-IO/DP-Decorator-java.io.png" width="500"> </div><br></p><p>Java I/O 使用了<strong>装饰者模式来实现。以 InputStream</strong> 为例，</p><ul><li>InputStream 是抽象组件；</li><li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li><li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能，例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li></ul><p><strong>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br></pre></td></tr></table></figure><p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p><h1 id="四、字符操作"><a href="#四、字符操作" class="headerlink" title="四、字符操作"></a>四、字符操作</h1><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p><ul><li>InputStreamReader 实现从字节流解码成字符流；</li><li>OutputStreamWriter 实现字符流编码成为字节流。</li></ul><p>逐行输出文本文件的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFileContent</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileReader fileReader = <span class="keyword">new</span> FileReader(filePath);</span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span></span><br><span class="line">    <span class="comment">// 在调用 BufferedReader 的 close() 方法时会去调用 fileReader 的 close() 方法</span></span><br><span class="line">    <span class="comment">// 因此只要一个 close() 调用即可</span></span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p><p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p><ul><li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li><li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li><li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li></ul><p>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p><p><strong>Java 使用双字节编码 UTF-16be</strong>，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。<strong>char 类型占 16 位</strong>，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p><p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"中文"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(bytes, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure><p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。<strong>getBytes() 的默认编码方式与平台有关，一般为 UTF-8。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes();</span><br></pre></td></tr></table></figure><h1 id="五、对象操作"><a href="#五、对象操作" class="headerlink" title="五、对象操作"></a>五、对象操作</h1><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p><ul><li>序列化：ObjectOutputStream.writeObject()</li><li>反序列化：ObjectInputStream.readObject()</li></ul><p>序列化的类需要<strong>实现 Serializable 接口</strong>，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    A a1 = <span class="keyword">new</span> A(<span class="number">123</span>, <span class="string">"abc"</span>);</span><br><span class="line">    String objectFile = <span class="string">"file/a1"</span>;</span><br><span class="line">    </span><br><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(objectFile));<span class="comment">// 序列化字节流初始化（用装饰者模式包装File输出字节流）</span></span><br><span class="line">    objectOutputStream.writeObject(a1);<span class="comment">// 序列化输出a1对象到文件</span></span><br><span class="line">    objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(objectFile));</span><br><span class="line">    A a2 = (A) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    </span><br><span class="line">    System.out.println(a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line"></span><br><span class="line">    A(<span class="keyword">int</span> x, String y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x = "</span> + x + <span class="string">"  "</span> + <span class="string">"y = "</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p><p><strong>transient</strong> <strong>关键字可以使一些属性不会被序列化</strong>。</p><p><strong>ArrayList 中存储数据的数组是用 transient 修饰的</strong>，因为这个数组是<strong>动态扩展</strong>的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure><h1 id="六、网络操作"><a href="#六、网络操作" class="headerlink" title="六、网络操作"></a>六、网络操作</h1><p>Java 中的网络支持：</p><ul><li><strong>InetAddress</strong>：用于表示网络上的硬件资源，即 <strong>IP 地址</strong>；</li><li><strong>URL</strong>：统一资源定位符；</li><li><strong>Sockets</strong>：使用 <strong>TCP</strong> 协议实现网络通信；</li><li><strong>Datagram</strong>：使用 <strong>UDP</strong> 协议实现网络通信。</li></ul><h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>没有公有的构造函数，只能通过静态方法来创建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress.getByName(String host);</span><br><span class="line">InetAddress.getByAddress(<span class="keyword">byte</span>[] address);</span><br></pre></td></tr></table></figure><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>可以直接从 URL 中读取字节流数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字节流 */</span></span><br><span class="line">    InputStream is = url.openStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字符流 */</span></span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(is, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提供缓存功能 */</span></span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h2><ul><li>ServerSocket：服务器端类</li><li>Socket：客户端类</li><li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li></ul><p><div align="center"> <img src="/Java-IO//ClienteServidorSockets1521731145260.jpg"> </div><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 监听指定的端口</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">55533</span>;</span><br><span class="line">    ServerSocket server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// server将一直等待连接的到来</span></span><br><span class="line">    System.out.println(<span class="string">"server将一直等待连接的到来"</span>);</span><br><span class="line">    Socket socket = server.accept();<span class="comment">// 等待一个连接</span></span><br><span class="line">    <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">    InputStream inputStream = socket.getInputStream();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">      sb.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len,<span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"get message from client: "</span> + sb);</span><br><span class="line">    inputStream.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    server.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端监听一个端口，等待连接的到来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> yiwangzhibujian.onlysend;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 要连接的服务端IP地址和端口</span></span><br><span class="line">    String host = <span class="string">"127.0.0.1"</span>; </span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">55533</span>;</span><br><span class="line">    <span class="comment">// 与服务端建立连接</span></span><br><span class="line">    Socket socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">    <span class="comment">// 建立连接后获得输出流</span></span><br><span class="line">    OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">    String message=<span class="string">"你好  yiwangzhibujian"</span>;</span><br><span class="line">    socket.getOutputStream().write(message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">    write.flush();</span><br><span class="line">    outputStream.close();</span><br><span class="line">    socket.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于客户端往Socket的输出流里面写数据传递给服务端要注意一点，如果写操作之后程序不是对应着输出流的关闭，而是进行其他阻塞式的操作（比如从输入流里面读数据），记住要flush一下，只有这样服务端才能收到客户端发送的数据，否则可能会引起两边无限的互相等待。 </p><h2 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h2><ul><li>DatagramPacket：数据包类</li><li>DatagramSocket：通信类</li></ul><h1 id="七、NIO-非阻塞IO"><a href="#七、NIO-非阻塞IO" class="headerlink" title="七、NIO 非阻塞IO"></a>七、NIO 非阻塞IO</h1><ul><li><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">Java NIO Tutorial</a></li><li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO 浅析</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">IBM: NIO 入门</a></li></ul><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p><h2 id="流与块"><a href="#流与块" class="headerlink" title="流与块"></a>流与块</h2><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p><p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p><p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p><p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p><h2 id="通道与缓冲区"><a href="#通道与缓冲区" class="headerlink" title="通道与缓冲区"></a>通道与缓冲区</h2><h3 id="1-通道（Channel）"><a href="#1-通道（Channel）" class="headerlink" title="1. 通道（Channel）"></a>1. 通道（Channel）</h3><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p><p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p><p>通道包括以下类型：</p><ul><li>FileChannel：从文件中读写数据；</li><li>DatagramChannel：通过 UDP 读写网络中数据；</li><li>SocketChannel：通过 TCP 读写网络中数据；</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><h3 id="2-缓冲区"><a href="#2-缓冲区" class="headerlink" title="2. 缓冲区"></a>2. 缓冲区</h3><p><strong>发送给一个通道的所有数据都必须首先放到缓冲区中</strong>，同样地，<strong>从通道中读取的任何数据都要先读到缓冲区中</strong>。也就是说，<strong>不会直接对通道进行读写数据，而是要先经过缓冲区。</strong></p><p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><p>缓冲区包括以下类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><h2 id="缓冲区状态变量"><a href="#缓冲区状态变量" class="headerlink" title="缓冲区状态变量"></a>缓冲区状态变量</h2><ul><li>capacity：最大容量；</li><li>position：当前已经读写的字节数；</li><li>limit：还可以读写的字节数。</li></ul><p>状态变量的改变过程举例：</p><p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p><p><div align="center"> <img src="/Blog/Java/Java-IO/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png"> </div><br></p><p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。</p><p><div align="center"> <img src="/Blog/Java/Java-IO/80804f52-8815-4096-b506-48eef3eed5c6.png"> </div><br></p><p>③ 在<strong>将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法</strong>，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p><p><div align="center"> <img src="/Blog/Java/Java-IO/952e06bd-5a65-4cab-82e4-dd1536462f38.png"> </div><br></p><p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p><p><div align="center"> <img src="/Blog/Java/Java-IO/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png"> </div><br></p><p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p><p><div align="center"> <img src="/Blog/Java/Java-IO/67bf5487-c45d-49b6-b9c0-a058d8c68902.png"> </div><br></p><h2 id="文件-NIO-实例"><a href="#文件-NIO-实例" class="headerlink" title="文件 NIO 实例"></a>文件 NIO 实例</h2><p>以下展示了使用 NIO 快速复制文件的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fastCopy</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得源文件的输入字节流 */</span></span><br><span class="line">    FileInputStream fin = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输入字节流的文件通道 */</span></span><br><span class="line">    FileChannel fcin = fin.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取目标文件的输出字节流 */</span></span><br><span class="line">    FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(dist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输出字节流的通道 */</span></span><br><span class="line">    FileChannel fcout = fout.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为缓冲区分配 1024 个字节 */</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从输入通道中读取数据到缓冲区中 */</span></span><br><span class="line">        <span class="keyword">int</span> r = fcin.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read() 返回 -1 表示 EOF */</span></span><br><span class="line">        <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 切换读写 */</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 把缓冲区的内容写入输出文件中 */</span></span><br><span class="line">        fcout.write(buffer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择器（Selector）"><a href="#选择器（Selector）" class="headerlink" title="选择器（Selector）"></a>选择器（Selector）</h2><p>NIO 常常被叫做<strong>非阻塞 IO</strong>，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p><p>NIO 实现了 IO 多路复用中的 Reactor 模型，<strong>一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件</strong>。</p><p>通过<strong>配置监听的通道 Channel 为非阻塞</strong>，那么<strong>当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel</strong>，找到 IO 事件已经到达的 Channel 执行。</p><p>因为创建和切换线程的开销很大，因此<strong>使用一个线程来处理多个事件</strong>而不是一个线程处理一个事件<strong>具有更好的性能。</strong></p><p>应该注意的是，<strong>只有套接字 Channel 才能配置为非阻塞</strong>，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p><p><div align="center"> <img src="/Blog/Java/Java-IO/4d930e22-f493-49ae-8dff-ea21cd6895dc.png"> </div><br></p><h3 id="1-创建选择器"><a href="#1-创建选择器" class="headerlink" title="1. 创建选择器"></a>1. 创建选择器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h3 id="2-将通道注册到选择器上"><a href="#2-将通道注册到选择器上" class="headerlink" title="2. 将通道注册到选择器上"></a>2. 将通道注册到选择器上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();<span class="comment">// 开启ServerSocket通道</span></span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">// 通道配置为非阻塞模式</span></span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);<span class="comment">// 通道注册到选择器上</span></span><br></pre></td></tr></table></figure><p><strong>通道必须配置为非阻塞模式</strong>，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p><p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>它们在 SelectionKey 的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h3 id="3-监听事件"><a href="#3-监听事件" class="headerlink" title="3. 监听事件"></a>3. 监听事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br></pre></td></tr></table></figure><p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p><h3 id="4-获取到达的事件"><a href="#4-获取到达的事件" class="headerlink" title="4. 获取到达的事件"></a>4. 获取到达的事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-事件循环"><a href="#5-事件循环" class="headerlink" title="5. 事件循环"></a>5. 事件循环</h3><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="套接字-NIO-实例"><a href="#套接字-NIO-实例" class="headerlink" title="套接字 NIO 实例"></a>套接字 NIO 实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();<span class="comment">// 选择器开启</span></span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();<span class="comment">// ServerSocket通道开启</span></span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">// 设置为非阻塞</span></span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);<span class="comment">// 在selector上注册为监听新连接事件</span></span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = ssChannel.socket();<span class="comment">// 获得ServerSocket实例</span></span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);<span class="comment">// 捆绑地址和端口</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">// 主线程死循环执行选择器监听</span></span><br><span class="line"></span><br><span class="line">            selector.select();<span class="comment">// 阻塞地监听，知道有事件到达</span></span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<span class="comment">// 已选择键集</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;<span class="comment">// 若是新连接事件</span></span><br><span class="line"></span><br><span class="line">                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();<span class="comment">// 取得被选中的ServerSocket通道</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    SocketChannel sChannel = ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">// Socket通道设置为非阻塞</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这个新连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);<span class="comment">// 通道注册到选择器为读事件</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;<span class="comment">// 若是读事件</span></span><br><span class="line"></span><br><span class="line">                    SocketChannel sChannel = (SocketChannel) key.channel();<span class="comment">// 获取触发读事件的Socket通道</span></span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));<span class="comment">// 调用了下面的方法读取内容</span></span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                keyIterator.remove();<span class="comment">// 本次事件处理完毕，移除key</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);<span class="comment">// 声明字节缓存</span></span><br><span class="line">        StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            buffer.clear();<span class="comment">// 读到缓存之前清理缓存</span></span><br><span class="line">            <span class="keyword">int</span> n = sChannel.read(buffer);<span class="comment">// 读取到缓存</span></span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();<span class="comment">// 从写模式切换到读模式</span></span><br><span class="line">            <span class="keyword">int</span> limit = buffer.limit();</span><br><span class="line">            <span class="keyword">char</span>[] dst = <span class="keyword">new</span> <span class="keyword">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">                dst[i] = (<span class="keyword">char</span>) buffer.get(i);<span class="comment">// 从缓存逐字节读取缓存</span></span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        String s = <span class="string">"hello world"</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p><p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p><p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>NIO 与普通 I/O 的区别主要有以下两点：</p><ul><li>NIO 是<strong>非阻塞的</strong></li><li>NIO <strong>面向块</strong>，I/O 面向流</li></ul><h1 id="八、参考资料"><a href="#八、参考资料" class="headerlink" title="八、参考资料"></a>八、参考资料</h1><ul><li>Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002.</li><li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">IBM: NIO 入门</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" target="_blank" rel="noopener">IBM: 深入分析 Java I/O 的工作机制</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.htm" target="_blank" rel="noopener">IBM: 深入分析 Java 中的中文编码问题</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" target="_blank" rel="noopener">IBM: Java 序列化的高级认识</a></li><li><a href="http://blog.csdn.net/shimiso/article/details/24990499" target="_blank" rel="noopener">NIO 与传统 IO 的区别</a></li><li><a href="http://stg-tud.github.io/sedc/Lecture/ws13-14/5.3-Decorator.html#mode=document" target="_blank" rel="noopener">Decorator Design Pattern</a></li><li><a href="http://labojava.blogspot.com/2012/12/socket-multicast.html" target="_blank" rel="noopener">Socket Multicast</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java 的 I/O 大概可以分成以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘操作：File&lt;/li&gt;
&lt;li&gt;字节操作：InputStream 和 OutputStream&lt;/li&gt;
&lt;li&gt;字符操作：Reader 和 Writer&lt;/li&gt;
&lt;li&gt;对象操作：Serializable&lt;/li&gt;
&lt;li&gt;网络操作：Socket&lt;/li&gt;
&lt;li&gt;新的输入/输出：NIO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考了CYC2018的博文：&lt;a href=&quot;https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Java%20基础.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github-CYC2018&lt;/a&gt;🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="NIO" scheme="https://uncleaaron.github.io/Blog/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java基础复习</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java基础复习/</id>
    <published>2018-08-04T03:32:47.000Z</published>
    <updated>2018-08-06T07:37:02.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文大致复习了Java的基础内容：数据类型，String，运算，类型转换，OOP的封装，继承，多态，Object方法包括equals，hashCode，clone，还有final、static关键字，反射，异常，泛型，注解，枚举类型</p><p>参考了github-CYC2018的笔记做的总结，在此基础上补充了一点自己需要补充的内容🖊 </p></blockquote><a id="more"></a><h1 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h1><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>八个基本类型：</p><ul><li>boolean / 1</li><li>byte / 8</li><li><strong>char / 16</strong>      // 注意！Java的char有16位！因为Java用的是UTF-16BE编码，中文和英文都是2个字节</li><li>short / 16</li><li>int / 32</li><li>float / 32</li><li>long / 64</li><li>double / 64</li></ul><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱和拆箱完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;<span class="comment">// 自动装箱，会调用Integer.valueOf(2)方法，尝试从缓存池获取缓存对象，若已经存在，则取缓存中已存在的Integer值为2的对象（是Integer不是int）</span></span><br><span class="line"><span class="keyword">int</span> y = x;<span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure><h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 区别在于：new Integer(123) 每次都会创建一个新对象，而Integer.valueOf(123) 可能会使用缓存对象，因此多次使用Integer.valueOf(123)会取得同一个对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>valueOf() 方法的实现比较简单，先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p><p>Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><h1 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>String被声明为final，因此不可继承</p><p>内部实现：char数组，数组也是final。意味着value数组初始化之后就不能再引用其他数组。String内部没有改变value数组的方法，保证了String的不可变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><h2 id="String不可变的好处"><a href="#String不可变的好处" class="headerlink" title="String不可变的好处"></a>String不可变的好处</h2><ol><li>可以缓存hash值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，只需要进行一次计算。 </li><li>构成了String Pool常量池：String常量池</li><li>安全性：String经常作为参数，不可变保证了连接传输的安全</li><li>线程安全</li></ol><h2 id="String的编码"><a href="#String的编码" class="headerlink" title="String的编码"></a>String的编码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String value = <span class="keyword">new</span> String(str.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure><h2 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h2><p>String不可变，所以是线程安全的</p><p>StringBuffer非线程安全</p><p>StringBuffer线程安全，内部使用synchronized同步</p><h2 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h2><p>使用 String.intern() 可以保证相同内容的字符串变量引用相同的内存对象。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用，这个方法首先把 s1 引用的对象放到 String Pool（字符串常量池）中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s4 = <span class="string">"bbb"</span>;</span><br><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 Java 7 之前，字符串常量池被放在运行时常量池中，它属于永久代。而在 Java 7，字符串常量池被放在堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h1 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Java参数传递是以值传递，不是引用传递。传进方法的都是值拷贝。传进的值只是拷贝，方法内修改无效，但是修改指针所指的内容是有效的。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>Java不允许隐式向下转型（包括精度损失下降的基本类型的转换也不允许：double→long-&gt;int→short→byte，double→float，float→long都不行）</p><h3 id="隐式向下转换的特例：基本类型的-，-，-，-运算"><a href="#隐式向下转换的特例：基本类型的-，-，-，-运算" class="headerlink" title="隐式向下转换的特例：基本类型的+=，/=，-=，*=运算"></a>隐式向下转换的特例：基本类型的+=，/=，-=，*=运算</h3><p>因为字面量1是int类型，它比short类型精度要高，因此不能隐式将int向下转型为short：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;// 这是错误的，1是int类型，s1 + 1会隐式向上转型为int，不能再赋值给short类型的s1。</span></span><br></pre></td></tr></table></figure><p>但是使用 += 运算符可以执行隐式类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;<span class="comment">// +=，/=等都可以。因为其内部做了显式转换，相当于下面显式转换</span></span><br></pre></td></tr></table></figure><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = (<span class="keyword">short</span>) (s1 + <span class="number">1</span>);<span class="comment">// 显式转换OK</span></span><br></pre></td></tr></table></figure><h3 id="float和double"><a href="#float和double" class="headerlink" title="float和double"></a>float和double</h3><p>double不能隐式转换为float ！</p><p>1.1属于double类型，不能直接将1.1赋值给float变量，因为这是向下转型，Java不能隐式向下转型，因为这会造成精度下降。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1// 注意！错误的转型</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span><span class="comment">// 1.1f字面量才是float类型</span></span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">1</span><span class="comment">// 字面量是整数也是可以的</span></span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>Java7开始，switch语句中可以使用String作为判断条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;<span class="comment">// 声明String</span></span><br><span class="line"><span class="keyword">switch</span> (s) &#123;<span class="comment">// 使用String判断</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:<span class="comment">//true</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 不支持 long，double，float，是因为 switch 的设计初衷是为那些只需要对少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p><p>Switch支持char, byte, short, int, Character, Byte, Short, Integer, String, or an enum</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>优先级从高到低</p><p><strong><code>~</code></strong>：按位取反</p><p><strong><code>&lt;&lt;</code></strong>：左移位（低位补0）</p><p><strong><code>&gt;&gt;</code></strong>：右移位（高位补符号位）</p><p><strong><code>&gt;&gt;&gt;</code></strong>：无符号右移位（高位补0）</p><p><code>&amp;</code>：按位与</p><p><strong><code>^</code></strong>：按位异或</p><p><strong><code>|</code></strong>：按位或</p><h1 id="四、封装、继承、多态"><a href="#四、封装、继承、多态" class="headerlink" title="四、封装、继承、多态"></a>四、封装、继承、多态</h1><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>java的四个访问权限：private、default、protected、public，(其中default不是访问权限修饰符)</p><table><thead><tr><th>权限</th><th>类内</th><th>同包</th><th>不同包子类</th><th>不同包非子类</th><th>备注</th></tr></thead><tbody><tr><td><strong>private</strong></td><td>√</td><td>××</td><td>××</td><td>××</td><td>类私有</td></tr><tr><td>default</td><td>√</td><td>√</td><td>××</td><td>××</td><td>默认，包访问权限</td></tr><tr><td><strong>protected</strong></td><td>√</td><td>√</td><td>√</td><td>××</td><td>保护，包与子类访问权限，修饰成员</td></tr><tr><td><strong>public</strong></td><td>√</td><td>√</td><td>√</td><td>√</td><td>公开</td></tr></tbody></table><p>成员可见：其他类可以用这个类的实例对象访问到该成员</p><p>类可见：其他类可以用这个类创建实例对象</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="子类构造函数的约束"><a href="#子类构造函数的约束" class="headerlink" title="子类构造函数的约束"></a>子类构造函数的约束</h3><p>子父类中的构造函数的特点：　　</p><ol><li><p><strong>在子类的构造函数中第一行有默认隐式的super();</strong></p><p>所以在子类构造对象时，发现，访问子类构造函数时，父类构造函数也运行了。 </p></li><li><p><strong>子类构造函数默认调用的是父类中的空参数构造函数</strong>，<strong>如需调用父类中的含参构造，可以在子类构造函数中定义</strong>super(args)。</p></li><li><p><strong>如果父类中没有定义空参构造，那么子类构造必须用super(args)明确</strong>要调用父类的哪个构造函数。</p></li><li><p>若<strong>子类构造函数使用this()调用了本类构造函数，那么该构造函数的隐藏super()就没有了</strong>，因为super()和this()都只能定义第一行，只能有一个。</p><p><strong>但子类中一定有其他的构造函数会访问到父类的构造函数</strong>。</p></li></ol><p>注意：super()语句必须要定义在子类构造函数的第一行。因为<strong>父类的初始化动作要先完成</strong>。</p><h2 id="重写与重载（多态）"><a href="#重写与重载（多态）" class="headerlink" title="重写与重载（多态）"></a>重写与重载（多态）</h2><h3 id="重写（及重写的返回值类型、访问权限要求）"><a href="#重写（及重写的返回值类型、访问权限要求）" class="headerlink" title="重写（及重写的返回值类型、访问权限要求）"></a>重写（及重写的返回值类型、访问权限要求）</h3><ul><li>重写（Override）存在于继承体系中，指子类实现了一个与父类在<strong>方法声明上完全相同</strong>的一个方法，<ul><li><strong>返回值类型</strong>：<strong>子类小于或等于父类</strong>的返回值类型；</li><li><strong>方法访问级别</strong>：<strong>子类不低于父类</strong>；子类中重写方法的访问级别不允许低于父类的访问级别。这是为了<strong>确保可以使用父类实例的地方都可以使用子类实例</strong>，也就是确保满足里氏替换原则。</li></ul></li></ul><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li>重载（Overload）存在于同一个类中，指一个方法与已经存在的<strong>方法名称相同</strong>，但是<strong>参数类型、个数、顺序至少有一个不同</strong>。应该注意的是，返回值不同，其它都相同不算是重载。</li></ul><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>访问父类的关键字</p><ul><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而完成一些初始化的工作。</li><li>访问父类的成员：如果子类覆盖了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);<span class="comment">// 访问父类构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();<span class="comment">// 访问父类的方法</span></span><br><span class="line">        System.out.println(<span class="string">"SuperExtendExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。 </p><p>如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessWithInnerClassExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;<span class="comment">// 私有内部类，成员可以暴露</span></span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccessWithInnerClassExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerClass.x; <span class="comment">// 直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><strong>抽象类</strong>和<strong>抽象方法</strong>都用<strong><code>abstract</code></strong>声明。抽象方法一定位于抽象类中。</p><p>抽象类<strong>不能被实例化</strong>，需要继承抽象类才能实例化其子类。这是它和普通类最大的区别。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClassExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;<span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;<span class="comment">// 实例方法</span></span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>从Java8开始，<strong>接口可以拥有默认的方法实现，此时用<code>default</code>修饰方法体</strong>（因为不支持默认方法的接口维护成本太高了，在Java8以前，一个接口想添加新的方法，需要修改所有的实现类；有的可能需要用适配器转接默认实现，如Spring的WebMvcConfig接口和WebMvcConfigAdaptor）</p><p>接口的成员（字段和方法）默认都是public的，并且不允许定义为其他访问权限private或protected。</p><p>接口的字段默认都是public static final的常量。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">123</span>; <span class="comment">// public static final 的常量</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;<span class="comment">// public的接口方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;<span class="comment">// 默认方法实现，用default修饰</span></span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类和接口比较"><a href="#抽象类和接口比较" class="headerlink" title="抽象类和接口比较"></a>抽象类和接口比较</h3><ul><li><strong>一个类可以实现多个接口，只能继承最多一个类或者抽象类</strong></li><li>接口的字段只能是public static final的，抽象类没这个限制</li><li>接口的方法只能是public的，抽象类没这个限制</li></ul><p>简单说，抽象类只是比普通类少了点方法实现，其他无太大差别。而接口不一样，必须是公开的。</p><p>抽象类是IS-A关系，子类对象必须能够替换掉父类对象</p><p>接口是Like-A关系，是一种契约，不需要完全实现</p><h3 id="选择抽象类还是接口？"><a href="#选择抽象类还是接口？" class="headerlink" title="选择抽象类还是接口？"></a>选择抽象类还是接口？</h3><p>很多情况下，接口优先与抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且，Java8开始，接口也能有默认方法实现，使得修改接口的成本也变得很低。</p><p><strong>使用接口：</strong></p><p>需要让不相关的类都<strong>实现一个方法</strong>，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法； </p><p>需要使用<strong>多继承</strong></p><p><strong>使用抽象类：</strong></p><ul><li>需要在几个相关的类中<strong>共享代码</strong></li><li>需要能<strong>控制</strong>继承来的成员的访问权限，而不都是public</li><li>需要<strong>继承</strong>非静态（non-static）和非常量（non-final）的字段。</li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类的特点"><a href="#内部类的特点" class="headerlink" title="内部类的特点"></a>内部类的特点</h3><ul><li>内部类提供了更好的封装。只有外部类能访问内部类</li><li>内部类可以直接访问外部类的属性和方法，即使是private。因为内部类是成员</li><li>外部类不能直接访问内部类的属性和方法。要用 内部类实例.xxx</li></ul><h3 id="内部类分类"><a href="#内部类分类" class="headerlink" title="内部类分类"></a>内部类分类</h3><p>内部类有4种：成员内部类，局部内部类，匿名内部类，静态内部类。</p><ol><li><p><strong>成员内部类</strong>：作为外部类的一个成员存在，与外部类的属性、方法并列，不能直接访问</p><ul><li><p><strong>非静态内部类中不能存在static成员</strong>。</p></li><li><p>非静态内部类中<strong>可以调用外部类的任何成员</strong>，不管是静态的还是非静态的 </p></li><li><p><strong>创建：</strong>非静态内部类要依靠外部类实例.内部类创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.InnerClass inner = <span class="keyword">new</span> OuterClass().new InnerClass();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>局部内部类</strong>：在方法中定义的内部类，与局部变量类似，不能加访问限定符。其范围为定义它的代码块。</p></li><li><p><strong>匿名内部类</strong>：在方法中new的接口或抽象类实现。若实现的方法只有一个，可以用lambda表达式代替。</p><ul><li>无构造方法（因为没有类名）</li><li>无静态成员或方法</li><li>无访问修饰符</li></ul><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类，实现的是ActionListener接口</span></span><br><span class="line">        <span class="keyword">new</span> ActionListener()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"click action..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.onAction();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态内部类</strong>：定义在外部类中，用static定义。</p><ul><li>静态内部类<strong>不可以使用任何外围类的非static成员</strong>变量和方法。</li><li>静态内部类不依附外部类，<strong>可以直接创建</strong></li></ul></li></ol><h3 id="静态内部类和非静态内部类对比"><a href="#静态内部类和非静态内部类对比" class="headerlink" title="静态内部类和非静态内部类对比"></a>静态内部类和非静态内部类对比</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String outerName;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass1</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 1. 在静态内部类中可以存在静态成员 */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String _innerName = <span class="string">"static variable"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 2. 静态内部类只能访问外部类的静态成员变量和方法</span></span><br><span class="line"><span class="comment">             *    不能访问外部类的非静态成员变量和方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(<span class="string">"OutClass name :"</span> + outerName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass2</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 1. 非静态内部类中不能存在静态成员 */</span></span><br><span class="line">        <span class="keyword">public</span> String _innerName = <span class="string">"no static variable"</span>;</span><br><span class="line">        <span class="comment">/* 2. 非静态内部类中可以调用外部类的任何成员,不管是静态的还是非静态的 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"OuterClass name："</span> + outerName);</span><br><span class="line">            System.out.println(<span class="string">"OuterClass age："</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 3. 外部类能直接访问静态内部类静态元素 */</span></span><br><span class="line">        System.out.println(InnerClass1._innerName);</span><br><span class="line">        <span class="comment">/* 4. 静态内部类可以直接创建实例不需要依赖于外部类 */</span></span><br><span class="line">        <span class="keyword">new</span> InnerClass1().display();</span><br><span class="line">        <span class="comment">/* 4. 非静态内部的创建需要依赖于外部类 */</span></span><br><span class="line">        OuterClass.InnerClass2 inner2 = <span class="keyword">new</span> OuterClass().new InnerClass2();</span><br><span class="line">        <span class="comment">/* 3. 非静态内部类的成员需要使用非静态内部类的实例访问 */</span></span><br><span class="line">        System.out.println(inner2._innerName);</span><br><span class="line">        inner2.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类参考链接：</p><ul><li><a href="https://blog.csdn.net/suifeng3051/article/details/51791812" target="_blank" rel="noopener">https://blog.csdn.net/suifeng3051/article/details/51791812</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3811445.html</a></li></ul><h1 id="五、Object通用方法"><a href="#五、Object通用方法" class="headerlink" title="五、Object通用方法"></a>五、Object通用方法</h1><h2 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h2><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><h3 id="equal-与"><a href="#equal-与" class="headerlink" title="equal()与=="></a>equal()与==</h3><p>对于基本类型，==判断两个值是否相等，基本类型没有equals()方法。</p><p>对于引用类型，==判断两个实例是否引用指针是否指向同一个对象，而equals()判断引用的对象是否等价。</p><p>对于包装类型，要使用equals()比较数值（如IntegerCache只保存-127~128的值，其他的值都为新对象在堆上产生，不能用==，要使用<code>integer.equals()</code>）</p><p>若未重写equals()，equals的实现就是==</p><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p>hashCode() 返回散列值，而 equals() 是用来判断两个实例是否等价。</p><p><strong>等价的两个实例散列值一定要相同，但是散列值相同的两个实例不一定等价。</strong> (相当于hashCode将对象分到桶里，而equals再区分到底等不等) </p><p>HashSet中会先识别hashCode是否相等，再识别equals是否相等，以此判断两个对象是否为同一个对象。 </p><h3 id="hashCode-与equal"><a href="#hashCode-与equal" class="headerlink" title="hashCode()与equal()"></a>hashCode()与equal()</h3><p><strong>重写equals时一定要重写hashCode()方法</strong>，保证两个等价的实例的hashCode也相等。</p><p><strong>不同时重写equals和hashCode的后果</strong>：</p><ul><li>可能导致<strong>数据的不唯一</strong>。（HashSet中会认为是不同的对象，导致存储了两次同样的数据）</li><li><strong>内存泄漏</strong>（开发人员在删除HashSet元素时，自认为已经删除一个引用，但其实还保留了另一个相同内容的副本，导致该对象长时间得不到释放，造成内存泄漏） </li></ul><h3 id="实现hashCode"><a href="#实现hashCode" class="headerlink" title="实现hashCode"></a>实现hashCode</h3><p>理想的散列函数应当具有均匀性，即不相等的实例应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><p>一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    int result = 17;</span><br><span class="line">    result = 31 * result + x;</span><br><span class="line">    result = 31 * result + y;</span><br><span class="line">    result = 31 * result + z;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 </p><h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><h3 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h3><p>clone() 是 Object 的 protected 方法，<strong>一个类不显式去重写 clone()和实现Cloneable接口，其它类就不能调用该类实例的 clone() 方法</strong>。 </p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;<span class="comment">// 实现Cloneable接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;<span class="comment">// 重写clone()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><ul><li><strong>浅拷贝：拷贝实例和实例的引用</strong>。拷贝实例和原始实例的引用类型<strong>引用同一个对象</strong>；</li><li><strong>深拷贝：拷贝实例引用指向的对象</strong>。拷贝实例和原始实例的引用类型<strong>引用不同对象</strong>。</li></ul><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneConstructorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CloneConstructorExample e1 = <span class="keyword">new</span> CloneConstructorExample();</span><br><span class="line">CloneConstructorExample e2 = <span class="keyword">new</span> CloneConstructorExample(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h1 id="六、关键字"><a href="#六、关键字" class="headerlink" title="六、关键字"></a>六、关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>常量</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态</p><h1 id="七、反射"><a href="#七、反射" class="headerlink" title="七、反射"></a>七、反射</h1><p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 <strong>Class.forName</strong>(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p><strong>反射可以提供运行时的类信息，并且这个类在运行时才加载进来</strong>，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>反射可以不通过访问权限访问，破坏了封装性。</p><h3 id="获得Class对象（Class）"><a href="#获得Class对象（Class）" class="headerlink" title="获得Class对象（Class）"></a>获得Class对象（Class）</h3><blockquote><p>forName, getClass</p></blockquote><p><strong><code>Class.forName(&quot;Class全类名&quot;)</code></strong>    // 1. 使用Class类的forName静态方法</p><p><strong><code>Class&lt;?&gt; klass = ins.getClass()</code></strong>    // 2. 调用某个对象的getClass()方法 </p><p><strong><code>Class&lt;?&gt; klass = ClassA.class</code></strong>    // 3. 直接获取某一个类对象的class</p><p><strong><code>Class&lt;?&gt; klass = Integer.TYPE</code></strong>    // 直接获取某一个对象的class</p><h3 id="获取构造器（Constructor）"><a href="#获取构造器（Constructor）" class="headerlink" title="获取构造器（Constructor）"></a>获取构造器（Constructor）</h3><blockquote><p>class.getConstructor</p></blockquote><p>通过Class类的getConstructor方法得到Constructor类的一个实例，Constructor类有一个newInstance方法可以创建一个对象实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clz.getConstructor(args.class)；//参数为原方法参数的类型</span><br></pre></td></tr></table></figure><h3 id="创建实例（Instance）"><a href="#创建实例（Instance）" class="headerlink" title="创建实例（Instance）"></a>创建实例（Instance）</h3><blockquote><p>class.newInstance, constructor.newInstance</p></blockquote><p>先获得class对象，如Class clz</p><ol><li><p>使用Class对象的newInstance()创建Class对象对应类的实例。</p><p><strong><code>Object ins = clz.newInstance()</code></strong></p></li><li><p>指定构造器创建实例：先通过Class对象获取Constructor构造器对象，再通过Constructor对象的newInstance()方法创建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clz.getConstructor(args.class)；<span class="comment">//参数为原方法参数的类型</span></span><br><span class="line">Object obj = constructor.newInstance(args);</span><br></pre></td></tr></table></figure></li></ol><h3 id="获取方法（method）"><a href="#获取方法（method）" class="headerlink" title="获取方法（method）"></a>获取方法（method）</h3><blockquote><p>clz.getMethods();</p></blockquote><p>获取某个Class对象的方法集合（无视访问权限，不包括继承的方法）</p><p><strong><code>Method[] methods = clz.getDeclaredMethods();</code></strong></p><p>获取某个Class对象的公用方法集合（public），包括继承的公用方法</p><p><strong><code>Method[] methods = clz.getMethods()</code></strong></p><p>获取一个特定的方法。其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象 </p><p><strong><code>clz.getMethod(String methodName, Class&lt;?&gt;... paramTypes)</code></strong></p><p><strong><code>clz.getDeclaredMethod(String methodName, Class&lt;?&gt;... paramTypes)</code></strong></p><h3 id="获取成员变量（Field）"><a href="#获取成员变量（Field）" class="headerlink" title="获取成员变量（Field）"></a>获取成员变量（Field）</h3><p><strong><code>getField(String name)</code></strong></p><p><strong><code>getDeclaredField(String name)</code></strong></p><p><strong><code>getFields()</code></strong></p><p><strong><code>getDeclaredFields()</code></strong></p><h3 id="调用方法（method-invoke）"><a href="#调用方法（method-invoke）" class="headerlink" title="调用方法（method.invoke）"></a>调用方法（method.invoke）</h3><p><strong><code>method.invoke(Object obj, Object...args)</code></strong>  // 参数为要调用方法的实例对象和参数列表</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;<span class="comment">// 在此之外声明了一个Testor的类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clz = Testor.class;</span><br><span class="line">        Object obj = clz.newInstance();<span class="comment">//创建Testor的实例</span></span><br><span class="line">        Method method = clz.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class);<span class="comment">// 获取Testor类的add方法</span></span><br><span class="line">        Object result = method.invoke(obj,<span class="number">1</span>,<span class="number">4</span>);<span class="comment">//调用method对应的方法 =&gt; add(1,4)</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否为某个类的实例（isInstance）"><a href="#判断是否为某个类的实例（isInstance）" class="headerlink" title="判断是否为某个类的实例（isInstance）"></a>判断是否为某个类的实例（isInstance）</h3><p>一般地，我们用<strong>instanceof关键字来判断是否为某个类的实例</strong>。同时我们<strong>也可以借助反射中Class对象的isInstance()方法</strong>来判断是否为某个类的实例，它是一个Native方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;<span class="comment">// Class对象的方法，用法：clz.inInstance(obj)</span></span><br></pre></td></tr></table></figure><h3 id="反射创建数组"><a href="#反射创建数组" class="headerlink" title="反射创建数组"></a>反射创建数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object array = java.lang.reflect.Array.newInstance(Class elementClass, <span class="keyword">int</span> length);<span class="comment">//实例array</span></span><br><span class="line">java.lang.reflect.Array.set(array, <span class="number">0</span>, elem);<span class="comment">// 往array插入值</span></span><br><span class="line">Array.get(array, <span class="number">0</span>);<span class="comment">// 读取值</span></span><br></pre></td></tr></table></figure><h1 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h1><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。</p><ul><li><p>Error：表示 JVM 无法处理的错误。</p></li><li><p>Exception：表示程序可捕捉可处理的异常。分为两种：</p><ul><li><strong>受检异常</strong> ：编译期可预测的，必须处理的异常，需要用 try…catch… 语句捕获并处理，或用throws子句抛出，否则编译无法通过。</li><li><strong>非受检异常</strong> ：RuntimeException，运行时异常，不要求强制处理。</li></ul></li></ul><p><img src="/Blog/Java/Java基础复习/异常类图.png" alt="异常类图"></p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>五个关键字，分别是：<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>、<code>throws</code> </p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>如果<strong>一个方法可以导致一个异常但不处理它</strong>，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常。要做到这点，我们可以在方法声明中包含一个<code>throws</code>子句。一个<code>throws</code>子句列举了一个方法可能引发的所有异常类型。 </p><h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>用户自定义异常类，只需继承<code>Exception</code>类即可。</p><p>在程序中使用自定义异常类，大体可分为以下几个步骤:</p><ul><li>创建自定义异常类。</li><li>在方法中通过<code>throw</code>关键字抛出异常对象。</li><li>如果在当前抛出异常的方法中处理异常，可以使用<code>try-catch</code>语句捕获并处理；否则在方法的声明处通过<code>throws</code>关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常方法的调用者中捕获并处理异常。</li></ul><p>本节参考：<a href="https://www.tianmaying.com/tutorial/Java-Exception" target="_blank" rel="noopener">Java异常处理-详解</a></p><h1 id="九、泛型"><a href="#九、泛型" class="headerlink" title="九、泛型"></a>九、泛型</h1><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><h2 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h2><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h2 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h2><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息</p><ul><li><a href="http://www.importnew.com/24029.html" target="_blank" rel="noopener">Java 泛型详解</a></li></ul><h1 id="十、注解"><a href="#十、注解" class="headerlink" title="十、注解"></a>十、注解</h1><p>Annotation类型定义为@interface。</p><ol><li><p>所有的Annotation会自动继承java.lang.Annotation接口，并且不能再去继承别的类或接口。.   </p></li><li><p>参数成员只能用public或默认(default)这两个访问权修饰   </p></li><li>参数成员只能用8种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.   </li><li>要获取类方法和字段的注解信息，必须通过反射获取 Annotation对象，除此之外没有获取注解的方法   </li><li>注解也可以没有定义成员, 可以用于标记 </li></ol><p>PS:自定义注解需要使用到元注解 </p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>@Documented –注解是否将包含在JavaDoc中</p><p>@Retention –什么时候使用该注解（RUNTIME运行, CLASS类加载, SOURCE编译期）</p><p>@Target –注解用于什么地方（可用ElementType的参数）</p><p>@Inherited – 是否允许子类继承该注解</p><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><ol><li><p>@Override</p><p>java.lang.Override是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java编译器将以一个编译错误来警示。</p></li><li><p>@Deprecated</p><p>Deprecated也是一种标记类型注解。当一个类型或者类型成员或父类使用@Deprecated修饰的话，编译器将不鼓励使用这个被标注的程序元素。</p></li><li><p>@SuppressWarnings</p><p>SuppressWarning不是一个标记类型注解。抑制警告。它有一个类型为String[]的成员，这个成员的值为被禁止的警告名。对于javac编译器来讲，被-Xlint选项有效的警告名也同样对@SuppressWarings有效，同时编译器忽略掉无法识别的警告名。</p><p>@SuppressWarnings(“unchecked”) </p></li></ol><h2 id="自定义注解实例"><a href="#自定义注解实例" class="headerlink" title="自定义注解实例"></a>自定义注解实例</h2><p>编写注解，注解处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水果颜色注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitColor &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 颜色枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Color&#123; BLUE,RED,GREEN&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 颜色属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Color <span class="title">fruitColor</span><span class="params">()</span> <span class="keyword">default</span> Color.GREEN</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本节参考：<a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html" target="_blank" rel="noopener">注解Annotation实现原理及自定义注解例子</a></li></ul><h1 id="十一、枚举类型"><a href="#十一、枚举类型" class="headerlink" title="十一、枚举类型"></a>十一、枚举类型</h1><table><thead><tr><th>返回类型</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>compareTo(E o)</code></td><td>比较此枚举与指定对象的顺序</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object other)</code></td><td>当指定对象等于此枚举常量时，返回 true。</td></tr><tr><td><code>Class&lt;?&gt;</code></td><td><code>getDeclaringClass()</code></td><td>返回与此枚举常量的枚举类型相对应的 Class 对象</td></tr><tr><td><code>String</code></td><td><strong><code>name()</code></strong></td><td>返回此枚举常量的名称，在其枚举声明中对其进行声明</td></tr><tr><td><code>int</code></td><td><strong><code>ordinal()</code></strong></td><td>返回枚举常量的序数（它在枚举声明中的位置，从0开始）</td></tr><tr><td><code>String</code></td><td><strong><code>toString()</code></strong></td><td>返回枚举常量的名称，它包含在声明中</td></tr><tr><td><code>static&lt;T extends Enum&lt;T&gt;&gt; T</code></td><td><strong><code>static valueOf(Class&lt;T&gt; enumType, String name)</code></strong></td><td>返回带指定名称的指定枚举类型的枚举常量。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day2 &#123;</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>),<span class="comment">// 这种写法都是调用构造函数</span></span><br><span class="line">    TUESDAY(<span class="string">"星期二"</span>),<span class="comment">// 这些都是本类型的实例，名为TUSDAY的Day2类型，类似多例模式</span></span><br><span class="line">    WEDNESDAY(<span class="string">"星期三"</span>),</span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>),</span><br><span class="line">    FRIDAY(<span class="string">"星期五"</span>),</span><br><span class="line">    SATURDAY(<span class="string">"星期六"</span>),</span><br><span class="line">    SUNDAY(<span class="string">"星期日"</span>);<span class="comment">// 以上枚举实例，记住要用分号结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">// 中文描述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造,防止被外部调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day2</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc=desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义方法,返回描述,跟常规类的定义没区别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Day2 day:Day2.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"name:"</span>+day.name()+</span><br><span class="line">                    <span class="string">",desc:"</span>+day.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     输出结果:</span></span><br><span class="line"><span class="comment">     name:MONDAY,desc:星期一</span></span><br><span class="line"><span class="comment">     name:TUESDAY,desc:星期二</span></span><br><span class="line"><span class="comment">     name:WEDNESDAY,desc:星期三</span></span><br><span class="line"><span class="comment">     name:THURSDAY,desc:星期四</span></span><br><span class="line"><span class="comment">     name:FRIDAY,desc:星期五</span></span><br><span class="line"><span class="comment">     name:SATURDAY,desc:星期六</span></span><br><span class="line"><span class="comment">     name:SUNDAY,desc:星期日</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参考资料：<a href="https://blog.csdn.net/javazejian/article/details/71333103" target="_blank" rel="noopener">Java枚举类型enum</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文大致复习了Java的基础内容：数据类型，String，运算，类型转换，OOP的封装，继承，多态，Object方法包括equals，hashCode，clone，还有final、static关键字，反射，异常，泛型，注解，枚举类型&lt;/p&gt;
&lt;p&gt;参考了github-CYC2018的笔记做的总结，在此基础上补充了一点自己需要补充的内容🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java8-Stream流-复习</title>
    <link href="https://uncleaaron.github.io/Blog/Java/java8-Stream%E6%B5%81-%E5%A4%8D%E4%B9%A0/"/>
    <id>https://uncleaaron.github.io/Blog/Java/java8-Stream流-复习/</id>
    <published>2018-08-03T07:03:51.000Z</published>
    <updated>2018-08-03T07:03:51.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="default1" scheme="https://uncleaaron.github.io/Blog/tags/default1/"/>
    
      <category term="default2" scheme="https://uncleaaron.github.io/Blog/tags/default2/"/>
    
  </entry>
  
  <entry>
    <title>java8其中两个新特性-lambda表达式和Stream流-复习</title>
    <link href="https://uncleaaron.github.io/Blog/Java/java8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%A4%8D%E4%B9%A0/"/>
    <id>https://uncleaaron.github.io/Blog/Java/java8-lambda表达式-复习/</id>
    <published>2018-08-03T07:02:16.000Z</published>
    <updated>2018-08-03T08:37:01.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>去除类定义和类方法，只留下方法使用的参数表和方法实现</p><p>如下：</p><p><code>(params) -&gt; { statements; }</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String a = <span class="string">"test1"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(<span class="string">"testa"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"testc"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替代的类只有一个方法的时候才能生效，否则java识别不出应该用哪个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量作用域：不能修改匿名方法外的变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="default1" scheme="https://uncleaaron.github.io/Blog/tags/default1/"/>
    
      <category term="default2" scheme="https://uncleaaron.github.io/Blog/tags/default2/"/>
    
  </entry>
  
  <entry>
    <title>java集合框架-汇总复习</title>
    <link href="https://uncleaaron.github.io/Blog/Java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E6%B1%87%E6%80%BB%E5%A4%8D%E4%B9%A0/"/>
    <id>https://uncleaaron.github.io/Blog/Java/java集合框架-汇总复习/</id>
    <published>2018-08-03T07:01:55.000Z</published>
    <updated>2018-08-06T03:20:33.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注</p><p><a href="https://www.jianshu.com/p/bfdb5ffa0ae2" target="_blank" rel="noopener">Java1.8集合框架索引总结</a> 这里有人整合了一段，可以阅读一下</p><p>此外，有人总结的面试题<a href="https://blog.csdn.net/qq_26947195/article/details/79755944" target="_blank" rel="noopener">Java集合框架面试总结</a></p><p>这个博主讲的非常精髓，有空也要读一下<a href="https://www.cnblogs.com/xiaoxi/p/6089984.html" target="_blank" rel="noopener">Java集合框架综述</a>🖊</p></blockquote><a id="more"></a><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>Collection集合：Set，List，Queue</p><p>Map图：（与Collection不同族）HashMap，HashTable，TreeMap，ConcurrentHashMap</p><p><img src="/Blog/Java/java集合框架-汇总复习/Collection类图.png" alt="类图"></p><p><img src="/Blog/Java/java集合框架-汇总复习/Map类图-简易.png" alt="Map类图-简易"></p><h1 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><strong>特点</strong>：<strong>查询快，增删慢</strong></p><p><strong>实现</strong>：<strong>动态数组</strong>，支持随机访问</p><p>默认大小10，默认扩展50%+1个</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。 </p><p><strong>特点</strong>：<strong>增删块，查询慢</strong></p><p><strong>实现</strong>：<strong>双向链表</strong></p><p>实现了Deque<strong>双向队列</strong>（offer入队，pool出队，peek查看）</p><p>可用作<strong>Stack栈</strong>（push入栈，pop出栈，peek查看）</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>与ArrayList相似，数组</p><p><strong>线程安全</strong>（synchronized），效率低，不推荐</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>LIFO先进后出，继承了Vector</p><p>数组</p><p>线程安全，效率低，不推荐</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>无序，按照Hash算法存储元素，</p><p><strong>实现</strong>：<strong>基于HashMap</strong>存储元素（先检查hashCode再检查equals）</p><p><strong>特点</strong>：<strong>存储性能和查询性能良好</strong>，<strong>不支持有序</strong>操作（用Iterator遍历的结果是不确定的）</p><p>非线程安全</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p><strong>可排序</strong>的Set结构</p><p><strong>实现</strong>：<strong>红黑树</strong>，基于TreeMap实现（底层维护一个TreeMap）</p><p>支持自然排序和定制排序</p><p>但是查找效率不如 HashSet：HashSet 查找时间复杂度为 O(1)，TreeSet 则为 O(logN) </p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>HashSet的子类</p><p><strong>实现</strong>：<strong>双向链表</strong> 维护<strong>元素顺序</strong></p><p>特点：具有 HashSet 的查找效率，有插入顺序</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HashSet性能最高</p><p>实现排序Set：用TreeSet</p><p>实现插入顺序：用LinkedHashSet</p><p>Set中尽量只添加不可变对象</p><p>上述三个Set都是线程不安全的，若需要并发访问，需要手动实现同步。（例Collection.synchronizedSet方法）</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>实现双向队列（offer入队，pool出队，peek查看）</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>优先队列</p><p><strong>实现：堆结构</strong></p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>Entry数组保存key-value</p><p>存储和查询时<strong>先根据HashCode决定在数组</strong>的位置，<strong>再根据equals决定</strong>其在该数组位置上的<strong>链表</strong>中的存储位置；</p><p>用<strong>链地址法</strong>解决Hash冲突（解决hash冲突的办法有1. 开放地址法 2. 再哈希法 3. 链地址法 4. 建立公共溢出区）</p><p><img src="/Blog/Java/java集合框架-汇总复习/HashMap.jpg" alt="HashMap"></p><p>默认大小16，加载因子为0.75，可以使用Collections.synchronizeMap(hashMap)实现同步</p><p>Java8开始，一个桶存储的链表长度&gt;8时，链表将转为红黑树</p><p>关于hashMap的总结这里还有更多：<a href="https://blog.csdn.net/weixin_37864013/article/details/77428919" target="_blank" rel="noopener">HashMap总结：链接</a></p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p><strong>实现：双向链表</strong> 维护元素的顺序，</p><p>顺序：<strong>插入</strong>顺序 或 <strong>最近最少使用</strong>（LRU）顺序。 </p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>实现：红黑树</p><p>TreeMap集合默认会对键进行排序，所以键必须实现自然排序和定制排序中的一种 </p><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>数据结构 HashMap 一致，但它是线程安全的，但Hashtable则会锁定整个map</p><p>它是遗留类，不应该去使用它。</p><p>现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 </p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>线程安全：分段锁机制：ConcurrentHashMap仅仅锁定map的某个部分</p><p>高效的线程安全</p><h3 id="Map类集合K-V能不能存储null值的情况"><a href="#Map类集合K-V能不能存储null值的情况" class="headerlink" title="Map类集合K/V能不能存储null值的情况"></a>Map类集合K/V能不能存储null值的情况</h3><p><img src="/Blog/Java/java集合框架-汇总复习/Map的是否允许null值.png" alt="Map的是否允许null值"></p><p>只有HashMap可以都为null，以及Tree只允许Value为null（key要排序），其他都不能为null</p><h1 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/bfdb5ffa0ae2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java1.8集合框架索引总结&lt;/a&gt; 这里有人整合了一段，可以阅读一下&lt;/p&gt;
&lt;p&gt;此外，有人总结的面试题&lt;a href=&quot;https://blog.csdn.net/qq_26947195/article/details/79755944&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java集合框架面试总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个博主讲的非常精髓，有空也要读一下&lt;a href=&quot;https://www.cnblogs.com/xiaoxi/p/6089984.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java集合框架综述&lt;/a&gt;🖊&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="Java集合框架" scheme="https://uncleaaron.github.io/Blog/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>java类加载-简单总结</title>
    <link href="https://uncleaaron.github.io/Blog/Java/java%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>https://uncleaaron.github.io/Blog/Java/java类加载-简单总结/</id>
    <published>2018-08-02T11:07:20.000Z</published>
    <updated>2018-08-02T12:21:48.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>这几天简单阅读了《深入理解Java虚拟机》的类加载章节，简单总结了一些内容，类加载器的部分之后会补充🖊 </p></blockquote><a id="more"></a><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p><strong>加载→验证→准备→解析→初始化===&gt;使用===&gt;卸载</strong></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>（不要和类加载搞混）加载阶段虚拟机所完成的3件事</p><ol><li>通过类名定义此类的二进制字节流</li><li>将静态结构存储结构转化进方法区的运行时数据结构</li><li>生成java.lang.Class对象，存入方法区，作为该类入口</li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>通过验证确保Class文件的字节流包含的信息符合当前虚拟机的要求，确保其不会威胁虚拟机自身</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>正式为类分配方法区内存空间（不是指对象），并设置类变量初始值(0值)。（这里仅仅分配static类变量，实例变量在实例对象时加入堆）</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>将常量池的符号引用替换为直接引用</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>这是类加载的最后一步，这个阶段才真正开始执行代码，执行类构造器<code>&lt;clinit&gt; ()</code>（由所有类变量赋值操作和静态语句块合并成）。</p><ul><li>类构造器的合并是按语句出现顺序排序的，静态语句块只能<strong>访问</strong>到定义在静态语句块之前的变量。（定义在其之后的变量只能赋值不能访问）如下所示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;<span class="comment">// 可以给变量赋值</span></span><br><span class="line">        System.out.println(i);<span class="comment">// 这是错误的，不可以访问定义在static语句块之后的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父类的类构造器一定会先执行完毕于子类的类构造器（也意味着其静态语句块先于子类的变量赋值操作）</li><li>接口没有静态语句块，但还有变量初始化的赋值操作，也会生成\&lt;client>()方法，但其不需要先执行父接口的类构造器（因为接口只有真正引用到了父接口时，父接口才会初始化)</li></ul><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>类中有且仅有4种主动引用情况执行类初始化，其他情况（被动引用）都不会初始化类</p><ol><li>遇到<strong>new、getstatic、putstatic、invokestatic</strong>这4个字节码指令<ul><li>new：使用new关键字实例化对象。</li><li>getstatic：读引用一个类的静态字段。(已经在编译期把结果放入常量池的final静态字段除外)</li><li>putstatic：写引用一个类的静态字段。(已经在编译期把结果放入常量池的final静态字段除外)</li><li>invokestatic：调用一个类的静态方法。(已经在编译期把结果放入常量池的final静态常量除外)</li></ul></li><li><strong>初始化类时，若父类也未初始化，先初始化父类</strong><ul><li><strong>接口初始化：只有真正引用到了父接口时，才会初始化。</strong></li></ul></li><li><strong>反射</strong>调用类</li><li>虚拟机<strong>启动</strong>时会先初始化包含<strong>main</strong>()方法的类</li></ol><p>演示几个不会触发类初始化的被动引用示例：</p><p>下面有三个示例</p><ul><li>通过类引用final静态常量，因为final静态常量已经在编译期进入常量池，本质上不会调用到类，不触发初始化</li><li><strong>通过子类引用父类的静态字段，不会导致子类初始化</strong></li><li>数组声明不触发初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"SuperClass init."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用value时，会初始化这个SuperClass类（这里的不是常量）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 引用Final_Value时，不会初始化SuperClass</span></span><br><span class="line">    <span class="comment">//    因为static final变量在编译期就已经放到了常量池里，本质上没直接引用到定义常量的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Final_Value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SonClass init."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 引用类的Final_Value时，不会触发初始化</span></span><br><span class="line">    <span class="comment">//    因为static final变量在编译期就已经放到了常量池里，本质上没直接引用到定义常量的类</span></span><br><span class="line">        System.out.println(SuperClass.Final_Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 通过子类引用父类的静态字段，不会导致子类的初始化！</span></span><br><span class="line">        System.out.println(SonClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 通过数组定义类，很明显不会触发初始化过程</span></span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这几天简单阅读了《深入理解Java虚拟机》的类加载章节，简单总结了一些内容，类加载器的部分之后会补充🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2.0 Cache自定义key/value序列化</title>
    <link href="https://uncleaaron.github.io/Blog/JavaWeb/Cache%E8%87%AA%E5%AE%9A%E4%B9%89key-value%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://uncleaaron.github.io/Blog/JavaWeb/Cache自定义key-value序列化/</id>
    <published>2018-08-01T13:06:58.000Z</published>
    <updated>2018-08-01T13:15:05.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Sping Boot2.0.3变化太多了，今天写redis缓存配置的时候又发现了RedisCacheManage的配置又相比SpringBoot 1.5变化了很多，再这再备注一下🖊 </p></blockquote><a id="more"></a><h1 id="SpringBoot2-0-Cache自定义key-value序列化"><a href="#SpringBoot2-0-Cache自定义key-value序列化" class="headerlink" title="SpringBoot2.0 Cache自定义key/value序列化"></a>SpringBoot2.0 Cache自定义key/value序列化</h1><h3 id="1、pom依赖"><a href="#1、pom依赖" class="headerlink" title="1、pom依赖"></a>1、pom依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2、配置yml"><a href="#2、配置yml" class="headerlink" title="2、配置yml"></a>2、配置yml</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cache:</span><br><span class="line">    redis:</span><br><span class="line">      use-key-prefix: <span class="keyword">true</span></span><br><span class="line">      time-to-live: <span class="number">1</span>d</span><br><span class="line">  redis:</span><br><span class="line">    port: <span class="number">6379</span></span><br><span class="line">    host: ip</span><br><span class="line">    password: pwd</span><br><span class="line">    database: <span class="number">0</span></span><br><span class="line">    timeout: <span class="number">1</span>s</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: <span class="number">8</span></span><br><span class="line">        max-idle: <span class="number">50</span></span><br><span class="line">        min-idle: <span class="number">0</span></span><br><span class="line">        max-wait: -<span class="number">1</span>ms</span><br></pre></td></tr></table></figure><h3 id="3、自定义CacheConfiguration-类"><a href="#3、自定义CacheConfiguration-类" class="headerlink" title="3、自定义CacheConfiguration 类"></a>3、自定义CacheConfiguration 类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j2;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.cache.redis"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Duration timeToLive = Duration.ZERO;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeToLive</span><span class="params">(Duration timeToLive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeToLive = timeToLive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(<span class="keyword">this</span>.timeToLive)</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(keySerializer()))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer()))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line"></span><br><span class="line">        RedisCacheManager redisCacheManager = RedisCacheManager.builder(connectionFactory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .transactionAware()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"自定义RedisCacheManager加载完成"</span>);</span><br><span class="line">        <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String,Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        redisTemplate.setKeySerializer(keySerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(keySerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(valueSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(valueSerializer());</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"自定义RedisTemplate加载完成"</span>);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedisSerializer&lt;String&gt; <span class="title">keySerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedisSerializer&lt;Object&gt; <span class="title">valueSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Sping Boot2.0.3变化太多了，今天写redis缓存配置的时候又发现了RedisCacheManage的配置又相比SpringBoot 1.5变化了很多，再这再备注一下🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
      <category term="Java 开发问题总结" scheme="https://uncleaaron.github.io/Blog/tags/Java-%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="SpringBoot" scheme="https://uncleaaron.github.io/Blog/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>第6章 Java并发容器和框架</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC6%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java并发编程艺术/第6章-Java并发容器和框架/</id>
    <published>2018-07-25T11:55:32.000Z</published>
    <updated>2018-07-26T12:47:29.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="default1" scheme="https://uncleaaron.github.io/Blog/tags/default1/"/>
    
      <category term="default2" scheme="https://uncleaaron.github.io/Blog/tags/default2/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾收集GC和内存分配策略</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86GC%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java垃圾收集GC和内存分配策略/</id>
    <published>2018-07-23T12:17:47.000Z</published>
    <updated>2018-07-23T12:19:31.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域划分以及内存溢出异常</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java内存区域划分以及内存溢出异常/</id>
    <published>2018-07-21T11:54:55.000Z</published>
    <updated>2018-07-23T12:15:41.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Java虚拟机的内存区域主要分为：程序计数器，虚拟机栈，本地方法栈，Java堆，方法区🖊 </p><p>其中，<strong>栈</strong>描述<strong>方法</strong>执行，及方法的<em>局部变量和引用</em>；<strong>堆</strong>描述<strong>对象</strong>；<strong>方法区</strong>描述<strong>类</strong>和常量</p><p>其中，栈结构线程私有，堆结构线程共享（方法区描述类，也是堆结构）</p></blockquote><a id="more"></a><h1 id="Java虚拟机运行时数据区域"><a href="#Java虚拟机运行时数据区域" class="headerlink" title="Java虚拟机运行时数据区域"></a>Java虚拟机运行时数据区域</h1><p><img src="/Blog/Java/Java内存区域划分以及内存溢出异常/Java虚拟机运行时数据区.png" alt="Java虚拟机运行时数据区"></p><blockquote><p>上图理解：</p><p><strong>堆</strong>结构线程共享，描述所有的对象（类在方法区中，方法区也是堆）；</p><p><strong>栈</strong>和计数器线程私有，描述方法执行</p></blockquote><p>Java虚拟机在运行时会把它所管理的内存划分为若干个不同的数据区域。大致分为以下：</p><ol><li><p><strong>程序计数器</strong>：在Java中，每个线程都有一个独立的程序计数器，独立存储，该段内存是线程私有的</p></li><li><p><strong>Java虚拟机栈：</strong>描述<strong>方法执行</strong>的内存模型：</p><ul><li><p>每个方法在执行的同时会创建<strong>栈帧</strong>用于存储<strong>局部变量表</strong>、动态链接等信息。</p></li><li><p>其中，局部变量表存放基本类型、对象引用、returnAddress类型。其内存空间大小分配在编译期间就可以完全确定，之后也不会改变。</p></li><li>线程私有的，生命周期与线程相同。</li><li>当线程请求的栈深度大于虚拟机允许的深度，抛出StackOverFlowError异常</li><li>可动态扩展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li><li><p><strong>本地方法栈</strong>：描述<strong>Native方法</strong>的内存模型，其他与虚拟机栈一样。</p></li><li><p><strong>Java堆</strong>：<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。</p><ul><li>被<strong>所有线程共享</strong>这一块内存区域，是Java虚拟机所管理的最大一块内存</li><li>堆是<strong>GC垃圾收集器管理</strong>的主要区域（在普遍使用的分代手机算法中，堆可分为：新生代和老年代）</li><li>对线程来说，还划分出多个线程私有的<strong>本地线程分配缓冲区（TLAB）</strong></li><li>以上无论如何划分，堆存放的都是对象实例，划分只是为了更好地回收和分配内存</li><li>可动态扩展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li><li><p><strong>方法区</strong>：<strong>存储Class</strong>文件的相关信息：已被加载的<strong>类信息</strong>、<strong>常量</strong>、（类变量）静态变量、编译后的代码等</p><ul><li>所有线程共享</li><li><strong>运行时常量池</strong>：Class文件的常量池的信息，在类加载后进入方法区的运行时常量池<ul><li>Java不要求常量一定要编译时产生，可以运行期间产生放入方法区常量池，例如String.intern()</li><li>（此外Class文件中还有类版本、字段、方法、接口等描述信息）</li></ul></li><li>这部分的GC较少，在此区域GC主要为了针对常量池回收和类型卸载。</li><li>其实它也是堆结构，但是要与Java堆区分，称为“Non-Heap”非堆</li><li>可动态拓展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li><li><p><strong>直接内存</strong>：</p><ul><li>可动态拓展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li></ol><h1 id="OutOfMemoryError异常-内存溢出"><a href="#OutOfMemoryError异常-内存溢出" class="headerlink" title="OutOfMemoryError异常(内存溢出)"></a>OutOfMemoryError异常(内存溢出)</h1><p>申请的内存空间超过了系统实际分配的空间<strong>（系统无法满足内存申请）</strong> ，就会发生OutOfMemory异常（以下简称OOM）</p><p>除了程序计数器外，其他几个运行时区域都有可能发生OOM异常</p><h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>堆用于存储对象实例，只要不断创建对象，并且保证GC Roots到对象之间有可达路径以避免对象被垃圾回收，那么对象数量在到达堆最大容量限制是抛出内存溢出OOM异常。</p><p>分清楚是内存泄漏还是内存溢出</p><p><strong>内存泄漏：</strong>申请内存后，无法释放已申请的内存空间 。</p><blockquote><p>比如，你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。 </p></blockquote><p><strong>内存溢出：</strong>申请内存时，没有足够的内存供申请者使用。</p><blockquote><p>比如：给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，内存不够用，就会报OOM，此时内存溢出。</p><p>又比如：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。   </p></blockquote><h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>（HotSpot虚拟机不区分这两个栈）</p><p><strong>StackOverFlow</strong>Error：线程请求的栈深度大于虚拟机允许的深度</p><p><strong>OutOfMemory</strong>Error：扩展栈时无法申请到足够的内存</p><p>单线程测试下，无论是栈容量少，还是栈帧太大，都抛出了StackOverFlow异常</p><p>而在多线程下，通过不断建立内存用量大的线程，迅速耗尽内存空间，会抛出OOM</p><h2 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h2><p>通过<strong>不断产生动态类</strong>（如<strong>反射</strong>和<strong>动态代理</strong>、<strong>JSP</strong>等<strong>会加载Class</strong>的操作），在运行时产生大量的类去填满方法区，直到溢出，抛出OOM。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java虚拟机的内存区域主要分为：程序计数器，虚拟机栈，本地方法栈，Java堆，方法区🖊 &lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;栈&lt;/strong&gt;描述&lt;strong&gt;方法&lt;/strong&gt;执行，及方法的&lt;em&gt;局部变量和引用&lt;/em&gt;；&lt;strong&gt;堆&lt;/strong&gt;描述&lt;strong&gt;对象&lt;/strong&gt;；&lt;strong&gt;方法区&lt;/strong&gt;描述&lt;strong&gt;类&lt;/strong&gt;和常量&lt;/p&gt;
&lt;p&gt;其中，栈结构线程私有，堆结构线程共享（方法区描述类，也是堆结构）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java对象创建、内部数据、如何访问(HotSpot虚拟机下）</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%AF%B9%E8%B1%A1-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java对象-HotSpot虚拟机下/</id>
    <published>2018-07-21T11:54:55.000Z</published>
    <updated>2018-07-23T11:44:44.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>对象创建</strong>：查找类型，确认类加载，分配内存，初始化内存，设置对象，init🖊</p><p><strong>对象构造</strong>：对象头（Markword，类型指针），实例数据</p><p><strong>对象访问定位</strong>：从栈上的引用访问到对象，需要查找到堆中的对象，然后通过对象中的类型指针找到其类型 </p></blockquote><a id="more"></a><h1 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h1><p>这里讲的是普通的Java对象，不包括数组或Class对象</p><ol><li>虚拟机遇到new指令时，<strong>检查指令参数是否能在常量池中定位到这个类的符号引用</strong></li><li>检查这个符号引用代表的类<strong>是否已经被加载、解析和初始化</strong>过</li><li>若未加载，<strong>执行相应的类加载</strong>过程</li><li>为新生对象<strong>分配内存</strong>。需要内存大小在编译时就可完全确定。分配方式有几种，“空闲列表”、“指针碰撞”、“CAS+失败重试保证原子性”，“分配TLAB本地线程分配缓冲”</li><li>对<strong>内存空间初始化零值</strong>。这一步保证了对象的实例字段在不赋初始值就可以直接使用，能访问到队形数据类型所对应的零值</li><li>虚拟机对<strong>对象进行设置</strong>。例如是哪个类、对象哈希码、GC分代年龄、是否设置偏向锁等，对对象头Object Header设置。</li><li><strong>执行<code>init</code>方法</strong>，按照程序员意愿初始化对象。这样才算是真正被完全生产出来对象（在这之前对象内都还是零值）</li></ol><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><ul><li>对象头：MarkWord+类型指针<ul><li>MarkWord：对象自身运行时的设置数据：哈希码HashCode，GC分代年龄，锁状态，持有锁，偏向线程ID等</li><li>类型指针：指向类元数据，虚拟机通过这个指针确定对象的类型</li></ul></li><li>实例数据：包括对象定义的数据，而且还包括从父类继承的、子类定义的数据</li><li>对齐填充：补位的无意义填充</li></ul><h1 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h1><p>Java程序是如何通过引用定位到对象实例数据和类型数据的？</p><p>虚拟机有两钟可实现的方式：</p><ul><li>句柄方式：Java堆中划分出一个句柄池，其中每个句柄存放对象实例数据和类型数据各自的地址信息。特点是稳定，对象被移动只改变句柄不改变reference。</li><li>直接指针：Java堆的对象还存放一个类型的指针。速度更快，节省了1次指针定位的时间开销。（这正是HotSpot虚拟机的实现方式）</li></ul><p><img src="/Blog/Java/Java对象-HotSpot虚拟机下/通过句柄访问对象.png" alt="通过句柄访问对象"></p><p><img src="/Blog/Java/Java对象-HotSpot虚拟机下/通过类型指针访问对象.png" alt="通过类型指针访问对象"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;对象创建&lt;/strong&gt;：查找类型，确认类加载，分配内存，初始化内存，设置对象，init🖊&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象构造&lt;/strong&gt;：对象头（Markword，类型指针），实例数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象访问定位&lt;/strong&gt;：从栈上的引用访问到对象，需要查找到堆中的对象，然后通过对象中的类型指针找到其类型 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库规范及解读</title>
    <link href="https://uncleaaron.github.io/Blog/DataBase/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8F%8A%E8%A7%A3%E8%AF%BB/"/>
    <id>https://uncleaaron.github.io/Blog/DataBase/MySQL数据库规范及解读/</id>
    <published>2018-07-19T07:16:08.000Z</published>
    <updated>2018-07-19T08:36:24.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>使用Mysql的准则 🖊 </p></blockquote><a id="more"></a><h2 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h2><blockquote><p>第一条：必须使用InnoDB存储引擎</p></blockquote><p>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</p><blockquote><p>第二条：必须使用utf8(utf8mb4)字符集</p></blockquote><p>解读：万国码，无需转码，无乱码风险，节省空间，utf8mb4是utf8的超集，由于近年移动设备的增多，emoji表情以及部分不常见汉字在utf8下会表现为乱码，故需要升级至utf8mb4</p><blockquote><p>第三条：数据表、数据字段必须加入中文注释</p></blockquote><p>解读：N年后谁会知道这个a1,a2,a3字段是干嘛的</p><blockquote><p>第四条：禁止使用存储过程、视图、触发器、Event</p></blockquote><p>解读：高并发<strong>大数据</strong>的互联网业务，<strong>架构</strong>设计思路是<em>“解放<strong>数据库</strong>CPU，将计算转移到服务层“</em>，并发量大的情况下，这些功能很可能将数据库拖死，<em>业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”</em>。数据库擅长存储与索引，CPU计算还是上移吧</p><blockquote><p>第五条：禁止存储大文件或者大照片</p></blockquote><p>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI多好</p><h2 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h2><blockquote><p>第一条：只允许<em>使用内网域名，而不是ip连接数据库</em></p></blockquote><p>解读：虽然IP访问更快，域名访问需要内网dns，但是对于大数据库的扩展和迁库考虑，域名更好</p><blockquote><p>第二条：线上环境、开发环境、<strong>测试</strong>环境数据库内网域名遵循命名规范</p></blockquote><p>业务名称：xxx<br>线上环境：dj.xxx.db<br>开发环境：dj.xxx.rdb<br>测试环境：dj.xxx.tdb<br>从库在名称后加-s标识，备库在名称后加-ss标识<br>线上从库：dj.xxx-s.db<br>线上备库：dj.xxx-sss.db</p><blockquote><p>第三条：库名、表名、字段名：小写，下划线风格，不超过32个字符，禁止拼音英文混用</p></blockquote><p>解读：见名知意，方便后续维护</p><blockquote><p>第四条：表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</p></blockquote><p>解读：见名知意，方便后续维护</p><h2 id="三、表和字段设计规范"><a href="#三、表和字段设计规范" class="headerlink" title="三、表和字段设计规范"></a>三、表和字段设计规范</h2><blockquote><p>第一条：禁止使用外键，如果有外键完整性约束，需要应用程序控制</p></blockquote><p>解读：<em>外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql的性能</em>，甚至会造成死锁。高并发情况下容易造成数据库性能，<em>大数据高并发业务场景数据库使用以性能优先</em></p><blockquote><p>第二条：必须把字段定义为NOT NULL并且提供默认值</p></blockquote><p>解读：<br>a) null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化<br>b) null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多<br>c) null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标识<br>d) 对null的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。<em>如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录</em></p><blockquote><p>第三条：禁止使用TEXT、BLOB类型</p></blockquote><p>解读：会浪费更多的磁盘和内存空间，<em>非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能</em></p><blockquote><p>第四条：禁止使用小数存储国币</p></blockquote><p>解读：曾经踩过这样的坑，100元分3天摊销，每天摊销(100/3)元，结果得到3个33.33。后来实施对账系统，始终有几分钱对不齐，郁闷了很久（不是几分钱的事，是业务方质疑的眼神让研发很不爽），最后发现是除法惹的祸<br>解决方案：使用“分”作为单位，这样数据库里就是整数了</p><blockquote><p>第五条：必须使用varchar(20)存储手机号</p></blockquote><p>解读：<br>a) 涉及到区号或者国家代号，可能出现+-()<br>b) 手机号会去做数学运算么？<br>c) varchar可以支持模糊查询，例如：like“138%”</p><blockquote><p>第六条：禁止使用ENUM，可使用TINYINT代替</p></blockquote><p>解读：<br>a) 增加新的ENUM值要做DDL操作<br>b) ENUM的内部实际存储就是整数，你以为自己定义的是字符串？</p><blockquote><p>第七条：表必须有主键，例如自增主键</p></blockquote><p>解读：<br>a) 主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用<br>b) 主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率<br>c) 无主键的表删除，在row模式的主从架构，会导致备库夯住</p><h2 id="四、索引设计规范"><a href="#四、索引设计规范" class="headerlink" title="四、索引设计规范"></a>四、索引设计规范</h2><blockquote><p>第一条：单表索引建议控制在5个以内</p></blockquote><p>解读：一个好的索引设计，可以让你的效率提高几十甚至几百倍，但过多反而适得其反</p><blockquote><p>第二条：单索引字段数不允许超过5个</p></blockquote><p>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了</p><blockquote><p>第三条：禁止在更新十分频繁、区分度不高的属性上建立索引</p></blockquote><p>解读：<br>a) 更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能<br>b) “性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似</p><blockquote><p>第四条:建立组合索引，必须把区分度高的字段放在前面</p></blockquote><p>解读：能够更加有效的过滤数据</p><h2 id="五、SQL使用规范"><a href="#五、SQL使用规范" class="headerlink" title="五、SQL使用规范"></a>五、SQL使用规范</h2><blockquote><p>第一条：禁止使用SELECT *，只获取必要的字段，需要显示说明列属性</p></blockquote><p>解读：<br>a) 读取不需要的列会增加CPU、IO、NET消耗<br>b) 不能有效的利用覆盖索引<br>c) 使用<code>SELECT *</code>容易在增加或者删除字段后出现程序BUG</p><blockquote><p>第二条：禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性</p></blockquote><p>解读：容易在增加或者删除字段后出现程序BUG</p><blockquote><p>第三条：禁止使用属性隐式转换</p></blockquote><p>解读：SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中phone索引，猜猜为什么？<br>int数据类型优先级高于varcher， 该查询会把phone转换为int，因此需要把表中所有数据改成int，所以必须全盘扫描<br>phone是varchar类型，SQL语句带入的是整形，故不会命中索引，加个引号就好了：<br>SELECT uid FROM t_user WHERE phone=’13812345678’</p><blockquote><p>第四条：禁止在WHERE条件的属性上使用函数或者表达式</p></blockquote><p>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描<br>正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</p><blockquote><p>第五条：禁止大表使用JOIN查询，禁止大表使用子查询</p></blockquote><p>解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能，大表指的是数据量在1000万以上的表</p><blockquote><p>第六条：禁止使用OR条件，必须改为IN查询</p></blockquote><p>解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？</p><blockquote><p>第七条：禁止使用负向查询，以及%开头的模糊查询</p></blockquote><p>解读：<br>a) 负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描<br>b) %开头的模糊查询，会导致全表扫描<br>一般来说，WHERE过滤条件不会只带这么一个“负向查询条件”，还会有其他过滤条件，举个例子：查询沈剑已完成订单之外的订单（好拗口）：<br>SELECT oid FROM t_order WHERE uid=123 AND status != 1;<br>订单表5000w数据，但uid=123就会迅速的将数据量过滤到很少的级别（uid建立了索引），此时再接上一个负向的查询条件就无所谓了，扫描的行数本身就会很少<br>但如果要查询所有已完成订单之外的订单：<br>SELECT oid FROM t_order WHERE status != 1;<br>这就挂了，立马CPU100%，status索引会失效，负向查询导致全表扫描</p><blockquote><p>第八条：应用程序必须捕获SQL异常，并有相应处理</p></blockquote><p>解读：方便维护，及时“查漏补缺”</p><p><strong>总结：大数据量高并发的互联网业务，极大影响数据库性能的都不让用，不让用哟。</strong></p><p>转自：<a href="https://zhuanlan.zhihu.com/p/32586602" target="_blank" rel="noopener">知乎：SangSir</a>的文章</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用Mysql的准则 🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>领域模型中的实体类的4种类型VO,DTO,DO,PO</title>
    <link href="https://uncleaaron.github.io/Blog/Java/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%9A%844%E7%A7%8D%E7%B1%BB%E5%9E%8BVO-DTO-DO-PO/"/>
    <id>https://uncleaaron.github.io/Blog/Java/领域模型中的实体类的4种类型VO-DTO-DO-PO/</id>
    <published>2018-07-19T07:14:08.000Z</published>
    <updated>2018-07-21T16:58:40.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>经常会接触到VO，DO，DTO的概念，本文从领域建模中的实体划分和项目中的实际应用情况两个角度，对这几个概念进行简析 🖊 </p></blockquote><a id="more"></a><p>在项目应用中，VO对应于页面上需要显示的数据（表单），DO对应于数据库中存储的数据（数据表），DTO对应于除二者之外需要进行传递的数据。 </p><p>领域模型中的实体类分为四种类型：VO、DTO、DO、PO，各种实体类用于不同业务层次间的交互，并会在层次内实现实体类之间的转化。</p><p>业务分层为：视图层（VIEW+ACTION），服务层（SERVICE），持久层（DAO） </p><p>相应各层间实体的传递如下图：  </p><p> <img src="/Blog/Java/领域模型中的实体类的4种类型VO-DTO-DO-PO/领域模型.jpg" alt="领域模型"></p><p>项目中我们并没有严格遵循这种传递关系，但这种和业务层次的关联对我们理解各实体类的作用是有帮助的。（我们没有接触到PO的原因，我理解为ORM对PO进行了封装） </p><p>概念：</p><ul><li><strong>VO（View Object）</strong>：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</li><li><strong>DTO（Data Transfer Object）</strong>：数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。</li><li><strong>DO（Domain Object）</strong>：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</li><li><strong>PO（PersistentObject）</strong>：持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。 </li></ul><p>模型：</p><p> 下面以一个时序图建立简单模型来描述上述对象在三层架构应用中的位置 </p><ul><li><p>用户发出请求（可能是填写表单），表单的数据在展示层被匹配为VO。</p></li><li><p>展示层把VO转换为服务层对应方法所要求的DTO，传送给服务层。 l 服务层首先根据DTO的数据构造（或重建）一个DO，调用DO的业务方法完成具体业务。 </p></li><li>服务层把DO转换为持久层对应的PO（可以使用ORM工具，也可以不用），调用持久层的持久化方法，把PO传递给它，完成持久化操作。</li><li><p>对于一个逆向操作，如读取数据，也是用类似的方式转换和传递，略。</p><p>三、项目中的实体类</p></li></ul><p>项目中常见的实体类有VO，DO和DTO，命名规则也常是以相应字符串结尾，如VO.Java。</p><p>但是DTO不总是遵循这个规则，而通常与他的用途有关，如写成Query.java，表示存储了一个查询条件。</p><p>项目中实体类出现的业务层次也没有这么严格，例如我们可以在视图层就组装一个DO，也可以将一个VO从持久层传出来，所以与业务分层相关联的划分方法显得有些冗余。</p><p>从项目代码中抽象出的理解是：VO对应于页面上需要显示的数据，DO对应于数据库中存储的数据，DTO对应于除二者之外需要进行传递的数据。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;经常会接触到VO，DO，DTO的概念，本文从领域建模中的实体划分和项目中的实际应用情况两个角度，对这几个概念进行简析 🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2.x中静态资源会被自定义拦截器拦截</title>
    <link href="https://uncleaaron.github.io/Blog/JavaWeb/SpringBoot2.x%E4%B8%AD%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AF%B9%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>https://uncleaaron.github.io/Blog/JavaWeb/SpringBoot2.x中拦截器对静态资源的影响/</id>
    <published>2018-07-17T12:41:09.000Z</published>
    <updated>2018-07-28T19:09:19.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>今天用Sping Boot2.0.3写项目编写WebMvc的JavaConfig时，SpringBoot2.x中静态资源会被自定义拦截器拦截，研究了大半天，总结一下我的方法，若有更好的方法欢迎讨论，向大佬们学习一下🖊 </p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置视图映射(页面跳转)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">"/index.html"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">        registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">        registry.addViewController(<span class="string">"/main.html"</span>).setViewName(<span class="string">"dashboard"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置拦截器</span></span><br><span class="line"><span class="comment">     * SpringBoot-2.x和Spring5.0的静态资源也会执行自定义的拦截器，因此在配置拦截器的时候需要指定排除静态资源的访问路径</span></span><br><span class="line"><span class="comment">     * 因此配置拦截器的时候还要拦截静态资源的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LoginHandleInterceptor()).addPathPatterns(<span class="string">"/**"</span>)    <span class="comment">// 拦截全局路径请求，下为放行某些url的请求</span></span><br><span class="line">                .excludePathPatterns(<span class="string">"/"</span>, <span class="string">"/index.html"</span>, <span class="string">"/user/login"</span>, <span class="string">"/resources/**"</span>);    <span class="comment">// 1. 注意这个/resources/**是我自定义的资源路径 2. 不要拦截需要请求的路径，比如这里的/user/login</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义静态资源URL</span></span><br><span class="line"><span class="comment">     * 使用了自定义拦截器后SpringBoot2.x的静态资源也会使用这个拦截器，</span></span><br><span class="line"><span class="comment">     * 而且好像屏蔽了自动配置的静态资源Handlers设置，</span></span><br><span class="line"><span class="comment">     * 上面的拦截器移除似乎需要这个方法进行解释路径url，之后才能在拦截器里才能使用这些url。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 在这里注册了一个静态资源url为/resources/**，但是这样的话，每个静态资源前面都需要加上/resources/前缀</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">"/resources/**"</span>).addResourceLocations(<span class="string">"classpath:/META-INF/resources/"</span>, <span class="string">"classpath:/static/"</span>, <span class="string">"classpath:/resources/"</span>, <span class="string">"classpath:/public/"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>  <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Signin Template for Bootstrap<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap core CSS --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意这里路径因为上面的WebMvcCOnfig类中设置了静态资源定位URL，为/resources/开头，所以要加上/resource/ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/css/bootstrap.min.css"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/resources/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Custom styles for this template --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/css/signin.css"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/resources/css/signin.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-signin"</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/user/login&#125;"</span> <span class="attr">th:method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"mb-4"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/resources/images/bootstrap-solid.svg&#125;"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"72"</span> <span class="attr">height</span>=<span class="string">"72"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"h3 mb-3 font-weight-normal"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.tips&#125;"</span>&gt;</span>Please sign in<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 错误消息提示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: red;"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;msg&#125;"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not #strings.isEmpty(msg)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"inputEmail"</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"inputEmail"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"Username"</span> <span class="attr">th:placeholder</span>=<span class="string">"#&#123;login.username&#125;"</span> <span class="attr">required</span> <span class="attr">autofocus</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"inputPassword"</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"inputPassword"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"Password"</span> <span class="attr">th:placeholder</span>=<span class="string">"#&#123;login.password&#125;"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"checkbox mb-3"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"remember-me"</span>&gt;</span> [[#&#123;login.remember&#125;]]</span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-lg btn-primary btn-block"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.btn&#125;"</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"mt-5 mb-3 text-muted"</span>&gt;</span>&amp;copy; 2017-2018<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/index.html(l='zh_CN')&#125;"</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/index.html(l='en_US')&#125;"</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;今天用Sping Boot2.0.3写项目编写WebMvc的JavaConfig时，SpringBoot2.x中静态资源会被自定义拦截器拦截，研究了大半天，总结一下我的方法，若有更好的方法欢迎讨论，向大佬们学习一下🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
      <category term="Java 开发问题总结" scheme="https://uncleaaron.github.io/Blog/tags/Java-%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="Spring" scheme="https://uncleaaron.github.io/Blog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>WebMvcConfigurerAdapter在Spring5.0中被弃用</title>
    <link href="https://uncleaaron.github.io/Blog/JavaWeb/WebMvcConfigurerAdaptor%E5%9C%A8Spring5.0%E8%A2%AB%E5%BC%83%E7%94%A8/"/>
    <id>https://uncleaaron.github.io/Blog/JavaWeb/WebMvcConfigurerAdaptor在Spring5.0被弃用/</id>
    <published>2018-07-17T12:41:09.000Z</published>
    <updated>2018-07-27T14:59:34.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>今天用Sping Boot2.0.3写项目编写WebMvc的JavaConfig时，发现WebMvcConfigurerAdapter已经被标注弃用，便去找了下Spring的API，发现官方开始推荐<strong>直接实现WebMvcConfigurer接口</strong>的方式来配置SpringMVC。（原因在Java8接口默认方法替代了原来适配器的作用）🖊 </p></blockquote><a id="more"></a><h2 id="在SpringBoot2-0及Spring-5-0-WebMvcConfigurerAdapter已被废弃，目前找到解决方案就有两种"><a href="#在SpringBoot2-0及Spring-5-0-WebMvcConfigurerAdapter已被废弃，目前找到解决方案就有两种" class="headerlink" title="在SpringBoot2.0及Spring 5.0 WebMvcConfigurerAdapter已被废弃，目前找到解决方案就有两种"></a>在SpringBoot2.0及Spring 5.0 WebMvcConfigurerAdapter已被废弃，目前找到解决方案就有两种</h2><hr><h3 id="1-直接实现WebMvcConfigurer-（官方推荐）"><a href="#1-直接实现WebMvcConfigurer-（官方推荐）" class="headerlink" title="1. 直接实现WebMvcConfigurer （官方推荐）"></a>1. 直接实现WebMvcConfigurer （官方推荐）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfg</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-直接继承WebMvcConfigurationSupport"><a href="#2-直接继承WebMvcConfigurationSupport" class="headerlink" title="2. 直接继承WebMvcConfigurationSupport"></a>2. 直接继承WebMvcConfigurationSupport</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfg</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebMvcConfigurerAdapter的官方api描述"><a href="#WebMvcConfigurerAdapter的官方api描述" class="headerlink" title="WebMvcConfigurerAdapter的官方api描述"></a>WebMvcConfigurerAdapter的官方api描述</h3><p>WebMvcConfigurerAdapter – Deprecated.<br>as of 5.0 WebMvcConfigurer has default methods (made possible by a Java 8 baseline) and can be implemented directly without the need for this adapter.<br>An implementation of WebMvcConfigurer with empty methods allowing subclasses to override only the methods they’re interested in.</p><blockquote><p>Java8中WebMvcConfigurer实现了默认方法，不需要这个适配器了。</p><p>因为WebMvcConfigurer接口实现了默认方法，使用者可以自由实现想配置的方法</p></blockquote><p>解释：</p><p>在Java8以前，因为实现接口的时候每个接口方法必须需要实现，所以导致编写JavaConfig配置类很困难，不能自由选择配置类，所以Spring5.0以前用一个适配器抽象类实现了WebMvcConfigurer的所有方法（但其实都是空的），这样可以满足用户可以选择自己需要的配置功能进行选择性配置，而不需要全部实现。</p><p>而现在Java8提供了接口默认实现方法，接口的默认方法完全替代了这个适配器类的目的，可以满足仅在接口层面用户就能选择自己想实现的方法，没有实现的方法就用默认方法代替，原来的适配器就多余了。因此推荐第一种方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;今天用Sping Boot2.0.3写项目编写WebMvc的JavaConfig时，发现WebMvcConfigurerAdapter已经被标注弃用，便去找了下Spring的API，发现官方开始推荐&lt;strong&gt;直接实现WebMvcConfigurer接口&lt;/strong&gt;的方式来配置SpringMVC。（原因在Java8接口默认方法替代了原来适配器的作用）🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
      <category term="Java 开发问题总结" scheme="https://uncleaaron.github.io/Blog/tags/Java-%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="Spring" scheme="https://uncleaaron.github.io/Blog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>使SpringMVC支持跨域访问的几种解决方法</title>
    <link href="https://uncleaaron.github.io/Blog/JavaWeb/%E4%BD%BFSpringMVC%E6%94%AF%E6%8C%81%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://uncleaaron.github.io/Blog/JavaWeb/使SpringMVC支持跨域访问的几种解决方法/</id>
    <published>2018-07-17T12:41:09.000Z</published>
    <updated>2018-07-21T14:48:33.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>由于最近又开始写博客，刚好碰到的开发问题都重新总结一下。</p><p>今天在写Controller的时候又想起<strong>跨域访问</strong>支持的问题，在这里总结一下我以前用过的方法🖊 </p></blockquote><a id="more"></a><h1 id="1-在Controller类或方法上加入-CrossOrigin注解"><a href="#1-在Controller类或方法上加入-CrossOrigin注解" class="headerlink" title="1. 在Controller类或方法上加入@CrossOrigin注解"></a>1. 在Controller类或方法上加入@CrossOrigin注解</h1><p><strong>@CrossOrigin</strong>有两个参数</p><p>origins：允许访问的域列表</p><p>maxAge：飞行前响应的缓存持续时间的最大年龄（以秒为单位） </p><h2 id="1-1-使方法支持跨域访问"><a href="#1-1-使方法支持跨域访问" class="headerlink" title="1.1. 使方法支持跨域访问"></a>1.1. 使方法支持跨域访问</h2><p>在方法上加<strong><code>@CrossOrigin</code></strong>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/crossDomain2"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">crossDomain2</span><span class="params">(HttpServletRequest req, HttpServletResponse res, String name)</span></span>&#123;</span><br><span class="line">    ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-使Controller类支持跨域访问"><a href="#1-2-使Controller类支持跨域访问" class="headerlink" title="1.2. 使Controller类支持跨域访问"></a>1.2. 使Controller类支持跨域访问</h2><p>在类上添加<strong><code>@CrossOrigin</code></strong>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="meta">@CrossOrigin</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;  </span><br><span class="line">    ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-重写WebMvcConfigurerAdapter-addCorsMapping方法"><a href="#2-重写WebMvcConfigurerAdapter-addCorsMapping方法" class="headerlink" title="2. 重写WebMvcConfigurerAdapter.addCorsMapping方法"></a>2. 重写WebMvcConfigurerAdapter.addCorsMapping方法</h1><ol><li>写一个Conroller的基类Cors，继承<strong><code>WebMvcConfigurerAdapter</code></strong>类，并重写<strong><code>addCorsMappings(CorsRegistry)</code></strong>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cors</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">        .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">        .allowedMethods(<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"OPTIONS"</span>, <span class="string">"DELETE"</span>, <span class="string">"PATCH"</span>)</span><br><span class="line">          .allowCredentials(<span class="keyword">true</span>).maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实现的Controller继承这个基类Cors</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStarter</span> <span class="keyword">extends</span> <span class="title">Cors</span> </span>&#123;<span class="comment">//继承了刚才实现的WebMvcConfigurerAdapter的子类Cors，从而实现支持跨域访问</span></span><br><span class="line">    <span class="comment">// 省略具体方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-直接拦截在header上加入响应头"><a href="#3-直接拦截在header上加入响应头" class="headerlink" title="3. 直接拦截在header上加入响应头"></a>3. 直接拦截在header上加入响应头</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>); <span class="comment">//自定义中间件，设置跨域需要的响应头。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;由于最近又开始写博客，刚好碰到的开发问题都重新总结一下。&lt;/p&gt;
&lt;p&gt;今天在写Controller的时候又想起&lt;strong&gt;跨域访问&lt;/strong&gt;支持的问题，在这里总结一下我以前用过的方法🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
      <category term="Java 开发问题总结" scheme="https://uncleaaron.github.io/Blog/tags/Java-%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux程序设计</title>
    <link href="https://uncleaaron.github.io/Blog/Linux/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://uncleaaron.github.io/Blog/Linux/Linux程序设计/</id>
    <published>2018-06-16T16:05:10.000Z</published>
    <updated>2018-07-17T02:20:53.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>简单总结了Shell脚本设计，C in Linux 的编程和编译，以及GTK+的简单原理</p></blockquote><a id="more"></a><h1 id="Shell程序设计"><a href="#Shell程序设计" class="headerlink" title="Shell程序设计"></a>Shell程序设计</h1><h2 id="bash程序执行步骤"><a href="#bash程序执行步骤" class="headerlink" title="bash程序执行步骤"></a>bash程序执行步骤</h2><ol><li>编辑保存<code>vi</code></li><li>赋可执行权限<code>chmod</code></li><li><code>./filename.sh</code>执行</li></ol><h2 id="bash程序结构"><a href="#bash程序结构" class="headerlink" title="bash程序结构"></a>bash程序结构</h2><p># file.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash****Shell类型****</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释</span></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">funn</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....<span class="comment"># 主过程</span></span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量=值<span class="comment"># "="两边不能留空格</span></span><br></pre></td></tr></table></figure><p>变量都会被默认成字符串</p><h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><p>用户自定义变量要加<code>$</code>，加<code>{}</code>可以同其他字符分开（建议添加）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;xxx&#125;</span></span><br></pre></td></tr></table></figure><h4 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h4><p><strong>会替换</strong><code>$</code><strong>变量</strong>成值。参数中包含空格也要用双引号。</p><h4 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h4><p><strong>字符串</strong>值，不会替换<code>$</code>变量</p><h4 id="倒引号"><a href="#倒引号" class="headerlink" title="倒引号 "></a>倒引号 <code></code></h4><p><strong>替换命令</strong>为其执行结果</p><h3 id="特定变量"><a href="#特定变量" class="headerlink" title="特定变量"></a>特定变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$@</span><span class="comment"># 参数列表（数组）</span></span><br><span class="line">$*<span class="comment"># 参数列表（字符串）</span></span><br><span class="line"><span class="variable">$#</span><span class="comment"># 参数个数</span></span><br><span class="line"><span class="variable">$n</span><span class="comment"># 位置参数$1，$2，$3...$n</span></span><br><span class="line"><span class="variable">$0</span><span class="comment"># 本脚本文件名</span></span><br><span class="line">$$<span class="comment"># 本程序进程号</span></span><br><span class="line">$?<span class="comment"># 上一条命令或函数的返回值</span></span><br><span class="line"><span class="variable">$HOME</span><span class="comment"># 用户主目录</span></span><br></pre></td></tr></table></figure><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><h3 id="expr-命令"><a href="#expr-命令" class="headerlink" title="expr 命令"></a>expr 命令</h3><p>计算算术表达式，支持 <code>+</code>、<code>-</code>、<code>\*</code>、<code>/</code>、<code>%</code>（<em>要<code></code>\</em><code></code>进行转移，否则会错误）</p><p>支持<code>|</code>，<code>&amp;</code>，<code>&gt;</code>，<code>&gt;=</code>，<code>!=</code>，<code>=</code>等逻辑运算，<code>|</code>,<code>&gt;</code>,<code>&lt;</code>要用<code>\</code>转义才能使用</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr arg</span><br></pre></td></tr></table></figure><p>数字符 和 符号 间要<strong>空格</strong></p><p>要改变运算次序的话需要使用<code></code>倒引号</p><figure class="highlight plain"><figcaption><span>`expr 5 \* 7` + 5```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### let 命令</span><br><span class="line"></span><br><span class="line">**语法**：给a赋值（语法中**不用空格**！）</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">let a=(5+7)/3</span><br></pre></td></tr></table></figure><h3 id="…-运算"><a href="#…-运算" class="headerlink" title="$((…))运算"></a>$((…))运算</h3><p>直接运算得出结果</p><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $((5+7))</span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p><strong>0真，1假</strong>（与熟知C语言判断相反）</p><p><strong>语法：</strong>注意！<strong>中括号</strong>两边<strong>要空格</strong>！！！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 条件判断语句 ]</span><br></pre></td></tr></table></figure><p><strong>多重条件判断组合</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-a<span class="comment"># 与</span></span><br><span class="line">-o<span class="comment"># 或</span></span><br><span class="line">!<span class="comment"># 非</span></span><br></pre></td></tr></table></figure><p><strong>算术比较：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a -eq b<span class="comment"># 相等（equal）</span></span><br><span class="line">a -ne b<span class="comment"># 不相等（not equal）</span></span><br><span class="line">a -gt b<span class="comment"># a大于b（greater then）</span></span><br><span class="line">a -ge b<span class="comment"># a大于等于b（greater equal）</span></span><br><span class="line">a -lt b<span class="comment"># a小于b（less then）</span></span><br><span class="line">a -le b<span class="comment"># a小于或等于b（less equal）</span></span><br><span class="line">!expr<span class="comment"># 假则真，真则假</span></span><br></pre></td></tr></table></figure><p><strong>字符比较：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = s2<span class="comment"># 字符串相同</span></span><br><span class="line">s1 != s2<span class="comment"># 字符串不同</span></span><br><span class="line">-n str1<span class="comment"># 字符串不为空</span></span><br><span class="line">-z str1<span class="comment"># 字符串为空</span></span><br></pre></td></tr></table></figure><p><strong>文件判断</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-d file<span class="comment"># 是目录</span></span><br><span class="line">-e file<span class="comment"># 存在</span></span><br><span class="line">-f file<span class="comment"># 是文件</span></span><br></pre></td></tr></table></figure><h3 id="if-分支语句"><a href="#if-分支语句" class="headerlink" title="if 分支语句"></a>if 分支语句</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">elif</span> [ 条件2 ]; <span class="keyword">then</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="case-模式匹配-分支语句"><a href="#case-模式匹配-分支语句" class="headerlink" title="case 模式匹配 分支语句"></a>case 模式匹配 分支语句</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 条件1 <span class="keyword">in</span></span><br><span class="line">模式n)</span><br><span class="line">命令n</span><br><span class="line">;;</span><br><span class="line">*)<span class="comment">#default</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p><strong>模式匹配配对符：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?<span class="comment"># 任意一个字符</span></span><br><span class="line">*<span class="comment"># 任意字符串</span></span><br><span class="line">[]<span class="comment"># 括号中的任意字符</span></span><br><span class="line">[!]<span class="comment"># 不在括号中的任意字符</span></span><br><span class="line">&#123;c1,c2&#125;<span class="comment"># 和c1或者c2匹配都可</span></span><br></pre></td></tr></table></figure><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 [<span class="keyword">in</span> 列表]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>可用 <code>in 1,2,3,4...</code>或者默认使用<code>in $@</code>。其中<code>$@</code>是参数数组</p><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>/until [ 条件 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">function</span>] 函数名()&#123;</span><br><span class="line">    命令</span><br><span class="line">    [<span class="built_in">return</span> xx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果最后不使用return返回，函数返回的就是最后一条命令的返回值</li></ul><h1 id="C-in-Linux"><a href="#C-in-Linux" class="headerlink" title="C in Linux"></a>C in Linux</h1><h2 id="gcc编译过程"><a href="#gcc编译过程" class="headerlink" title="gcc编译过程"></a>gcc编译过程</h2><p><img src="/Blog/Linux/Linux程序设计/gcc编译过程.png" alt="gcc编译过程"></p><h2 id="gcc命令"><a href="#gcc命令" class="headerlink" title="gcc命令"></a>gcc命令</h2><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc [选项] [filename]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c<span class="comment"># 编译.c文件生成.o文件，不生成可执行文件</span></span><br><span class="line">-o filename<span class="comment"># 指定生成文件名称为filename。不设这个选项则默认为filename.xx（根据编译阶段生成后缀文件）</span></span><br><span class="line">-Idir<span class="comment"># 在编译时增加搜索头文件的目录</span></span><br><span class="line">-Ldir<span class="comment"># 在编译时增加搜索库的目录</span></span><br><span class="line">-lname<span class="comment"># 在编译时装在名为libname.a的函数库，需要存在于系统预设目录或-L设置的目录。</span></span><br><span class="line">-g<span class="comment"># 加入调试信息</span></span><br><span class="line">-E<span class="comment"># 生成.i预处理文件</span></span><br><span class="line">-S<span class="comment"># 生成.s汇编文件</span></span><br></pre></td></tr></table></figure><p>总结：在编译过程中。除非使用了”-c”，“-S”,或”-E”选项(或者编译错误阻止了完整的过程)，否则统一完整链接步骤。 </p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><strong>分步编译</strong></p><p>先用<code>-c</code>,<code>-S</code>,<code>-E</code>中断编译过程，生成中间文件，再用<code>gcc 中间文件</code>完成编译</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br><span class="line">gcc -c say_hello.c -o say_hello.o</span><br><span class="line">gcc hello.o say_hello.o -o hello</span><br></pre></td></tr></table></figure><p><strong>一步编译</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c say_hello.c -o hello</span><br></pre></td></tr></table></figure><p><strong>使用<code>-Idirname</code>增加搜索头文件目录</strong></p><p>示例：</p><p>当前目录为./hello.c    ./functions/say_hello.h    ./functions/say_hello.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c <span class="built_in">functions</span>/say_hello.c -o hello -Ifunctions</span><br></pre></td></tr></table></figure><h2 id="make-软件维护工具"><a href="#make-软件维护工具" class="headerlink" title="make 软件维护工具"></a>make 软件维护工具</h2><h3 id="makefile文件"><a href="#makefile文件" class="headerlink" title="makefile文件"></a>makefile文件</h3><p><strong>格式：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">目标文件: 依赖项列表</span></span><br><span class="line">命令</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>依赖项可以不写.h文件，但一定要写清.c文件的路径</p><p>示例：</p><p>当前目录为./hello.c    ./functions/say_hello.h    ./functions/say_hello.c</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:hello.o say_hello.o</span></span><br><span class="line">gcc hello.o say_hello.o -o hello</span><br><span class="line"><span class="section">hello.o:hello.c say_hello.h</span></span><br><span class="line">gcc -c hello.c -o hello.o -Ifunctions</span><br><span class="line"><span class="section">say_hello.o:functions/say_hello.c</span></span><br><span class="line">gcc -c functions/say_hello.c -o say_hello.o -Ifunctions</span><br></pre></td></tr></table></figure><p>makefile可以使用变量宏命令<code>${}</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CC=-Wall-c</span><br><span class="line"><span class="section">hello:$&#123;CC&#125;</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><h3 id="使用makefile"><a href="#使用makefile" class="headerlink" title="使用makefile"></a>使用makefile</h3><p>在存放makefile文件的目录下使用：<code>make</code></p><h2 id="调试工具-gdb"><a href="#调试工具-gdb" class="headerlink" title="调试工具 gdb"></a>调试工具 gdb</h2><ol><li>设置断点</li><li>监视变量</li><li>单步执行</li><li>修改变量值</li></ol><p><strong>进入gdb：</strong><code>gdb</code></p><h3 id="使用gdb"><a href="#使用gdb" class="headerlink" title="使用gdb"></a>使用gdb</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file<span class="comment"># 装入可执行文件</span></span><br><span class="line">list<span class="comment"># 查看源代码</span></span><br><span class="line">quit<span class="comment"># 退出gdb</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行程序</span></span><br><span class="line"><span class="built_in">break</span> &lt;line&gt;<span class="comment"># 设置断点</span></span><br><span class="line">next<span class="comment"># 单步执行</span></span><br><span class="line">step<span class="comment"># 单步执行到函数内部</span></span><br><span class="line">run<span class="comment"># 执行程序</span></span><br><span class="line"><span class="built_in">kill</span><span class="comment"># 终止正在调试的程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视变量</span></span><br><span class="line">watch<span class="comment"># 监视变量</span></span><br><span class="line"><span class="built_in">print</span><span class="comment"># 打印变量</span></span><br></pre></td></tr></table></figure><h2 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h2><h3 id="静态函数库"><a href="#静态函数库" class="headerlink" title="静态函数库"></a>静态函数库</h3><p><strong>库文件名</strong>：<code>libxxxxx.a</code></p><p>静态函数库文件比较大，因为整个函数库的所有代码都会被整合编译到目标代码中，所以使用静态库编译后的程序不需要外部函数库支持，因为都已经编译进去了。但是如果今天函数库改变了就需要重新编译。</p><p><strong>创建</strong></p><p>编译生成.o文件：<code>gcc -c pr1.c pr2.c</code></p><p>链接静态库：<code>ar -rsv libpr.a pr1.o pr2.o</code></p><p><strong>使用</strong></p><p>加载库文件编译：<code>gcc -o main main.c -L./ -lpr</code></p><h3 id="动态函数库"><a href="#动态函数库" class="headerlink" title="动态函数库"></a>动态函数库</h3><p><strong>库文件名：</strong><code>libxxxx.so</code></p><p>动态函数库在编译时没有被编译进目标代码中，当程序执行到时才会调用函数里的相应函数。所以使用动态函数库产生的可执行文件较小。</p><p><strong>创建</strong></p><p>生成动态库：<code>gcc -fpic -shared -o libpr.so pr1.c pr2.c</code></p><p><strong>使用</strong></p><p>调用动态库：<code>gcc -o main_so main.c ./libpr.so</code></p><h1 id="GTK"><a href="#GTK" class="headerlink" title="GTK+"></a>GTK+</h1><h2 id="GTK-控件"><a href="#GTK-控件" class="headerlink" title="GTK+控件"></a>GTK+控件</h2><p><strong>GtkWidget</strong>：GTK控件的父类，所有控件按照此类型返回</p><p>创建控件：<code>GtkWidget * gtk_xxxx_new(GtkNodeType type 或者 void)</code></p><p>设置xxx：<code>void gtk_xxx_set_xxx(GtkNode *xxx, XX message)</code></p><p>读取xxx：<code>xx gtk_xxx_get_xxx(GtkNode *xxx)</code></p><p>存放进窗体：<code>gtk_container_add(GTK_CONTAINER(windowxx), xxxx)</code></p><p>显示窗体：<code>gtk_widget_show_all(window)</code></p><p>界面布局采用横向<code>hbox</code>和纵向<code>vbox</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    GtkWidget *window, *button;<span class="comment">//声明window和button为GtkWidget，后面使用需要类型转换</span></span><br><span class="line">    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);<span class="comment">// 初始化window变量为GTK....类型</span></span><br><span class="line">    gtk_window_set_title(GTK_WINDOW(window), <span class="string">"HELLO WORLD"</span>);<span class="comment">//这里用的大写是类型转换</span></span><br><span class="line">    button = gtk_button_new_with_label(<span class="string">"Hello World"</span>);<span class="comment">// 初始化button变量为button类型</span></span><br><span class="line">    gtk_container_add(GTK_CONTAINER(window)， button)<span class="comment">//类型转换成Container，button放入window</span></span><br><span class="line">    gtk_widget_show_all(window);</span><br><span class="line">    gtk_main();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调函数、信号"><a href="#回调函数、信号" class="headerlink" title="回调函数、信号"></a>回调函数、信号</h2><p>GTK+用信号（signal）和回调函数（callback）处理外部事件。</p><h3 id="信号与回调函数绑定"><a href="#信号与回调函数绑定" class="headerlink" title="信号与回调函数绑定"></a>信号与回调函数绑定</h3><p>采用<code>g_signal_connect</code>函数来完成信号和回调函数绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g_signal_connect(gpointer *object,<span class="comment">// 连接信号的对象</span></span><br><span class="line">                <span class="keyword">const</span> gchar *name,<span class="comment">// 信号名</span></span><br><span class="line">                Gcallback func,<span class="comment">// 回调函数名</span></span><br><span class="line">                gpointer user_data)<span class="comment">// 回调函数参数的指针</span></span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数的<strong>函数原型</strong>（用户自己定义）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback_func</span><span class="params">(GtkWidget *widget,<span class="comment">// 发出信号的控件的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">              gpointer callback_data)</span><span class="comment">// 传递进函数的数据</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;简单总结了Shell脚本设计，C in Linux 的编程和编译，以及GTK+的简单原理&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Vi</title>
    <link href="https://uncleaaron.github.io/Blog/Linux/Vim%E7%AE%80%E6%98%93%E7%AC%94%E8%AE%B0/"/>
    <id>https://uncleaaron.github.io/Blog/Linux/Vim简易笔记/</id>
    <published>2018-06-11T06:37:58.000Z</published>
    <updated>2018-07-16T11:46:30.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>总结了Vi的使用</p></blockquote><a id="more"></a><p><img src="/Blog/Linux/Vim简易笔记/Vi.png" alt="Vi"></p><h2 id="末行模式（进出、搜索、替换）"><a href="#末行模式（进出、搜索、替换）" class="headerlink" title="末行模式（进出、搜索、替换）"></a>末行模式（进出、搜索、替换）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:w<span class="comment"># 保存</span></span><br><span class="line">:w filename<span class="comment"># 另存为</span></span><br><span class="line">:q<span class="comment"># 退出</span></span><br><span class="line">:q!<span class="comment"># 退出不保存</span></span><br><span class="line">:wq<span class="comment"># 退出保存</span></span><br><span class="line">:x<span class="comment"># 加密保存</span></span><br></pre></td></tr></table></figure><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/&lt;pattern&gt;<span class="comment"># 从光标向下搜索</span></span><br><span class="line">?&lt;pattern&gt;<span class="comment"># 从光标向上搜索</span></span><br></pre></td></tr></table></figure><p>n：向下遍历光标</p><p>N：向上遍历光标</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>(:s/x/y普通替换本行第一个。最后加/g替换本行全部 , :%s/x/y 替换全部行第一个，这基础上加/g替换全文)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:s/old/new<span class="comment"># 替换本行首次出现的old</span></span><br><span class="line">:s/old/new/g<span class="comment"># 替换本行全部</span></span><br><span class="line">:%s/old/new/g<span class="comment"># 替换全文（全部行全部）</span></span><br><span class="line">:n,m s/old/new/g<span class="comment">#替换n-m行的全部old</span></span><br></pre></td></tr></table></figure><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><table><thead><tr><th style="text-align:center">h</th><th style="text-align:center">j</th><th style="text-align:center">k</th><th style="text-align:center">l</th></tr></thead><tbody><tr><td style="text-align:center">左</td><td style="text-align:center">下</td><td style="text-align:center">上</td><td style="text-align:center">右</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">k j h l<span class="comment"># 上下左右</span></span><br><span class="line">0<span class="comment"># 行首</span></span><br><span class="line">^<span class="comment"># 行首</span></span><br><span class="line">$<span class="comment"># 行尾</span></span><br><span class="line">w<span class="comment"># 下一个字首</span></span><br><span class="line">b<span class="comment"># 当前字首，已经在字首则到上个字首</span></span><br><span class="line">e<span class="comment"># 当前字尾，已经在字尾则到下个字尾</span></span><br><span class="line">nw<span class="comment"># 右移n字</span></span><br><span class="line">nb<span class="comment"># 左移n字</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">H<span class="comment"># 当前屏幕最顶端（Highest）</span></span><br><span class="line">nH<span class="comment"># 当前屏第n行</span></span><br><span class="line">gg<span class="comment"># 文首</span></span><br><span class="line">G<span class="comment"># 文末</span></span><br><span class="line">n+<span class="comment"># 后跳n行</span></span><br><span class="line">n-<span class="comment"># 前跳n行</span></span><br><span class="line">nG<span class="comment"># 跳到第n行</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="comment"># 本句首</span></span><br><span class="line">)<span class="comment"># 下一句首</span></span><br><span class="line">&#123;<span class="comment"># 本段首</span></span><br><span class="line">&#125;<span class="comment"># 本段末</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+b<span class="comment"># 向上翻一页(back)</span></span><br><span class="line">Ctrl+f<span class="comment"># 向下翻一页（front）</span></span><br><span class="line">Ctrl+u<span class="comment"># 向前翻半页（up）</span></span><br><span class="line">Ctrl+d<span class="comment"># 向下翻半页（down）</span></span><br></pre></td></tr></table></figure><h2 id="编辑指令"><a href="#编辑指令" class="headerlink" title="编辑指令"></a>编辑指令</h2><h3 id="删除（x-d）"><a href="#删除（x-d）" class="headerlink" title="删除（x, d）"></a>删除（x, d）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x<span class="comment"># 删除字符</span></span><br><span class="line">nx<span class="comment"># 删除从光标开始的n个字符</span></span><br><span class="line">dd<span class="comment"># 删除行</span></span><br><span class="line">ndd<span class="comment">#删除包括当前行的n行</span></span><br></pre></td></tr></table></figure><h3 id="复制（y）"><a href="#复制（y）" class="headerlink" title="复制（y）"></a>复制（y）</h3><p>可配合光标移动使用（w, n, ^, $）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yy<span class="comment">#当前行复制</span></span><br><span class="line">nyy<span class="comment">#n行复制</span></span><br><span class="line">yw<span class="comment">#复制到到字胃</span></span><br><span class="line">nyw<span class="comment">#复制光标及其后的n个单词</span></span><br><span class="line">y^<span class="comment">#复制光标到行首</span></span><br><span class="line">y$<span class="comment">#复制光标到行尾</span></span><br></pre></td></tr></table></figure><h3 id="粘贴（p）"><a href="#粘贴（p）" class="headerlink" title="粘贴（p）"></a>粘贴（p）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p<span class="comment"># 光标后粘贴</span></span><br><span class="line">P<span class="comment"># 光标前粘贴</span></span><br></pre></td></tr></table></figure><h3 id="撤销（u）"><a href="#撤销（u）" class="headerlink" title="撤销（u）"></a>撤销（u）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u<span class="comment"># 撤销一步</span></span><br><span class="line">U<span class="comment"># 撤销本行操作(其实是增加了全局操作，会被u撤销)</span></span><br></pre></td></tr></table></figure><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> nu<span class="comment"># 显示行号</span></span><br><span class="line">:<span class="built_in">set</span> nonu<span class="comment"># 取消显示行号</span></span><br><span class="line">:nu<span class="comment"># 取得该行行号</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Vim编辑异常退出后，会无法正常进行编辑，这时候就要删除一个同名的.swap文件，即可编辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;总结了Vi的使用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux总结</title>
    <link href="https://uncleaaron.github.io/Blog/Linux/Linux%E6%80%BB%E7%BB%93/"/>
    <id>https://uncleaaron.github.io/Blog/Linux/Linux总结/</id>
    <published>2018-06-06T16:05:10.000Z</published>
    <updated>2018-07-31T07:48:52.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>根据自己的记忆和理解方式，总结了最近学习和接触到的Linux理论和指令。</p><p>涉及Linux目录，文件管理，系统，设备管理，进程管理，网络管理，用户管理等。</p><p>（此外，Vi使用 以及 Shell脚本编写在别篇）</p></blockquote><a id="more"></a><h1 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h1><h2 id="linux内核版本号"><a href="#linux内核版本号" class="headerlink" title="linux内核版本号"></a>linux内核版本号</h2><p>x.y.zz（y次版本号，偶数稳定版，奇数发展版）</p><h2 id="Linux目录"><a href="#Linux目录" class="headerlink" title="Linux目录"></a>Linux目录</h2><table><thead><tr><th>目录</th><th>功能</th><th>助记</th></tr></thead><tbody><tr><td>/bin</td><td>常用系统程序目录</td><td>binary</td></tr><tr><td>/boot</td><td>开技设定目录</td><td>boot</td></tr><tr><td>/dev</td><td>系统设备装置文件目录</td><td>device  /dev/null 垃圾箱</td></tr><tr><td>/etc</td><td>系统配置文件，尤其是passwd，shadow文件</td><td>Edit Text Configuration</td></tr><tr><td>/home</td><td>系统使用者的目录</td><td></td></tr><tr><td>/lib</td><td>Linux执行或编译程序函数库的目录</td><td>Libary</td></tr><tr><td>/mnt</td><td>软驱和光驱接入挂载的地方</td><td></td></tr><tr><td>/proc</td><td>系统核心与程序的一些信息</td><td></td></tr><tr><td>/tmp</td><td>临时文件目录</td><td>Temporary 临时的</td></tr><tr><td>/sbin</td><td>系统管理员常用指令集和程序</td><td></td></tr><tr><td>/usr</td><td>/usr/sbin 系统管理员的管理程序和指令<br>/usr/bin 一般执行文件摆放的地方</td><td></td></tr><tr><td>/var</td><td>摆放系统日志文件</td></tr></tbody></table><h1 id="系统启动或关闭"><a href="#系统启动或关闭" class="headerlink" title="系统启动或关闭"></a>系统启动或关闭</h1><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>暂时更改系统运行级别</p><p><strong>权限：</strong>root</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init [0123456]</span><br></pre></td></tr></table></figure><p><strong>重要参数</strong></p><p>0：关机级别</p><p>1：单用户运行级别</p><p>2：多用户</p><p>3：多用户，字符模式</p><p>4：用户自定义</p><p>5：图形界面</p><p>6：重启</p><hr><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>关闭或重启系统</p><p><strong>权限：</strong>root</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown [选项] [时间] [警告信息]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-r: shutdown之后重启</span><br><span class="line">-h: 关机后不重启</span><br></pre></td></tr></table></figure><p><strong>时间：</strong>now 或者 +时间值</p><hr><h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><p>关闭系统和关闭电源</p><p><strong>权限：</strong>所有用户</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p: 关闭计算机后再关闭电源</span><br></pre></td></tr></table></figure><hr><h1 id="用户和组管理"><a href="#用户和组管理" class="headerlink" title="用户和组管理"></a>用户和组管理</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>超级用户：UID 0    （默认为root）</p><p>系统用户：UID 100以下</p><p>普通用户：UID 500+</p><p>/etc/passwd：账号文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaron:x:1002:1002:aaron:/home/aaron:/bin/bash</span><br><span class="line">用户名:加密密码:用户ID:组ID:用户信息:用户主目录:登陆Shell</span><br><span class="line">（默认创建用户下，GID会和UID相同）</span><br></pre></td></tr></table></figure><p>/etc/shadow：口令文件</p><p>/etc/group：用户组信息文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaron:x:500:a1,a2</span><br><span class="line">组名:密码:GID:用户列表（逗号分隔）</span><br></pre></td></tr></table></figure><hr><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>添加用户</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [选项] [参数] &lt;newUsername&gt;</span><br></pre></td></tr></table></figure><p><strong>选项/参数：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d: 指定主目录(directory)</span><br><span class="line">-u: 指定UID(UID)</span><br><span class="line">-g: 指定用户组(group)</span><br><span class="line">-G: 指定用户组列表(Groups)</span><br><span class="line">-s: 指定Shell(Shell)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># useradd aaron</span></span><br></pre></td></tr></table></figure><p>默认条件下：系统自动分配一个500以上的UID和GID，默认创建一个与UID同名的GID组，默认在home目录下创建同名文件夹为主目录。</p><hr><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>修改密码（root可以修改所有的密码，普通用户只能修改自己的密码）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [选项] &lt;Username&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><p>修改用户属性</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod [选项] [参数] &lt;Username&gt;</span><br></pre></td></tr></table></figure><p><strong>选项/参数：</strong>（同useradd）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d: 指定主目录(directory)</span><br><span class="line">-u: 指定UID(UID)</span><br><span class="line">-g: 指定用户组(group)</span><br><span class="line">-G: 指定用户组列表(Groups)</span><br><span class="line">-s: 指定Shell(Shell)</span><br></pre></td></tr></table></figure><hr><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><p>删除用户</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel [选项] &lt;Username&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-r: 删除用户的同时删除主目录</span><br></pre></td></tr></table></figure><hr><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><hr><h3 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h3><p>添加用户组</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd [选项] &lt;GroupName&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g: 设定组ID</span><br><span class="line">-r: 添加系统组(GID小于500)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 501 worker</span><br></pre></td></tr></table></figure><hr><h3 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h3><p>修改组属性</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod [选项] &lt;GroupName&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g GID：设定组ID</span><br><span class="line">-n &lt;GroupName&gt;: 设定新组名</span><br></pre></td></tr></table></figure><hr><h2 id="账号查看"><a href="#账号查看" class="headerlink" title="账号查看"></a>账号查看</h2><hr><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>显示系统中有哪些用户正在使用</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-u: 显示详细的用户状态</span><br><span class="line">-H: 显示表头</span><br><span class="line">-a: 显示所有用户</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ who -uH</span><br><span class="line">NAME     LINE         TIME             IDLE          PID COMMENT</span><br><span class="line">aaron    pts/0        2018-06-07 11:35   .         21837 (125.88.24.125)</span><br></pre></td></tr></table></figure><hr><h3 id="w"><a href="#w" class="headerlink" title="w"></a>w</h3><p>显示系统中用户使用情况，是who的增强版</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w [选项] [user]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s: 简短模式</span><br><span class="line">user: 指定用户</span><br></pre></td></tr></table></figure><hr><h3 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h3><p>显示当前用户名</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><hr><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>显示用户信息</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g: 只显示GID</span><br><span class="line">-u: 只显示UID</span><br></pre></td></tr></table></figure><hr><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>切换用户身份</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [选项] [username]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-l: 同时切换用户主目录</span><br><span class="line">-: 同时切换环境变量</span><br><span class="line">-m: 保留环境变量</span><br></pre></td></tr></table></figure><hr><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>以root身份执行指令</p><p><strong>权限：</strong>在 /etc/sudoers 中有出现的使用者</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">command</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>/etc/shells: 查看系统支持的shell</p><p>一般shell都在/bin/xxx目录下（xx为shell名，例如/bin/bash ）</p><p>root 提示符# 其他用户提示符$</p><h1 id="输入-输出重定向"><a href="#输入-输出重定向" class="headerlink" title="输入/输出重定向"></a>输入/输出重定向</h1><h2 id="文件描述符（0-1-2）"><a href="#文件描述符（0-1-2）" class="headerlink" title="文件描述符（0, 1, 2）"></a>文件描述符（0, 1, 2）</h2><p><strong>0：标准输入</strong></p><p><strong>1：标准输出</strong></p><p><strong>2：标准错误输出</strong></p><h2 id="重定向控制符"><a href="#重定向控制符" class="headerlink" title="重定向控制符"></a>重定向控制符</h2><p><strong>&lt; 文件</strong> ：输入重定向控制符，输入内容从文件获取</p><p><strong>> 文件</strong>：输出重定向控制符（覆盖）</p><p><strong>>> 文件</strong>：输出重定向控制符（追加）</p><h2 id="重定向高级用法"><a href="#重定向高级用法" class="headerlink" title="重定向高级用法"></a>重定向高级用法</h2><ul><li>文件描述符[0,1,2] 重定向控制符[&gt;,&lt;,&lt;&lt;] 文件</li></ul><p>例：重定向标准输出到文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> xxx 1&gt;文件</span><br></pre></td></tr></table></figure><hr><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><strong>符号：</strong><code>&quot;|&quot;</code></p><p>用于连接进程，通过管道连接的进程可以同时运行，并且随着数据流在她们之间传递可以自动地进行协调。</p><hr><h1 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h1><h2 id="文件权限属性"><a href="#文件权限属性" class="headerlink" title="文件权限属性"></a>文件权限属性</h2><p><img src="/Blog/Linux/Linux总结/文件权限属性.png" alt="文件权限属性"></p><p>文件类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-：普通文件</span><br><span class="line">d：目录</span><br><span class="line">l：链接文件</span><br><span class="line">p：管道文件</span><br></pre></td></tr></table></figure><p>权限码（rwx）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r = 4<span class="comment"># 读</span></span><br><span class="line">w = 2<span class="comment"># 写</span></span><br><span class="line">x = 1<span class="comment"># 执行</span></span><br><span class="line">- = 0<span class="comment"># 无权限</span></span><br></pre></td></tr></table></figure><hr><h2 id="文件-目录-属性操作"><a href="#文件-目录-属性操作" class="headerlink" title="文件/目录/属性操作"></a>文件/目录/属性操作</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>显示指定目录下的目录和文件</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [选项] 目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a：显示隐藏文件（<span class="string">"."</span>开头）</span><br><span class="line">-l：列出文件详细信息</span><br><span class="line">-S：以文件大小排序</span><br><span class="line">-t：以时间排序</span><br><span class="line">-i：显示索引节点</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">-drwxr-xr-x1rootroot969May2917:02dir1</span><br><span class="line">文件权限:链接数:拥有者:所属组:文件大小(B):修改日期:文件名</span><br></pre></td></tr></table></figure><hr><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>切换工作目录</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 目录名</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ : 用户主目录</span><br><span class="line">. : 当前目录</span><br><span class="line">.. : 父目录</span><br><span class="line">- : 返回上一次目录</span><br></pre></td></tr></table></figure><hr><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>查看当前工作目录</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><hr><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建目录</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项] 目录</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-p：确保目录名称存在，不存在则创建一个</span><br><span class="line">-m：在创建目录的同时设置目录的权限</span><br></pre></td></tr></table></figure><hr><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>删除<strong>空目录</strong></p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p：当子目录被删除后也成为空目录时，也一并删除</span><br></pre></td></tr></table></figure><hr><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>用于修改文件的时间属性，包括存取时间和更改时间。<strong>若文件不存在，系统会建立一个新的文件</strong> </p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [选项] 文件1 [文件2...]</span><br></pre></td></tr></table></figure><p>不加选项的话修改时间记录为当前系统时间</p><hr><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p><strong>删除</strong>文件或目录（删除目录要 -r）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] 文件名或目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r：递归删除目录一下文件</span><br><span class="line">-i：交互模式，删除前逐一询问（interactive）</span><br><span class="line">-f：强制模式，即使属性为只读，也直接删除，无需逐一确认（force）</span><br></pre></td></tr></table></figure><hr><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p><strong>复制</strong>文件或目录（目录用 -a）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [选项] 源文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a：复制目录时使用，保留链接、文件属性，且递归复制目录下所有内容，相当于-pdr</span><br><span class="line">-p：复制属性</span><br><span class="line">-d：复制链接的话，只复制链接而非期文件</span><br><span class="line">-r：递归复制目录</span><br><span class="line">-i：覆盖之前询问</span><br><span class="line">-f：覆盖且不询问</span><br></pre></td></tr></table></figure><hr><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p><strong>移动</strong>或<strong>更名</strong>指定的文件或目录</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [选项] 源文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure><p><strong>mv参数设置与运行结果：</strong></p><table><thead><tr><th>命令格式</th><th>运行结果</th></tr></thead><tbody><tr><td>mv  文件名  文件名</td><td>将源文件名改为目标文件名</td></tr><tr><td>mv  文件名  目录名</td><td>移动文件到目录</td></tr><tr><td>mv  目录名  目录名</td><td>目标目录存在，将源目录移动到目标目录<br>目标目录不存在，则改名</td></tr><tr><td>mv  目录名  文件名</td><td>错误</td></tr></tbody></table><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-i：交互模式，覆盖询问</span><br><span class="line">-f：强制模式，覆盖不提示</span><br></pre></td></tr></table></figure><hr><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>从指定目录开始递归查找文件，并可以对其进行操作</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 起始目录 &lt;选项查找条件&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-name &lt;name&gt;：正则匹配字符串（-iname 忽略大小写）</span><br><span class="line">-<span class="built_in">type</span> &lt;d/c/b/p/f/l/s&gt;：文件类型</span><br><span class="line">-ls：详细列出所找到的文件</span><br><span class="line">-<span class="built_in">exec</span>：执行期间不询问；用&#123;&#125;表示找到的文件，对其进行命令操作，命令末尾必须以 <span class="string">"\;"</span> 结束</span><br><span class="line">-ok：同<span class="built_in">exec</span>，但会询问。</span><br><span class="line">-size &lt;n&gt;：文件大小是n，可用b，c（char），k(kB)表示</span><br><span class="line">对查询条件做逻辑运算：</span><br><span class="line">-a：与</span><br><span class="line">-o：或</span><br><span class="line">！：非</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># find ~ -name &quot;test*&quot; -ls -exec rm &#123;&#125; \;</span><br><span class="line">393291    0 -rw-rw-r--   1 aaron    aaron           0 Jun  8 13:40 /home/aaron/test3</span><br><span class="line">393290    0 -rw-rw-r--   1 aaron    aaron           0 Jun  8 13:40 /home/aaron/test2</span><br><span class="line">393236    0 -rw-rw-r--   1 aaron    aaron           0 Jun  8 13:40 /home/aaron/test1</span><br></pre></td></tr></table></figure><hr><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>为源文件创建一个链接，但不复制源文件</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [选项] 源对象 目的对象</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s：进行软链接</span><br><span class="line">不用-s：进行硬链接</span><br></pre></td></tr></table></figure><p><strong>硬链接</strong>：文件的副本（别名），同时两者存在连接关系，<strong>修改其中一个另一个也会一同被修改，删除一个，另一个不受影响</strong>。两者在<strong>硬盘上只有一份数据</strong>，只存在于同一个文件系统中。</p><p><strong>软链接</strong>：<strong>一个快捷方式</strong>，是一个内容指向另一个文件位置的特殊文件。删了源文件就没用了。可以跨越文件系统。</p><p>个人理解：</p><p><img src="/Blog/Linux/Linux总结/硬链接和软链接图示.png" alt="硬链接和软链接图示"></p><hr><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>改变目录或文件的权限</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [选项] &lt;mode&gt; &lt;文件名或目录&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R：递归对目录下的所有子文件与子目录进行相同的权限变更</span><br></pre></td></tr></table></figure><p><strong>权限修改：</strong></p><ol><li>用数字修改</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4:r</span><br><span class="line">2:w</span><br><span class="line">1:x</span><br><span class="line">例如775就是rwxrwxr-x</span><br><span class="line">示例：chmod 775 file.txt</span><br></pre></td></tr></table></figure><ol start="2"><li>用指令修改权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u：所有者user</span><br><span class="line">g：组group</span><br><span class="line">o：其他other</span><br><span class="line">+：增加权限</span><br><span class="line">-：取消权限</span><br><span class="line">示例：chmod g+w,o+w,o-r file.txt</span><br></pre></td></tr></table></figure><hr><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>改变指定目录或文件(用-R)的所属用户、所属组</p><p><strong>权限：</strong>root</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [选项] 用户名[：组名] 文件或目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R：递归对子文件或目录操作</span><br></pre></td></tr></table></figure><hr><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>改变文件/目录的所属组</p><p><strong>权限：</strong>所有使用者</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [选项] 组名 文件或目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R：递归对子文件或目录操作</span><br></pre></td></tr></table></figure><hr><h2 id="文字显示-文件操作"><a href="#文字显示-文件操作" class="headerlink" title="文字显示/文件操作"></a>文字显示/文件操作</h2><hr><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>显示文件内容</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-n：显示行号</span><br></pre></td></tr></table></figure><hr><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>分页显示文件内容</p><p>b上一页，空格下一页，回车下一行，</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [选项参数] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项参数：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&lt;数字&gt;：指定每屏显示的行数</span><br><span class="line">+&lt;数字&gt;：从指定数字的行开始显示</span><br><span class="line">-c：不进行滚屏操作。每次刷新这个屏幕</span><br><span class="line">-s：将多个空行压缩成一行</span><br></pre></td></tr></table></figure><hr><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>分页显示文件内容，与more十分相似，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。more读的时候会全部加载，而less部分加载，所以less有时候会更快。</p><p>PageUp键上翻页，PageDown向下翻。Q键退出。 </p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [选项] 文件</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n：显示行号</span><br><span class="line">-s：多个空行压缩成一行</span><br></pre></td></tr></table></figure><hr><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>显示文件前N行内容或前N个字节，默认为前10行</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [选项] 文件</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-n&lt;数字&gt; ：显示前N行</span><br><span class="line">-c&lt;数字&gt; ：显示前N个字节</span><br><span class="line">-v：同时显示文件名</span><br></pre></td></tr></table></figure><hr><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>显示文件后N行内容或前N个字节，默认为前10行</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [选项] 文件</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-n&lt;数字&gt; ：显示后N行</span><br><span class="line">-c&lt;数字&gt; ：显示后N个字节</span><br><span class="line">-v：同时显示文件名</span><br></pre></td></tr></table></figure><hr><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>从文件中过滤或提取特定内容并显示</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-d&lt;分隔符&gt;：指定分隔符号（可用引号包起来）</span><br><span class="line">-f&lt;list&gt;：指定提取的列（可以是-f1，也可以是 -f2-5，-f2,4 这样的范围）</span><br><span class="line">-c&lt;list&gt;：仅显示行中指定范围的字符</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost text]<span class="comment"># cut -f2,4 -d";" test.txt </span></span><br><span class="line">Name Mark</span><br><span class="line">tom 69</span><br><span class="line">jack 71</span><br><span class="line">alex 68</span><br></pre></td></tr></table></figure><hr><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>（wordcount）统计一个文件多少字/字节/行</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c：只显示字节Bytes数；（char（字节)）</span><br><span class="line">-l：只显示列数；（line）</span><br><span class="line">-w：只显示字数。（word）</span><br><span class="line">无参数默认统计行、字、字节数</span><br></pre></td></tr></table></figure><hr><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>对输出的内容进行排序（不改变文件）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r：反向排序(reverse)</span><br><span class="line">-n：数字排序（number）</span><br><span class="line">-f：不区分大小写</span><br></pre></td></tr></table></figure><hr><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>显示文字</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> [选项] 字符串</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n：最后不换行</span><br><span class="line">-e：输出一个空行</span><br></pre></td></tr></table></figure><hr><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p>日历显示</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal [选项] [[月] 年]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无参数则本月日历</span><br><span class="line">-y：显示今年日历</span><br><span class="line">-m：周一为第一天</span><br></pre></td></tr></table></figure><hr><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>显示系统时间 或 设定系统时间</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date [选项] [+format]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-d &lt;dateStr&gt;：显示 字符串所指的日期与时间。字符串须加双引号；</span><br><span class="line">-s &lt;dateStr&gt;：设置 字符串表示的日期与时间。字符串须加双引号；</span><br></pre></td></tr></table></figure><p><strong>日期格式字符串列表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">%H 小时，24小时制（00~23）</span><br><span class="line">%I 小时，12小时制（01~12）</span><br><span class="line">%k 小时，24小时制（0~23）</span><br><span class="line">%l 小时，12小时制（1~12）</span><br><span class="line">%M 分钟（00~59）</span><br><span class="line">%p 显示出AM或PM</span><br><span class="line">%r 显示时间，12小时制（hh:mm:ss %p）</span><br><span class="line">%s 从1970年1月1日00:00:00到目前经历的秒数</span><br><span class="line">%S 显示秒（00~59）</span><br><span class="line">%T 显示时间，24小时制（hh:mm:ss）</span><br><span class="line">%X 显示时间的格式（%H:%M:%S）</span><br><span class="line">%Z 显示时区，日期域（CST）</span><br><span class="line">%a 星期的简称（Sun~Sat）</span><br><span class="line">%A 星期的全称（Sunday~Saturday）</span><br><span class="line">%b 月的简称（Jan~Dec）</span><br><span class="line">%B 月的全称（January~December）</span><br><span class="line">%c 日期和时间（Tue Nov 20 14:12:58 2012）</span><br><span class="line">%d 一个月的第几天（01~31）</span><br><span class="line">%x,%D 日期（mm/dd/yy）</span><br><span class="line">%j 一年的第几天（001~366）</span><br><span class="line">%m 月份（01~12）</span><br><span class="line">%w 一个星期的第几天（0代表星期天）</span><br><span class="line">%W 一年的第几个星期（00~53，星期一为第一天）</span><br><span class="line">%y 年的最后两个数字（00-99）</span><br><span class="line">%Y 完整年份(0000-9999)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>格式化输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date +<span class="string">"%Y-%m-%d"</span></span><br><span class="line">2009-12-07</span><br></pre></td></tr></table></figure><p>设置时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date -s 20120523               //设置成20120523，这样会把具体时间设置成空00:00:00</span><br><span class="line">date -s 01:01:01               //设置具体时间，不会对日期做更改</span><br><span class="line">date -s <span class="string">"01:01:01 2012-05-23"</span>  //这样可以设置全部时间</span><br></pre></td></tr></table></figure><hr><p>###grep</p><p>行搜索工具</p><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v<span class="comment"># 不包含</span></span><br></pre></td></tr></table></figure><hr><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>对标准输入的字符进行替换、压缩和删除 </p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr [选项] 字符串1 字符串2</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-d<span class="comment"># 删除字符1中出现的输入字符</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tr <span class="string">'a-z'</span> <span class="string">'A-Z'</span> &lt; works.txt</span><br><span class="line">LINUX</span><br><span class="line">UNIX</span><br><span class="line">MAC OS</span><br><span class="line"></span><br><span class="line">$ cat works.txt | tr <span class="string">"abc"</span> <span class="string">"xyz"</span></span><br><span class="line">Linux</span><br><span class="line">Unix</span><br><span class="line">Mxz OS</span><br></pre></td></tr></table></figure><hr><h2 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] 目录或文件</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-zcvf<span class="comment"># 压缩</span></span><br><span class="line">-zxvf<span class="comment"># 解压</span></span><br><span class="line">-z<span class="comment"># 用gzip压缩/解压(.gz)</span></span><br><span class="line">-c<span class="comment"># 打包（create）</span></span><br><span class="line">-x<span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><hr><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>压缩：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip File</span><br></pre></td></tr></table></figure><p><strong>解压：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d file.gz</span><br></pre></td></tr></table></figure><hr><h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><p>解压zip文件</p><p><strong>解压：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -x File.zip</span><br></pre></td></tr></table></figure><hr><h2 id="联机、帮助指令"><a href="#联机、帮助指令" class="headerlink" title="联机、帮助指令"></a>联机、帮助指令</h2><p>获取命令的帮助</p><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man [选项] 命令或配置文件</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ls</span><br></pre></td></tr></table></figure><hr><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info &lt;命令名&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> [命令名]</span><br></pre></td></tr></table></figure><hr><h3 id="–help参数"><a href="#–help参数" class="headerlink" title="–help参数"></a>–help参数</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;命令&gt; --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><hr><h2 id="文本格式转换"><a href="#文本格式转换" class="headerlink" title="文本格式转换"></a>文本格式转换</h2><h3 id="unix2dos-dos2unix"><a href="#unix2dos-dos2unix" class="headerlink" title="unix2dos, dos2unix"></a>unix2dos, dos2unix</h3><table><thead><tr><th>系统</th><th>换行符</th></tr></thead><tbody><tr><td>windows</td><td>^M^J<br>(回车换行)</td></tr><tr><td>Linux</td><td>^J<br>(换行)</td></tr></tbody></table><h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="磁盘设备描述"><a href="#磁盘设备描述" class="headerlink" title="磁盘设备描述"></a>磁盘设备描述</h2><p>前两个字母：设备类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hd<span class="comment"># IDE硬盘</span></span><br><span class="line">sd<span class="comment"># SCSI硬盘(U盘)</span></span><br></pre></td></tr></table></figure><p>第三个字母：设备编号</p><p>数字：分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sda2：第1块SCSI硬盘的第1个分区</span><br><span class="line">sdb1：第2块SCSI硬盘的第1个分区</span><br></pre></td></tr></table></figure><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ol><li><p><strong>FAT</strong></p><p>早期<strong>Windows</strong>的文件系统</p></li><li><p><strong>NTFS</strong></p><p>目前<strong>Windows</strong>普遍的文件系统</p></li><li><p><strong>Ext</strong></p><p><strong>Linux</strong>引入的可扩展文件系统</p></li><li><p><strong>VFS</strong></p><p><strong>Linux的虚拟文件系统</strong>，（接口层），屏蔽不同的文件系统，实现对各种文件系统的支持。</p></li></ol><h2 id="fdisk-l"><a href="#fdisk-l" class="headerlink" title="fdisk -l"></a>fdisk -l</h2><p>查看本机硬盘及分区情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x0008de3e</span><br><span class="line"></span><br><span class="line">Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048    83884031    41940992   83  Linux</span><br></pre></td></tr></table></figure><h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p>挂载设备</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [选项] 设备名 挂载点</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-t &lt;文件系统类型&gt;</span><br><span class="line">-o &lt;选项&gt; 如ro, rw, auto, iocharset等</span><br></pre></td></tr></table></figure><h2 id="挂载过程"><a href="#挂载过程" class="headerlink" title="挂载过程"></a>挂载过程</h2><ol><li><strong>获取设备名</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">查看设备名</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>建立挂载点目录</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/目录名</span><br><span class="line">建立mnt目录下的挂载点</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>mount 命令挂载</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount 设备名 挂载点</span><br></pre></td></tr></table></figure><h2 id="umount-卸载设备命令"><a href="#umount-卸载设备命令" class="headerlink" title="umount 卸载设备命令"></a>umount 卸载设备命令</h2><p>卸载挂载的设备</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount 挂载点/设备名</span><br></pre></td></tr></table></figure><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="mkfs"><a href="#mkfs" class="headerlink" title="mkfs"></a>mkfs</h3><p>格式化硬盘分区（创建文件系统）(mkFileSystem)</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t 文件系统 设备名</span><br></pre></td></tr></table></figure><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>查看磁盘使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [选项]</span><br></pre></td></tr></table></figure><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>统计目录或文件所占磁盘空间大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [选项] 目录名</span><br></pre></td></tr></table></figure><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><p><strong>交互进程：</strong>由Shell启动的进程</p><p><strong>守护进程：</strong>在后台运行的进程</p><p><strong>批处理进程：</strong>管理进程的序列</p><p>进程的属性：PID, PPID(父进程ID), UID, GID, 状态, 优先级, 资源占用</p><p>杀终止父进程会连带终止子进程</p><p>系统的第一个进程init(PID=1)（所有进程的父进程）</p><h2 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h2><h3 id="手工启动线程"><a href="#手工启动线程" class="headerlink" title="手工启动线程"></a>手工启动线程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxx &amp;<span class="comment"># 后台运行程序加"&amp;"</span></span><br></pre></td></tr></table></figure><h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><p>指定时间执行命令序列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at [选项] TIME</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-l<span class="comment"># 列出所有作业（可以使用atq）</span></span><br><span class="line">-d<span class="comment"># 删除作业（可以使用atrm）</span></span><br></pre></td></tr></table></figure><hr><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>显示瞬间进程动态（另外，top指令可以动态监控进程）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e<span class="comment"># 显示所有进程</span></span><br><span class="line">-a<span class="comment"># 显示所有进程，包括其他用户的进程</span></span><br><span class="line">-x<span class="comment"># 显示所有控制终端的进程</span></span><br></pre></td></tr></table></figure><hr><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><p>以树状结构显示系统中的所有进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree [选项] [PID|User]</span><br></pre></td></tr></table></figure><p>可以指定显示指定PID的信息 或 指定User的进程信息</p><hr><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>结束进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-s signal] PID</span><br><span class="line"><span class="built_in">kill</span> -l<span class="comment"># 列出所有可用的信号</span></span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-s signal<span class="comment"># 指定信号。重启(1)，强制杀死(9)，结束(10)</span></span><br></pre></td></tr></table></figure><hr><h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><p>查看后台进程</p><h3 id="ctrl-Z"><a href="#ctrl-Z" class="headerlink" title="ctrl+Z"></a>ctrl+Z</h3><p>挂起当前线程</p><h3 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h3><p>前台执行进程</p><p><code>fg PID</code></p><h3 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h3><p>后台执行进程</p><hr><h2 id="crontab-周期性执行程序"><a href="#crontab-周期性执行程序" class="headerlink" title="crontab 周期性执行程序"></a>crontab 周期性执行程序</h2><p>周期性执行程序</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] &#123;-l | -r | -e&#125;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e<span class="comment"># 编辑时程表</span></span><br><span class="line">-r<span class="comment"># 删除目前时程表</span></span><br><span class="line">-l<span class="comment"># 列出目前时程表</span></span><br></pre></td></tr></table></figure><h3 id="crontab文件编写"><a href="#crontab文件编写" class="headerlink" title="crontab文件编写"></a>crontab文件编写</h3><p><strong>格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1 f2 f3 f4 f5 program</span><br><span class="line">m, h, d-M, M-y, d-W program</span><br><span class="line">分钟 小时 月中的天 月 周中的天 program</span><br></pre></td></tr></table></figure><p><strong>特殊格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="comment"># 每个时间点都要执行</span></span><br><span class="line">a-b<span class="comment"># a-b时间点内都要执行</span></span><br><span class="line">*/n<span class="comment"># 每n个时间点都要执行1次</span></span><br><span class="line">a,b,c<span class="comment"># 第a,b,c,个时间点要执行</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每个月每天的12点都要执行wall hello</span><br><span class="line">0 12 * * * wall hello</span><br><span class="line">在12月内，每天早上6点到12点中的每3个小时，每个20分钟执行一次command</span><br><span class="line">*/20 6-12/3 * 12 * command</span><br></pre></td></tr></table></figure><hr><h1 id="系统监视"><a href="#系统监视" class="headerlink" title="系统监视"></a>系统监视</h1><h2 id="系统监视指令"><a href="#系统监视指令" class="headerlink" title="系统监视指令"></a>系统监视指令</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>动态监视进程和信息指令（进化版的ps）</p><p><strong>操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">space<span class="comment"># 刷新</span></span><br><span class="line">h<span class="comment"># 帮助</span></span><br><span class="line">k<span class="comment"># 杀死某进程</span></span><br><span class="line">u<span class="comment"># 显示指定用户</span></span><br><span class="line">P<span class="comment"># 按CPU使用情况排序</span></span><br><span class="line">q<span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>内存查看命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-b<span class="comment"># B字节单位显示</span></span><br><span class="line">-k<span class="comment"># KB单位</span></span><br><span class="line">-m<span class="comment"># MB单位</span></span><br></pre></td></tr></table></figure><h2 id="日志监视"><a href="#日志监视" class="headerlink" title="日志监视"></a>日志监视</h2><p>日志存放于/var/log目录下</p><h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p><strong>1. BIOS初始化</strong></p><p>加载和引导设备，启动操作系统</p><p><strong>2. 内核初始化</strong></p><ol><li>硬件设备检测</li><li>设备驱动初始化</li><li>只读挂载文件系统</li><li>启动第一个进程init（PID=1，所有进程的父进程，失去父进程的子进程都以init作为父进程）</li></ol><p><strong>3. 确定系统运行级别</strong></p><p>init读取配置文件<strong>/etc/inittab</strong></p><p>修改系统默认运行级别：修改其中数字</p><p><code>id:5:initdefault</code></p><p><strong>4. 运行初始化脚本</strong></p><p><strong>5. 运行用户自定义脚本</strong></p><p>修改/etc/rc.d/rc.local</p><p><strong>6. 激活控制台</strong></p><p><strong>7. 启动界面</strong></p><h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><h2 id="网络设置文件"><a href="#网络设置文件" class="headerlink" title="网络设置文件"></a>网络设置文件</h2><table><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td>/etc/hosts</td><td>域名或主机名与IP的映射文件。本机查询DNS</td></tr><tr><td>/etc/sysconfig/network-scripts/ifcfg-ethN</td><td>ethN网卡的配置信息</td></tr><tr><td>/etc/sysconfig/network</td><td>最基本的网络配置信息，系统启动时读取</td></tr><tr><td>/etc/resolv.conf</td><td>域名服务器配置文件</td></tr><tr><td>/etc/host.conf</td><td>域名解析的配置文件，指定如何解析</td></tr><tr><td>/etc/services</td><td>网络服务和端口的映射文件，设定主机不同端口号的网络服务</td></tr><tr><td>/etc/protocols</td><td>描述网络协议及其对应协议号</td></tr></tbody></table><h2 id="网络管理命令"><a href="#网络管理命令" class="headerlink" title="网络管理命令"></a>网络管理命令</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>查看或配置网卡状态</p><p><strong>查看状态：</strong><code>ifconfig</code></p><p><strong>查看单独显卡状态：</strong><code>ifconfig eth0</code></p><p><strong>停止</strong>显卡：<code>down</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure><p><strong>激活</strong>显卡： <code>up</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 dp</span><br></pre></td></tr></table></figure><p><strong>设置</strong>设备<strong>IP地址和子网掩码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig &lt;设备名&gt; &lt;IP&gt; netmask &lt;掩码&gt;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong><code>ifconfig eth0 192.168.0.17 netmask 255.255.255.0</code></p><p>以上修改都是临时性的（永久的修改需要修改<code>/etc/sysconfig/network-scripts/ifcfg-ethN</code>文件修改）</p><hr><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>测试网络是否联通。</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [选项] 地址</span><br></pre></td></tr></table></figure><hr><h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>显示数据包到主机之间的路径</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute [选项] 地址</span><br></pre></td></tr></table></figure><hr><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p>显示路由表 / 添加删除路由记录</p><p>显示路由表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route</span><br></pre></td></tr></table></figure><p>添加|删除网关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route &lt;add|del&gt; default gw 网关IP</span><br></pre></td></tr></table></figure><p>添加 | 删除路由记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route &lt;add|del-net&gt; 网络号 netmask 掩码 dev 设备名</span><br></pre></td></tr></table></figure><hr><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>显示网络状态（端口开放情况）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i<span class="comment"># 列出每个显卡</span></span><br></pre></td></tr></table></figure><hr><h2 id="网络服务管理"><a href="#网络服务管理" class="headerlink" title="网络服务管理"></a>网络服务管理</h2><h3 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h3><p>检查和设置系统的各种服务</p><p>添加/删除指定的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add|del 服务名</span><br></pre></td></tr></table></figure><p>显示所有或指定的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list [服务名]</span><br></pre></td></tr></table></figure><p>检查指定服务的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig 服务名</span><br></pre></td></tr></table></figure><p>改变服务运行级别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig [--level 运行级别(3/4/5)] 服务名 状态(on/off/reset)</span><br></pre></td></tr></table></figure><hr><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>对系统服务管理（启动、停止、重启、查看状态）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service 服务名 [start|stop|restart|status]</span><br></pre></td></tr></table></figure><hr><p>chkconfig和service的区别：前者重启后仍然生效，后者不然</p><hr><h2 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h2><ol><li><strong>独立守护进程工作模式：</strong>一个守护进程响应一个特定的端口的服务或连接（每个服务都对应一个守护进程，会导致资源浪费。）(也叫stand-alone模式)</li><li><strong>基于xinetd的工作模式：</strong>xinetd进程同时监听多个端口，在接收请求时根据端口号来启动不同的服务进程处理请求。（流量小开销小，流量大时由于频繁启动服务进程导致性能下降）</li></ol><h3 id="Telnet服务"><a href="#Telnet服务" class="headerlink" title="Telnet服务"></a>Telnet服务</h3><p>远程登陆应用。基于xinetd的服务。</p><p><strong>使用：</strong></p><ol><li>安装krb5-telnet</li><li>编辑/etc/xinetd.d/krb5-telnet配置文件（在此之前可能要改xinetd配置文件/etc/xinetd.conf文件），编辑/etc/securetty文件</li><li>重启服务 <code>service xinetd restart</code></li></ol><p>需要用非root普通用户登陆</p><p><strong>停止：</strong></p><p>关闭xinetd服务（telnet受xinetd管理，所以关闭xinetd即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service xinetd stop</span><br></pre></td></tr></table></figure><hr><h3 id="FTP服务"><a href="#FTP服务" class="headerlink" title="FTP服务"></a>FTP服务</h3><p>FTP文件传输协议，支持standalone模式和xinetd模式。</p><p><strong>配置文件：</strong></p><ol><li>/etc/vsftpd/vsftpd.conf：主配置文件</li><li>/etc/vsftpd.ftpusers：禁用用户列表</li><li>/etc/vsftpd.user_list：</li></ol><p><strong>启动vsFTPd</strong></p><p><code>service vsftpd [start | stop | restart]</code></p><p><strong>需要关闭防火墙</strong></p><p><strong>使用操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lcd<span class="comment"># 切换本机目录</span></span><br><span class="line">get &lt;filename&gt;<span class="comment"># 从FTP下载到本地</span></span><br><span class="line">put &lt;filename&gt;<span class="comment"># 从本地上传到FTP</span></span><br><span class="line">close<span class="comment"># 关闭ftp会话</span></span><br><span class="line">open<span class="comment"># 连接ftp站点</span></span><br><span class="line">quit<span class="comment"># 断开连接并退出</span></span><br></pre></td></tr></table></figure><hr><h3 id="SElinux-访问控制"><a href="#SElinux-访问控制" class="headerlink" title="SElinux 访问控制"></a>SElinux 访问控制</h3><p>在SELinux的访问控制限制下，进程只能访问那些在其任务中所需要的文件。</p><h3 id="www"><a href="#www" class="headerlink" title="www"></a>www</h3><p>web服务，用的是httpd服务</p><p>启动httpd</p><p><code>service httpd [start | stop | restart]</code></p><p><strong>httpd的配置文件：</strong></p><p><strong>/etc/httpd/conf/http.conf</strong></p><hr><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;根据自己的记忆和理解方式，总结了最近学习和接触到的Linux理论和指令。&lt;/p&gt;
&lt;p&gt;涉及Linux目录，文件管理，系统，设备管理，进程管理，网络管理，用户管理等。&lt;/p&gt;
&lt;p&gt;（此外，Vi使用 以及 Shell脚本编写在别篇）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/tags/Linux/"/>
    
  </entry>
  
</feed>
