<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StormAaron的技术站</title>
  
  
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="https://uncleaaron.github.io/Blog/"/>
  <updated>2018-08-12T14:56:01.234Z</updated>
  <id>https://uncleaaron.github.io/Blog/</id>
  
  <author>
    <name>Aaron.H</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://uncleaaron.github.io/Blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://uncleaaron.github.io/Blog/计算机网络/</id>
    <published>2018-08-12T10:04:59.000Z</published>
    <updated>2018-08-12T14:56:01.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a><p><img src="/Blog/计算机网络/计算机网络体系结构图.png" alt="计算机网络体系结构图"></p><h3 id="1-五层协议"><a href="#1-五层协议" class="headerlink" title="1. 五层协议"></a>1. 五层协议</h3><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</li><li><strong>运输层</strong> ：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><strong>网络层</strong> ：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。<strong>（IP层）</strong></li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流</li></ul><p>，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p><h3 id="2-OSI"><a href="#2-OSI" class="headerlink" title="2. OSI"></a>2. OSI</h3><p>其中表示层和会话层用途如下：</p><ul><li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必担心在各台主机中数据内部格式不同的问题。</li><li><strong>会话层</strong> ：建立及管理会话。</li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h3 id="3-TCP-IP"><a href="#3-TCP-IP" class="headerlink" title="3. TCP/IP"></a>3. TCP/IP</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p><img src="/Blog/计算机网络/TCP.IP四层体系结构.png" alt="TCP.IP四层体系结构"></p><p>TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。</p><p><img src="/Blog/计算机网络/沙漏计时器形状的TCP.IP协议族.png" alt="沙漏计时器形状的TCP.IP协议族"></p><h3 id="4-数据在各层之间的传递过程"><a href="#4-数据在各层之间的传递过程" class="headerlink" title="4. 数据在各层之间的传递过程"></a>4. 数据在各层之间的传递过程</h3><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</p><p><img src="/Blog/计算机网络/数据在各层之间传递.jpg" alt="数据在各层之间传递"></p><p>DNS是使用UDP查询的</p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h2><h3 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h3><p>需要防止数据碰撞：信道复用或CSMA/CD协议</p><h3 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h3><p>一对一通信，PPP协议控制</p><h2 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h2><p>频分复用</p><p>时分复用</p><p>统计时分复用</p><p>波分复用</p><p>码分复用</p><h2 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议*"></a>CSMA/CD协议*</h2><p>CSMA/CD表示载波监听、多点接入 / 碰撞检测</p><ul><li><p>多点接入：多主机接入总线网络</p></li><li><p>载波监听：每个主机都不停的监听信道。若监听到信道正被使用，则等待</p></li><li><p>碰撞检测：发送过程中检测到其他主机发生数据，则发生碰撞。（传播时延导致的监听延迟）</p></li></ul><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><h2 id="ppp协议"><a href="#ppp协议" class="headerlink" title="ppp协议"></a>ppp协议</h2><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层*"></a>网络层*</h1><p>IP协议</p><p>配套了：</p><ul><li>地址解析协议ARP</li><li>网际控制报文协议ICMP</li><li>网际组管理协议IGMP</li></ul><p><img src="/Blog/计算机网络/网际协议IP及其配套协议.png" alt="网际协议IP及其配套协议"></p><h2 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li></ul><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><p><img src="/Blog/计算机网络/IP分类地址段.png" alt="IP分类地址段"></p><h3 id="2-子网划分"><a href="#2-子网划分" class="headerlink" title="2. 子网划分"></a>2. 子网划分</h3><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><h3 id="3-无分类"><a href="#3-无分类" class="headerlink" title="3. 无分类"></a>3. 无分类</h3><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p><p><strong>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度</strong>的方法，例如 <strong>128.14.35.7/20 表示前 20 位为网络前缀</strong>。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h2 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><p>ARP实现由IP地址得到MAC地址</p><h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。</p><h3 id="1-Ping"><a href="#1-Ping" class="headerlink" title="1. Ping"></a>1. Ping</h3><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><h3 id="2-Traceroute"><a href="#2-Traceroute" class="headerlink" title="2. Traceroute"></a>2. Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指“好像是”，而实际上并不是，它有经过公用的互联网。</p><p><img src="/Blog/计算机网络/VPN.jpg" alt="VPN"></p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><p><img src="/Blog/计算机网络/NAT.png" alt="NAT"></p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层*"></a>运输层*</h1><h2 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h2><ul><li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li><li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li></ul><h2 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h2><ul><li><strong>序号 seq</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>确认号 ack</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认 ACK</strong> ：<strong>当 ACK=1 时确认号字段有效，否则无效</strong>。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong> ：在<strong>连接建立时用来同步序号</strong>。<strong>当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1</strong>。</li><li><strong>终止 FIN</strong> ：用来<strong>释放一个连接，当 FIN=1</strong> 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="/Blog/计算机网络/TCP三次握手.png" alt="TCP三次握手"></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><strong>三次握手的原因</strong></p><p>第三次握手是<strong>为了防止失效的连接请求到达服务器，让服务器错误打开连接。</strong></p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="/Blog/计算机网络/TCP四次挥手.jpg" alt="TCP四次挥手"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://uncleaaron.github.io/Blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP" scheme="https://uncleaaron.github.io/Blog/tags/TCP-IP/"/>
    
      <category term="HTTP" scheme="https://uncleaaron.github.io/Blog/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>SQL</title>
    <link href="https://uncleaaron.github.io/Blog/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/"/>
    <id>https://uncleaaron.github.io/Blog/数据库/SQL/</id>
    <published>2018-08-06T11:21:03.000Z</published>
    <updated>2018-08-07T03:28:39.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a><p>DML数据操纵语言(INSERT, UPDATE, DELETE)</p><p>DDL数据定义语言(CREATE TABLE, VIEW, INDEX, )</p><p>DQL数据查询语言(SELECT)</p><p>DCL数据控制语言（GRANT, ROLLBACK, COMMIT）</p><h1 id="一、创建和使用数据库"><a href="#一、创建和使用数据库" class="headerlink" title="一、创建和使用数据库"></a>一、创建和使用数据库</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">USE</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><h1 id="二、创建表"><a href="#二、创建表" class="headerlink" title="二、创建表"></a>二、创建表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">table</span> (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    col1 <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">"COL1"</span>,</span><br><span class="line">    col2 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="三、修改表"><a href="#三、修改表" class="headerlink" title="三、修改表"></a>三、修改表</h1><p>Alter， Drop</p><h2 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">col</span> <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure><h1 id="四、插入行"><a href="#四、插入行" class="headerlink" title="四、插入行"></a>四、插入行</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table(col1, col2) VALUES (val1, val2);</span><br></pre></td></tr></table></figure><h2 id="插入检索出来的数据"><a href="#插入检索出来的数据" class="headerlink" title="插入检索出来的数据"></a>插入检索出来的数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table(col1, col2)</span><br><span class="line">SELECT col1, col2</span><br><span class="line">FROM table_A;</span><br></pre></td></tr></table></figure><h2 id="将一个表中的内容插入到新表"><a href="#将一个表中的内容插入到新表" class="headerlink" title="将一个表中的内容插入到新表"></a>将一个表中的内容插入到新表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE newtable AS</span><br><span class="line">SELECT * FROM table;</span><br></pre></td></tr></table></figure><h1 id="六、更新"><a href="#六、更新" class="headerlink" title="六、更新"></a>六、更新</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table</span><br><span class="line">SET col1 = val1</span><br><span class="line">WHERE id = 1;</span><br></pre></td></tr></table></figure><h1 id="七、删除"><a href="#七、删除" class="headerlink" title="七、删除"></a>七、删除</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table</span><br><span class="line">where id = 1;</span><br></pre></td></tr></table></figure><h1 id="八、查询"><a href="#八、查询" class="headerlink" title="八、查询"></a>八、查询</h1><h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>重复行只出现一次。作用于所有列，也就是说所有列的值都相同才算重复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT col1, col2</span><br><span class="line">FROM table;</span><br></pre></td></tr></table></figure><h2 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h2><p>分页。限制返回的行数。可以有两个参数，第一个参数为：起始行，从0开始；第二个参数为返回的行数。</p><p>返回前5行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1, col2</span><br><span class="line">FROM table</span><br><span class="line">LIMIT 5;# 返回前5行</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1, col2</span><br><span class="line">FROM table</span><br><span class="line">LIMIT 0, 5;# 返回前5行完整写法</span><br></pre></td></tr></table></figure><p>返回3~5行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1, col2</span><br><span class="line">FROM table</span><br><span class="line">LIMIT 2, 3;# 返回第2+1行开始的3条数据，也就是345行</span><br></pre></td></tr></table></figure><h1 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h1><ul><li><strong>ASC：</strong>升序（默认）</li><li><strong>DESC：</strong>降序</li></ul><p>可以按多个列排序，而且可以给每个列指定不同的排序方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1, col2</span><br><span class="line">FROM table</span><br><span class="line">ORDER BY col DESC, col2 ASC;</span><br></pre></td></tr></table></figure><h1 id="九、用where过滤"><a href="#九、用where过滤" class="headerlink" title="九、用where过滤"></a>九、用where过滤</h1><p>WHERE子句可用的操作符</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;&gt;   !=</td><td>不等于</td></tr><tr><td>&lt;=    !&gt;</td><td>小于等于</td></tr><tr><td>&gt;=    !&lt;</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在两个值之间</td></tr><tr><td>IS NULL</td><td>为 NULL 值</td></tr></tbody></table><ul><li>注意：NULL和0和空字符串””都不一样！区分！</li></ul><p>WHERE子句的连接符</p><table><thead><tr><th>连接符</th><th>说明</th></tr></thead><tbody><tr><td>AND</td><td>与，连接过滤条件。与比或优先</td></tr><tr><td>OR</td><td>或，连接过滤条件</td></tr><tr><td>IN</td><td>匹配值，后面可以接SELECT子句，匹配查询到的一组值</td></tr><tr><td>NOT</td><td>否定一个条件</td></tr><tr><td>col LIKE xx</td><td>检查col匹配通配符xx</td></tr></tbody></table><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ul><li>% 匹配 &gt;=0 的任意字符串</li><li>_ 匹配 1 个字符</li><li style="list-style: none"><input type="checkbox"> 匹配集合内的字符，例如 [ab] 匹配字符 a 或者 b。</li><li>^ 否定，配合 [ ] 使用，表示不匹配集合内的字符，如 [^ab]</li></ul><p>使用 LIKE 来进行通配符匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1, col2</span><br><span class="line">FROM table</span><br><span class="line">WHERE col LIKE &apos;[^AB]%&apos;-- 不以A或B开头的任意文本</span><br></pre></td></tr></table></figure><ul><li>注意：通配符位于开头处匹配会非常慢！不要滥用！</li></ul><h1 id="十、计算字段"><a href="#十、计算字段" class="headerlink" title="十、计算字段"></a>十、计算字段</h1><h1 id="十一、函数"><a href="#十一、函数" class="headerlink" title="十一、函数"></a>十一、函数</h1><h1 id="十二、分组"><a href="#十二、分组" class="headerlink" title="十二、分组"></a>十二、分组</h1><h1 id="十三、子查询"><a href="#十三、子查询" class="headerlink" title="十三、子查询"></a>十三、子查询</h1><h1 id="十四、连接"><a href="#十四、连接" class="headerlink" title="十四、连接"></a>十四、连接</h1><h1 id="十五、组合查询"><a href="#十五、组合查询" class="headerlink" title="十五、组合查询"></a>十五、组合查询</h1><h1 id="十六、视图"><a href="#十六、视图" class="headerlink" title="十六、视图"></a>十六、视图</h1><h1 id="十七、存储过程"><a href="#十七、存储过程" class="headerlink" title="十七、存储过程"></a>十七、存储过程</h1><h1 id="十八、游标"><a href="#十八、游标" class="headerlink" title="十八、游标"></a>十八、游标</h1><h1 id="十九、触发器"><a href="#十九、触发器" class="headerlink" title="十九、触发器"></a>十九、触发器</h1><h1 id="二十、事务管理"><a href="#二十、事务管理" class="headerlink" title="二十、事务管理"></a>二十、事务管理</h1><p>基本术语：</p><ul><li>事务（transaction）指一组 SQL 语句；</li><li>回退（rollback）指撤销指定 SQL 语句的过程；</li><li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ul><p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p><p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION</span><br><span class="line">// ...</span><br><span class="line">SAVEPOINT delete1</span><br><span class="line">// ...</span><br><span class="line">ROLLBACK TO delete1</span><br><span class="line">// ...</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><h1 id="二十一、字符集"><a href="#二十一、字符集" class="headerlink" title="二十一、字符集"></a>二十一、字符集</h1><h1 id="二十二、权限管理"><a href="#二十二、权限管理" class="headerlink" title="二十二、权限管理"></a>二十二、权限管理</h1><ul><li>Mysql的账户信息存在mysql这个数据库中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line">SELECT user from user;# 查询mysql.user表</span><br></pre></td></tr></table></figure><p>##创建账户</p><p>新创建的账户没有任何权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER myuser Identified By &apos;password&apos;;</span><br></pre></td></tr></table></figure><h2 id="删除账户"><a href="#删除账户" class="headerlink" title="删除账户"></a>删除账户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER myuser;</span><br></pre></td></tr></table></figure><h2 id="授予权限Grant"><a href="#授予权限Grant" class="headerlink" title="授予权限Grant"></a>授予权限Grant</h2><p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON mydatabase.* TO myuser</span><br></pre></td></tr></table></figure><h2 id="删除权限Revoke"><a href="#删除权限Revoke" class="headerlink" title="删除权限Revoke"></a>删除权限Revoke</h2><p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE SELECT, INSERT ON mydatabase.* FROM myuser;</span><br></pre></td></tr></table></figure><h2 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR myuser;</span><br></pre></td></tr></table></figure><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>使用 Password() 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR myuser = Password(&apos;new_password&apos;);</span><br></pre></td></tr></table></figure><h2 id="修改账户名"><a href="#修改账户名" class="headerlink" title="修改账户名"></a>修改账户名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME myuser TO newuser;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://uncleaaron.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="https://uncleaaron.github.io/Blog/tags/Mysql/"/>
    
      <category term="SQL" scheme="https://uncleaaron.github.io/Blog/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="https://uncleaaron.github.io/Blog/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    <id>https://uncleaaron.github.io/Blog/数据库/Mysql/</id>
    <published>2018-08-06T11:20:55.000Z</published>
    <updated>2018-08-11T02:13:57.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a><!-- GFM-TOC --><ul><li><a href="#一存储引擎">一、存储引擎</a><ul><li><a href="#innodb">InnoDB</a></li><li><a href="#myisam">MyISAM</a></li><li><a href="#比较">比较</a></li></ul></li><li><a href="#二数据类型">二、数据类型</a><ul><li><a href="#整型">整型</a></li><li><a href="#浮点数">浮点数</a></li><li><a href="#字符串">字符串</a></li><li><a href="#时间和日期">时间和日期</a></li></ul></li><li><a href="#三索引">三、索引</a><ul><li><a href="#b-tree-原理">B+ Tree 原理</a></li><li><a href="#索引分类">索引分类</a></li><li><a href="#索引的优点">索引的优点</a></li><li><a href="#索引优化">索引优化</a></li></ul></li><li><a href="#四查询性能优化">四、查询性能优化</a><ul><li><a href="#使用-explain-进行分析">使用 Explain 进行分析</a></li><li><a href="#优化数据访问">优化数据访问</a></li><li><a href="#重构查询方式">重构查询方式</a></li></ul></li><li><a href="#五切分">五、切分</a><ul><li><a href="#水平切分">水平切分</a></li><li><a href="#垂直切分">垂直切分</a></li><li><a href="#sharding-策略">Sharding 策略</a></li><li><a href="#sharding-存在的问题及解决方案">Sharding 存在的问题及解决方案</a></li></ul></li><li><a href="#六复制">六、复制</a><ul><li><a href="#主从复制">主从复制</a></li><li><a href="#读写分离">读写分离</a></li></ul></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、存储引擎"><a href="#一、存储引擎" class="headerlink" title="一、存储引擎"></a>一、存储引擎</h1><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB 是 MySQL 默认的事务型存储引擎，只有在需要 InnoDB 不支持的特性时，才考虑使用其它存储引擎。</p><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（next-key locking）防止幻影读。</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用 MyISAM。</p><p>MyISAM 提供了大量的特性，包括压缩表、空间数据索引等。</p><p>不支持事务。</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ul><li><p>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</p></li><li><p>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</p></li><li><p>外键：InnoDB 支持外键。</p></li><li><p>备份：InnoDB 支持在线热备份。</p></li><li><p>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</p></li><li><p>其它特性：MyISAM 支持压缩表和空间数据索引。</p></li></ul><h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p><p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p><p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p><p>VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。</p><h2 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h2><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p><h3 id="1-DATETIME"><a href="#1-DATETIME" class="headerlink" title="1. DATETIME"></a>1. DATETIME</h3><p>能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p><p>它与时区无关。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h3 id="2-TIMESTAMP"><a href="#2-TIMESTAMP" class="headerlink" title="2. TIMESTAMP"></a>2. TIMESTAMP</h3><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。</p><p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p><p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p><p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p><h1 id="三、索引"><a href="#三、索引" class="headerlink" title="三、索引"></a>三、索引</h1><p>索引能够轻易将查询性能提升几个数量级。</p><p>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。对于中到大型的表，索引就非常有效。但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</p><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h2 id="B-Tree-原理"><a href="#B-Tree-原理" class="headerlink" title="B+ Tree 原理"></a>B+ Tree 原理</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树时一颗查找树，并且所有叶子节点位于同一层。</p><p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key<sub>i</sub> 和 key<sub>i+1</sub>，且不为 null，则该指针指向节点的所有 key 大于等于 key<sub>i</sub> 且小于等于 key<sub>i+1</sub>。</p><p><div align="center"> <img src="../pics//061c88c1-572f-424f-b580-9cbce903a3fe.png"> </div><br></p><h3 id="2-操作"><a href="#2-操作" class="headerlink" title="2. 操作"></a>2. 操作</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p><p>插入删除操作记录会破坏平衡树的平衡性，因此在插入删除时，需要对树进行一个分裂、合并、旋转等操作。</p><h3 id="3-与红黑树的比较"><a href="#3-与红黑树的比较" class="headerlink" title="3. 与红黑树的比较"></a>3. 与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p><p>（一）更少的检索次数</p><p>平衡树检索数据的时间复杂度等于树高 h，而树高大致为 O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。</p><p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大。红黑树的树高 h 很明显比 B+ Tree 大非常多，因此检索的次数也就更多。</p><p>（二）利用计算机预读特性</p><p>为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。</p><p>操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="1-B-Tree-索引"><a href="#1-B-Tree-索引" class="headerlink" title="1. B+Tree 索引"></a>1. B+Tree 索引</h3><p>B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><p>B+Tree 索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。</p><p>如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p><p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p><div align="center"> <img src="../pics//c28c6fbc-2bc1-47d9-9b2e-cf3d4034f877.jpg"> </div><br></p><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><p><div align="center"> <img src="../pics//7ab8ca28-2a41-4adf-9502-cc0a21e63b51.jpg"> </div><br></p><h3 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2. 哈希索引"></a>2. 哈希索引</h3><p>InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找；</li></ul><h3 id="3-全文索引"><a href="#3-全文索引" class="headerlink" title="3. 全文索引"></a>3. 全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h3 id="4-空间数据索引（R-Tree）"><a href="#4-空间数据索引（R-Tree）" class="headerlink" title="4. 空间数据索引（R-Tree）"></a>4. 空间数据索引（R-Tree）</h3><p>MyISAM 存储引擎支持空间数据索引，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul><li><p>大大减少了服务器需要扫描的数据行数。</p></li><li><p>帮助服务器避免进行排序和创建临时表（B+Tree 索引是有序的，可以用来做 ORDER BY 和 GROUP BY 操作）；</p></li><li><p>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，也就将相邻的数据都存储在一起）。</p></li></ul><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1. 独立的列"></a>1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="2-多列索引"><a href="#2-多列索引" class="headerlink" title="2. 多列索引"></a>2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ <span class="keyword">id</span> <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">AND</span> film_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="3-索引列的顺序"><a href="#3-索引列的顺序" class="headerlink" title="3. 索引列的顺序"></a>3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面，索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure><h3 id="4-前缀索引"><a href="#4-前缀索引" class="headerlink" title="4. 前缀索引"></a>4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>对于前缀长度的选取需要根据索引选择性来确定。</p><h3 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>因为索引条目通常远小于数据行的大小，所以若只读取索引，能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h1 id="四、查询性能优化"><a href="#四、查询性能优化" class="headerlink" title="四、查询性能优化"></a>四、查询性能优化</h1><h2 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a>使用 Explain 进行分析</h2><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>比较重要的字段有：</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><p>更多内容请参考：<a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析</a></p><h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><h3 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1. 减少请求的数据量"></a>1. 减少请求的数据量</h3><p>（一）只返回必要的列</p><p>最好不要使用 SELECT * 语句。</p><p>（二）只返回必要的行</p><p>使用 WHERE 语句进行查询过滤，有时候也需要使用 LIMIT 语句来限制返回的数据。</p><p>（三）缓存重复查询的数据</p><p>使用缓存可以避免在数据库中进行查询，特别要查询的数据经常被重复查询，缓存可以带来的查询性能提升将会是非常明显的。</p><h3 id="2-减少服务器端扫描的行数"><a href="#2-减少服务器端扫描的行数" class="headerlink" title="2. 减少服务器端扫描的行数"></a>2. 减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询。</p><h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><h3 id="1-切分大查询"><a href="#1-切分大查询" class="headerlink" title="1. 切分大查询"></a>1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELEFT FROM messages WHERE <span class="keyword">create</span> &lt; <span class="keyword">DATE_SUB</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rows_affected = 0</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    rows_affected = do_query(</span><br><span class="line">    <span class="string">"DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span>)</span><br><span class="line">&#125; <span class="keyword">while</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="2-分解大连接查询"><a href="#2-分解大连接查询" class="headerlink" title="2. 分解大连接查询"></a>2. 分解大连接查询</h3><p>将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有：</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tab</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id=tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id=post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag=<span class="string">'mysql'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag=<span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id=<span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure><h1 id="五、切分"><a href="#五、切分" class="headerlink" title="五、切分"></a>五、切分</h1><h2 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h2><p><div align="center"> <img src="../pics//63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg"> </div><br></p><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><h2 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h2><p><div align="center"> <img src="../pics//e130e5b8-b19a-4f1e-b860-223040525cf6.jpg"> </div><br></p><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库 payDB、用户数据库 userDB 等。</p><h2 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h2><ul><li>哈希取模：hash(key) % NUM_DB</li><li>范围：可以是 ID 范围也可以是时间范围</li><li>映射表：使用单独的一个数据库来存储映射关系</li></ul><h2 id="Sharding-存在的问题及解决方案"><a href="#Sharding-存在的问题及解决方案" class="headerlink" title="Sharding 存在的问题及解决方案"></a>Sharding 存在的问题及解决方案</h2><h3 id="1-事务问题"><a href="#1-事务问题" class="headerlink" title="1. 事务问题"></a>1. 事务问题</h3><p>使用分布式事务来解决，比如 XA 接口。</p><h3 id="2-JOIN"><a href="#2-JOIN" class="headerlink" title="2. JOIN"></a>2. JOIN</h3><p>可以将原来的 JOIN 查询分解成多个单表查询，然后在用户程序中进行 JOIN。</p><h3 id="3-ID-唯一性"><a href="#3-ID-唯一性" class="headerlink" title="3. ID 唯一性"></a>3. ID 唯一性</h3><ul><li>使用全局唯一 ID：GUID。</li><li>为每个分片指定一个 ID 范围。</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)。</li></ul><p>更多内容请参考：</p><ul><li><a href="https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6" target="_blank" rel="noopener">How Sharding Works</a></li><li><a href="https://tech.meituan.com/dianping_order_db_sharding.html" target="_blank" rel="noopener">大众点评订单系统分库分表实践</a></li></ul><h1 id="六、复制"><a href="#六、复制" class="headerlink" title="六、复制"></a>六、复制</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制文件（binlog）中。</li><li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志文件，并写入从服务器的中继日志中。</li><li><strong>SQL 线程</strong> ：负责读取中继日志并重放其中的 SQL 语句。</li></ul><p><div align="center"> <img src="../pics//master-slave.png"> </div><br></p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作。</p><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><p>MySQL 读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以配置 MyISAM 引擎，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p><div align="center"> <img src="../pics//master-slave-proxy.png"> </div><br></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013.</li><li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011.</li><li><a href="https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html" target="_blank" rel="noopener">20+ 条 MySQL 性能优化的最佳经验</a></li><li><a href="http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/" title="服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策" target="_blank" rel="noopener">服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策</a></li><li><a href="https://stackoverflow.com/questions/788829/how-to-create-unique-row-id-in-sharded-databases" target="_blank" rel="noopener">How to create unique row ID in sharded databases?</a></li><li><a href="http://geekswithblogs.net/shaunxu/archive/2012/01/07/sql-azure-federation-ndash-introduction.aspx" title="Title of this entry." target="_blank" rel="noopener">SQL Azure Federation – Introduction</a></li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://uncleaaron.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="https://uncleaaron.github.io/Blog/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://uncleaaron.github.io/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://uncleaaron.github.io/Blog/数据结构/</id>
    <published>2018-08-06T11:20:55.000Z</published>
    <updated>2018-08-27T13:05:11.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>深度：节点层次</p><p>度：节点的子树数</p><p>叶子：度为0的节点</p><p>分支结点</p><p>子结点</p><p>父结点</p><p>兄弟结点：有同一个父结点的结点</p><p>无序树：左右无序</p><p>有序树：左右有序</p><p>森林：多个不相交的树的集合</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是个有序树，每个结点至多有两棵子树</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li><p>在二叉树上的第 i 层上至多有 $$2^{i-1}$$个结点</p></li><li><p>深度为k的二叉树至多有 $$2^k-1$$个结点</p></li><li><p>对任何一棵二叉树T，如果其叶子数为 $$n_0$$，度为2的结点数为$$n_2$$，则有 $$n_0=n_2+1$$</p><blockquote><p> 证明3：</p><ol><li>二叉树内所有结点数为 $n=n_0+n_1+n_2$</li><li>二叉树内总分支数都由度为1和2的结点射出，总结点数为 $n_1+2n_2$</li><li>总分支树代表子结点数，再加上根节点（唯一的非子结点）得：$$n=n_1+2n_2+1$$</li><li>结合1，3得 $n_0=n_2+1$</li></ol></blockquote></li><li><p>满二叉树：深度为 k 且结点数为$2^k-1$的二叉树（满了）</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><ol><li>具有 n 个结点的完全二叉树的深度为 $[log_2n]+1$</li><li>$i=1$ 的结点为根节点，$i&gt;1$ 的结点的父节点为 $[i/2]$</li><li>如果 $2i&gt;n$ ，则结点 i 是叶子结点，否则其左孩子为 $2i$</li><li>如果 $2i&gt;n$ ，则结点 i 无右孩子，否则其右孩子为 $2i+1$</li></ol></li></ol><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="数组（计算得出结点）"><a href="#数组（计算得出结点）" class="headerlink" title="数组（计算得出结点）"></a>数组（计算得出结点）</h4><p>根据性质计算出结点位置</p><h4 id="链式存储（模拟了逻辑模型）"><a href="#链式存储（模拟了逻辑模型）" class="headerlink" title="链式存储（模拟了逻辑模型）"></a>链式存储（模拟了逻辑模型）</h4><p>每个结点存储一个左孩子，右孩子和数据，还可以存储父节点</p><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><h4 id="孩子兄弟表示法（二叉树表示法）"><a href="#孩子兄弟表示法（二叉树表示法）" class="headerlink" title="孩子兄弟表示法（二叉树表示法）"></a>孩子兄弟表示法（二叉树表示法）</h4><p><img src="/Blog/数据结构/树的存储结构-孩子兄弟表示法.png" alt="树的存储结构-孩子兄弟表示法"></p><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><ol><li>根节点</li><li>左子树</li><li>右子树</li></ol><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ol><li>左子树</li><li>根结点</li><li>右子树</li></ol><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><ol><li>左子树</li><li>右子树</li><li>根节点</li></ol><h4 id="根据先序遍历和中序遍历还原二叉树或后序遍历"><a href="#根据先序遍历和中序遍历还原二叉树或后序遍历" class="headerlink" title="根据先序遍历和中序遍历还原二叉树或后序遍历"></a>根据先序遍历和中序遍历还原二叉树或后序遍历</h4><h5 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h5><p>输入：前序遍历，中序遍历<br>1、寻找树的root，前序遍历的第一节点G就是root。<br>2、观察前序遍历GDAFEMHZ，知道了G是root，剩下的节点必然在root的左或右子树中的节点。<br>3、观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树中的节点，G右侧的HMZ必然是root的右子树中的节点，root不在中序遍历的末尾或开始就说明根节点的两颗子树都不为空。<br>4、观察左子树ADEF，按照前序遍历的顺序来排序为DAFE，因此左子树的根节点为D，并且A是左子树的左子树中的节点，EF是左子树的右子树中的节点。<br>5、同样的道理，观察右子树节点HMZ，前序为MHZ，因此右子树的根节点为M，左子节点H，右子节点Z。</p><p>观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了：</p><p><img src="https://images2015.cnblogs.com/blog/795187/201510/795187-20151023201552927-578458496.png" alt="img"></p><p>从而得到PostOrder:       AEFDHZMG</p><p>改进：<br>更进一步说，其实，如果仅仅要求写后续遍历，甚至不要专门占用空间保存还原后的树。只需要用一个数组保存将要得到的后序，就能实现：</p><h5 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h5><p>输入：一个保存后序的数组，前序遍历，中序遍历<br>1、确定根,放在数组末尾<br>2、确定左子树的索引范围，放在数组中相同索引的位置。<br>3、确定右子树索引范围，放在数组中对应索引的位置，刚好能放下。<br>4、用左子树的前序遍历和中序遍历，把后序遍历保存在对应索引的位置<br>5、用左子树的前序遍历和中序遍历，把后序遍历保存在对应索引的位置</p><h3 id="哈夫曼树（最优二叉树）"><a href="#哈夫曼树（最优二叉树）" class="headerlink" title="哈夫曼树（最优二叉树）"></a>哈夫曼树（最优二叉树）</h3><p>路径长度</p><p>带权路径长度</p><p>哈夫曼树：所有叶子结点的带权路径长度之和最小</p><p>构造哈夫曼树</p><h3 id="数等价"><a href="#数等价" class="headerlink" title="数等价"></a>数等价</h3><h3 id="二叉树与一般树转换"><a href="#二叉树与一般树转换" class="headerlink" title="二叉树与一般树转换"></a>二叉树与一般树转换</h3><h4 id="一般树转二叉树"><a href="#一般树转二叉树" class="headerlink" title="一般树转二叉树"></a>一般树转二叉树</h4><ol><li><p>将每一个结点与他的兄弟结点之间连一条线。</p></li><li><p>对每一个双亲结点，只保留它与第一个子结点的连线，删除与其余结点的连线。</p></li><li><p>整理，左右摆齐。</p></li></ol><p><img src="/Blog/数据结构/二叉树转换为树.jpg" alt="二叉树转换为树"></p><h4 id="二叉树转一般树（反过程）"><a href="#二叉树转一般树（反过程）" class="headerlink" title="二叉树转一般树（反过程）"></a>二叉树转一般树（反过程）</h4><ol><li><p>若一个结点是其父结点的左结点，则将此结点的右结点，右结点的右结点……都与其父结点相连线。</p></li><li><p>删除原二叉树所有父结点与右结点的连线。</p></li><li><p>整理连线，统一高度。</p></li></ol><p><img src="/Blog/数据结构/二叉树转一般树.jpg" alt="二叉树转一般树"></p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>顶点</p><p>有向图</p><ul><li>弧<ul><li>弧头/初始点</li><li>弧尾/终结点</li></ul></li></ul><p>无向图</p><ul><li>边</li></ul><p>$$G=(V,{A})$$</p><p>设n为顶点数目，e为边或弧的数目</p><p>无向图中 $0\leq$ $$e\leq\frac{1}{2}n(n-1)$$</p><p>完全图：$$e=\frac{1}{2}n(n-1)$$的无向图</p><p>有向完全图：$$e=n(n-1)$$的有向图</p><p>稀疏图：边或弧很少的图</p><p>稠密图</p><p>子图：有两个图$$G=(V,{E})$$和$$G’=(V’,{E’})$$，若$$V’\subseteq V$$且$$E’\subseteq E$$，则 G‘ 是 G 的子图</p><p>邻接点：对于无向图$$G=(V,{E})$$，有边$(v,v’)\in E$，则称顶点 v 和 v’ <strong>互为邻接点</strong>；边$(v,v’)$与顶点 v 和 v’ <strong>相关联</strong>。</p><p>度$$TD(v)$$(degree)：顶点关联的边的数目</p><p>入度$$ID(v)$$(indegree)：</p><p>出度$$OD(v)$$(outdegree)：</p><p>图的度数之和等于边的两倍：$$e=\frac{1}{2}\sum^n_{i=1}TD(v_i)$$</p><p>路径：</p><p>回路/环：第一个顶点和最后一个顶点相同的路径</p><p>简单路径：顶点不重复出现的路径</p><p>连通：无向图中，顶点间有路径，则称为连通</p><p>连通图：图中任意点都是连通的，就是连通图</p><p>连通分量：非连通图中的极大连通子图</p><p>强连通图：有向图中所有顶点都存在路径</p><p>强连通分量：有向图中的极大强连通子图</p><p>生成树：一个连通图的极小连通子图。有连通图中的全部顶点，但只有足以构成一棵树的n-1条边。如果在生成树上增加一条边，必定构成一个环。</p><p>生成森林：</p><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h4 id="数组表示法："><a href="#数组表示法：" class="headerlink" title="数组表示法："></a>数组表示法：</h4><p><strong>顶点向量+邻接矩阵</strong></p><ul><li>邻接矩阵：表示序号为0-n的元素之间的邻接关系（两点间是否有弧）</li></ul><p>$$<br>\left[<br>\begin{matrix}<br>0 &amp; 1 &amp; 1 &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>1 &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; 1 &amp; 1 &amp; 0<br>\end{matrix}<br>\right]<br>$$</p><ul><li>网的邻接矩阵（带权）：</li></ul><p>$$<br>\left[<br>\begin{matrix}<br>∞ &amp; 5 &amp; 7 &amp; ∞ \<br>∞ &amp; ∞ &amp; ∞ &amp; 1 \<br>12 &amp; 4 &amp; ∞ &amp; ∞ \<br>∞ &amp; 2 &amp; 1 &amp; ∞<br>\end{matrix}<br>\right]<br>$$</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>图的一种链式存储结构，反映的是节点的出度邻接情况。</p><h4 id="逆邻接表"><a href="#逆邻接表" class="headerlink" title="逆邻接表"></a>逆邻接表</h4><p>反映的是节点的入度邻接情况</p><p><img src="/Blog/数据结构/邻接表和逆邻接表.png" alt="邻接表和逆邻接表"></p><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p>有向图的一种优化存储结构。</p><p>十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以vi为尾的弧，也容易找到以vi为头的弧，因而容易求得顶点的出度和入度。除了结构复杂一点外，其创建图的时间复杂度和邻接表是相同的，因此在某些有向图的应用中，是很有用的工具。</p><p>顶点结点</p><table><thead><tr><th>data</th><th>firstin</th><th>firstout</th></tr></thead><tbody><tr><td>顶点信息</td><td>以该顶点为弧头的第一个弧</td><td>以该顶点为弧尾的第一个弧</td></tr></tbody></table><p>弧结点</p><table><thead><tr><th>tailvex</th><th>headvex</th><th>hlink</th><th>tlink</th><th>info</th></tr></thead><tbody><tr><td>弧尾位置</td><td>弧头位置</td><td>弧头相同的下一个弧</td><td>弧尾相同的下一个弧</td><td>以该顶点为弧尾的第一个弧</td></tr></tbody></table><p><img src="/Blog/数据结构/图的十字链表结构.jpg" alt="图的十字链表结构"></p><h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><p>无向图的一种链式存储结构</p><p>边：<br>| mark     | ivex | ilink                   | jvex | jlink                   | info   |<br>| ——– | —- | ———————– | —- | ———————– | —— |<br>| 搜索标记 | 顶点 | 下一条依附于 i 顶点的边 | 顶点 | 下一条依附与 j 顶点的边 | 边信息 |</p><p>顶点：</p><table><thead><tr><th>data</th><th>firstedge</th></tr></thead><tbody><tr><td></td><td>第一条依附于该顶点的边</td></tr></tbody></table><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>类似树的先序遍历，先序遍历未被搜索的顶点</p><p>如：下面的顺序是$$v_1→v_2→v_4→v_8→v_5→v_3→v_6→v_7$$</p><p><img src="/Blog/数据结构/深度优先搜索.jpg" alt="深度优先搜索"></p><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>类似树的按层次遍历，从v出发依次访问未被访问过的v的邻接点</p><p>如：上面的广度优先搜索顺序是：$$v_1→v_2→v_3→v_4→v_5→v_6→v_7→v_8$$</p><h3 id="图的连通性问题"><a href="#图的连通性问题" class="headerlink" title="图的连通性问题"></a>图的连通性问题</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>最小代价生成树（权值之和最小）</p><p>Prim算法</p><p>适用于求边稠密的网的最小生成树</p><p>Kruskal算法</p><p>适用于求边稀疏的网的最小生成树</p><h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><p>Dijkstra算法</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>二分查找</p><p>O(logn)</p><h2 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h2><h2 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h2><p>二叉排序树</p><p>左子树上的所有结点小于根节点的值，右子树所有节点大于根节点，左右子树也是二叉排序树</p><p>中序遍历有序，适用于二分查找</p><p>平衡二叉树（AVL树）</p><p>左子树和右子树的深度之差绝对值不超过1</p><p>B-树</p><p>B+树</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>处理冲突：</p><p>开放地址法</p><p>再哈希法</p><p>链地址法</p><p>建立公共溢出区</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://uncleaaron.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉树" scheme="https://uncleaaron.github.io/Blog/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统原理</title>
    <link href="https://uncleaaron.github.io/Blog/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <id>https://uncleaaron.github.io/Blog/数据库/数据库系统原理/</id>
    <published>2018-08-06T11:20:43.000Z</published>
    <updated>2018-08-07T03:27:55.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a><!-- GFM-TOC --><ul><li><a href="#一事务">一、事务</a><ul><li><a href="#概念">概念</a></li><li><a href="#acid">ACID</a></li><li><a href="#autocommit">AUTOCOMMIT</a></li></ul></li><li><a href="#二并发一致性问题">二、并发一致性问题</a><ul><li><a href="#丢失修改">丢失修改</a></li><li><a href="#读脏数据">读脏数据</a></li><li><a href="#不可重复读">不可重复读</a></li><li><a href="#幻影读">幻影读</a></li></ul></li><li><a href="#三封锁">三、封锁</a><ul><li><a href="#封锁粒度">封锁粒度</a></li><li><a href="#封锁类型">封锁类型</a></li><li><a href="#封锁协议">封锁协议</a></li><li><a href="#mysql-隐式与显示锁定">MySQL 隐式与显示锁定</a></li></ul></li><li><a href="#四隔离级别">四、隔离级别</a><ul><li><a href="#未提交读read-uncommitted">未提交读（READ UNCOMMITTED）</a></li><li><a href="#提交读read-committed">提交读（READ COMMITTED）</a></li><li><a href="#可重复读repeatable-read">可重复读（REPEATABLE READ）</a></li><li><a href="#可串行化serializable">可串行化（SERIALIZABLE）</a></li></ul></li><li><a href="#五多版本并发控制">五、多版本并发控制</a><ul><li><a href="#版本号">版本号</a></li><li><a href="#undo-日志">Undo 日志</a></li><li><a href="#实现过程">实现过程</a></li><li><a href="#快照读与当前读">快照读与当前读</a></li></ul></li><li><a href="#六next-key-locks">六、Next-Key Locks</a><ul><li><a href="#record-locks">Record Locks</a></li><li><a href="#gap-locks">Gap Locks</a></li><li><a href="#next-key-locks">Next-Key Locks</a></li></ul></li><li><a href="#七关系数据库设计理论">七、关系数据库设计理论</a><ul><li><a href="#函数依赖">函数依赖</a></li><li><a href="#异常">异常</a></li><li><a href="#范式">范式</a></li></ul></li><li><a href="#八er-图">八、ER 图</a><ul><li><a href="#实体的三种联系">实体的三种联系</a></li><li><a href="#表示出现多次的关系">表示出现多次的关系</a></li><li><a href="#联系的多向性">联系的多向性</a></li><li><a href="#表示子类">表示子类</a></li></ul></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、事务（Transaction）"><a href="#一、事务（Transaction）" class="headerlink" title="一、事务（Transaction）"></a>一、事务（Transaction）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/ACID.png" width="400"> </div><br></p><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。</p><p>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。</p><hr><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时要只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库崩溃的情况。</li></ul><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/a58e294a-615d-4ea0-9fbf-064a6daec4b2.png" width="400"> </div><br></p><h2 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h2><p><strong>MySQL 默认采用自动提交模式。</strong>也就是说，如果不显式<u>使用<strong><code>START TRANSACTION</code></strong>语句来开始一个事务</u>，那么每个查询都会被当做一个事务自动提交。</p><h1 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h2 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h2><blockquote><p> 准备读的修改被另一个事务覆盖，导致读取了错误的值</p></blockquote><p>T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/丢失修改.png" width="300"> </div><br></p><h2 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h2><blockquote><p> 读取了未提交的数据</p></blockquote><p>T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/读脏数据.png" width="300"> </div><br></p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><blockquote><p> 在另一事务执行时读同一条记录两次的结果不一样（update或delete）</p></blockquote><p>T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/不可重复读.png" width="300"> </div><br></p><h2 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h2><blockquote><p> 读取范围块期间被另一个事务insert新记录，感觉莫名其妙多出来一行</p></blockquote><p>T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/幻读.png" width="300"> </div><br></p><hr><p><strong>产生并发不一致性问题主要原因是破坏了事务的隔离性</strong>，解决方法是<strong>通过并发控制来保证隔离性</strong>。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。<strong>数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</strong></p><h1 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h1><h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/封锁粒度.jpg" width="300"> </div><br></p><p><strong>MySQL</strong> 中提供了两种封锁粒度：<strong>行级锁</strong>以及<strong>表级锁</strong>。</p><p>应该<strong>尽量只锁定需要修改的那部分</strong>数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的<strong>并发程度就越高</strong>。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。<strong>锁粒度越小，系统开销就越大</strong>。</p><p>在选择封锁粒度时，需要在<strong>锁开销和并发程度之间做一个权衡</strong>。</p><h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><h3 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1. 读写锁"></a>1. 读写锁</h3><ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定：</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ul><p>锁的兼容关系如下：</p><table><thead><tr><th style="text-align:center">-</th><th style="text-align:center">X</th><th style="text-align:center">S</th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td></tr></tbody></table><h3 id="2-意向锁（表级锁IS-IX）"><a href="#2-意向锁（表级锁IS-IX）" class="headerlink" title="2. 意向锁（表级锁IS,IX）"></a>2. 意向锁（表级锁IS,IX）</h3><p>使用<strong>意向锁（Intention Locks）可以更容易地支持多粒度封锁</strong>。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，<strong>IX/IS 都是表锁</strong>，用来<strong>表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁</strong>。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p>各种锁的兼容关系如下：</p><table><thead><tr><th style="text-align:center">-</th><th style="text-align:center">X</th><th style="text-align:center">IX</th><th style="text-align:center">S</th><th style="text-align:center">IS</th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">IX</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">IS</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td></tr></tbody></table><p>解释如下：</p><ul><li>任意 <strong>IS/IX 锁之间都是兼容的</strong>，因为它们<strong>只是表示想要对表加锁，而不是真正加锁</strong>；</li><li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li></ul><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="1-三级锁协议"><a href="#1-三级锁协议" class="headerlink" title="1. 三级锁协议"></a>1. 三级锁协议</h3><p><strong>一级封锁协议</strong> </p><p>事务 T 要修改数据 A 时必须加 X 锁，<strong>直到 T 结束才释放锁</strong>。</p><p>可以<strong>解决丢失修改</strong>问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><p><strong>二级封锁协议</strong> </p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，<strong>读取完马上释放 S 锁</strong>。</p><p>可以<strong>解决读脏数据</strong>问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p><strong>三级封锁协议</strong> </p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到<strong>事务结束了才能释放 S 锁</strong>。</p><p>可以<strong>解决不可重复读</strong>的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><h3 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h3><p><strong>加锁和解锁分为两个阶段进行</strong>。<strong>一个事务中一旦开始释放锁，就不能再申请新锁了。</strong></p><p><strong>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</strong></p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure><p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure><h2 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h2><p><strong>MySQL 的 InnoDB 存储引擎采用两段锁协议</strong>，<strong>会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定</strong>。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h1 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h1><h2 id="未提交读（READ-UNCOMMITTED）（脏读）"><a href="#未提交读（READ-UNCOMMITTED）（脏读）" class="headerlink" title="未提交读（READ UNCOMMITTED）（脏读）"></a>未提交读（READ UNCOMMITTED）（脏读）</h2><p>事务中的修改，即使没有提交，对其它事务也是可见的。（总是读取最新的数据行）</p><h2 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h2><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。（事务提交之后才能读）</p><h2 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h2><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><h2 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h2><p>强制事务串行执行。</p><hr><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻影读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">提交读</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">可串行化</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr></tbody></table><h1 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h1><p><strong>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式</strong>，用于<strong>实现提交读和可重复读这两种隔离级别</strong>。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC；可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ul><li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号：事务开始时的系统版本号。</li></ul><p>InooDB 的 MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p><ul><li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul><h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>InnoDB 的 MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/Undo.jpg" width=""> </div><br></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>以下实现过程针对可重复读隔离级别。</p><h3 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1. SELECT"></a>1. SELECT</h3><p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p><p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。</p><p>除了上面的要求，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p><h3 id="2-INSERT"><a href="#2-INSERT" class="headerlink" title="2. INSERT"></a>2. INSERT</h3><p>将当前系统版本号作为数据行快照的创建版本号。</p><h3 id="3-DELETE"><a href="#3-DELETE" class="headerlink" title="3. DELETE"></a>3. DELETE</h3><p>将当前系统版本号作为数据行快照的删除版本号。</p><h3 id="4-UPDATE"><a href="#4-UPDATE" class="headerlink" title="4. UPDATE"></a>4. UPDATE</h3><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><h3 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h3><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure><h3 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h3><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span>;</span><br><span class="line"><span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h1 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h1><p>Next-Key Locks 也是 MySQL 的 InnoDB 存储引擎的一种锁实现。MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。<strong>在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</strong></p><h2 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h2><p>锁定整个记录（行）。锁定的对象是记录的索引，而不是记录本身。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚集索引，因此 Record Locks 依然可以使用。</p><h2 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h2><p>锁定一个范围内的索引，例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录，也锁定范围内的索引。在 user 中有以下记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|   id | last_name   | first_name   |   age |</span><br><span class="line">|<span class="comment">------|-------------|--------------|-------|</span></span><br><span class="line">|    4 | stark       | tony         |    21 |</span><br><span class="line">|    1 | tom         | hiddleston   |    30 |</span><br><span class="line">|    3 | morgan      | freeman      |    40 |</span><br><span class="line">|    5 | jeff        | dean         |    50 |</span><br><span class="line">|    2 | donald      | trump        |    80 |</span><br><span class="line">+<span class="comment">------|-------------|--------------|-------+</span></span><br></pre></td></tr></table></figure><p>那么就需要锁定以下范围：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 21]</span><br><span class="line">(21, 30]</span><br><span class="line">(30, 40]</span><br><span class="line">(40, 50]</span><br><span class="line">(50, 80]</span><br><span class="line">(80, ∞)</span><br></pre></td></tr></table></figure><h1 id="七、关系数据库设计理论"><a href="#七、关系数据库设计理论" class="headerlink" title="七、关系数据库设计理论"></a>七、关系数据库设计理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖；</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 学生-2 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如如果删除了 课程-1，需要删除第一行和第三行，那么 学生-1 的信息就会丢失。</li><li>插入异常，例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/范式.png" width="300"> </div><br></p><h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>属性不可分；</p><h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><p><font size="4"> <strong>分解前</strong> </font><br></p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">95</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><font size="4"> <strong>分解后</strong> </font><br></p><p>关系-1</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">课程-2</td><td style="text-align:center">95</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt;  Grade</li></ul><h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p><p>上面的 关系-1 中存在以下传递函数依赖：Sno -&gt; Sdept -&gt; Mname，可以进行以下分解：</p><p>关系-11</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td></tr></tbody></table><p>关系-12</p><table><thead><tr><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th></tr></thead><tbody><tr><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td></tr><tr><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr></tbody></table><h1 id="八、ER-图"><a href="#八、ER-图" class="headerlink" title="八、ER 图"></a>八、ER 图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h2 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h2><p>包含一对一，一对多，多对多三种。</p><p>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；如果是一对一，画两个带箭头的线段；如果是多对多，画两个不带箭头的线段。下图的 Course 和 Student 是一对多的关系。</p><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/实体的三种联系.jpg" width=""> </div><br></p><h2 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h2><p>一个实体在联系出现几次，就要用几条线连接。下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/多次出现的关系.jpg" width=""> </div><br></p><h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/联系的多向性.png" width=""> </div><br></p><p>一般只使用二元联系，可以把多元关系转换为二元关系。</p><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/联系的多向性-二元关系.png" width=""> </div><br></p><h2 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h2><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><p><div align="center"> <img src="/Blog/数据库/数据库系统原理/子类.jpg" width=""> </div><br></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006.</li><li>施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013.</li><li>史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006.</li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">The InnoDB Storage Engine</a></li><li><a href="https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels" target="_blank" rel="noopener">Transaction isolation levels</a></li><li><a href="http://scanftree.com/dbms/2-phase-locking-protocol" target="_blank" rel="noopener">Concurrency Control</a></li><li><a href="https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666" target="_blank" rel="noopener">The Nightmare of Locking, Blocking and Isolation Levels!</a></li><li><a href="https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html" target="_blank" rel="noopener">Database Normalization and Normal Forms with an Example</a></li><li><a href="https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/" target="_blank" rel="noopener">The basics of the InnoDB undo logging and history system</a></li><li><a href="https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/" target="_blank" rel="noopener">MySQL locking for the busy web developer</a></li><li><a href="https://draveness.me/mysql-innodb" target="_blank" rel="noopener">浅入浅出 MySQL 和 InnoDB</a></li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="noopener">Innodb 中的事务隔离级别和锁的关系</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://uncleaaron.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="https://uncleaaron.github.io/Blog/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java-IO</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java-IO/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java-IO/</id>
    <published>2018-08-06T03:29:19.000Z</published>
    <updated>2018-08-07T10:31:04.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Java 的 I/O 大概可以分成以下几类：</p><ul><li>磁盘操作：File</li><li>字节操作：InputStream 和 OutputStream</li><li>字符操作：Reader 和 Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>新的输入/输出：NIO</li></ul><p>参考了CYC2018的博文：<a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Java%20基础.md" target="_blank" rel="noopener">github-CYC2018</a>🖊 </p></blockquote><a id="more"></a><!-- GFM-TOC --><ul><li><a href="#一概览">一、概览</a></li><li><a href="#二磁盘操作">二、磁盘操作</a></li><li><a href="#三字节操作">三、字节操作</a></li><li><a href="#四字符操作">四、字符操作</a></li><li><a href="#五对象操作">五、对象操作</a></li><li><a href="#六网络操作">六、网络操作</a><ul><li><a href="#inetaddress">InetAddress</a></li><li><a href="#url">URL</a></li><li><a href="#sockets">Sockets</a></li><li><a href="#datagram">Datagram</a></li></ul></li><li><a href="#七nio">七、NIO</a><ul><li><a href="#流与块">流与块</a></li><li><a href="#通道与缓冲区">通道与缓冲区</a></li><li><a href="#缓冲区状态变量">缓冲区状态变量</a></li><li><a href="#文件-nio-实例">文件 NIO 实例</a></li><li><a href="#选择器">选择器</a></li><li><a href="#套接字-nio-实例">套接字 NIO 实例</a></li><li><a href="#内存映射文件">内存映射文件</a></li><li><a href="#对比">对比</a></li></ul></li><li><a href="#八参考资料">八、参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>Java 的 I/O 大概可以分成以下几类：</p><ul><li>磁盘操作：File</li><li>字节操作：InputStream 和 OutputStream</li><li>字符操作：Reader 和 Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>新的输入/输出：NIO</li></ul><h1 id="二、磁盘操作"><a href="#二、磁盘操作" class="headerlink" title="二、磁盘操作"></a>二、磁盘操作</h1><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p><p>递归地输出一个目录下所有文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAllFiles</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="keyword">null</span> || !dir.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dir.isFile()) &#123;<span class="comment">// 是文件，输出文件名</span></span><br><span class="line">        System.out.println(dir.getName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles()) &#123;<span class="comment">// 递归遍历文件</span></span><br><span class="line">        listAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、字节操作"><a href="#三、字节操作" class="headerlink" title="三、字节操作"></a>三、字节操作</h1><p>使用字节流操作进行文件复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(dist);</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read() 最多读取 buffer.length 个字节</span></span><br><span class="line">    <span class="comment">// 返回的是实际读取的个数</span></span><br><span class="line">    <span class="comment">// 返回 -1 的时候表示读到 eof，即文件尾</span></span><br><span class="line">    <span class="keyword">while</span> (in.read(buffer, <span class="number">0</span>, buffer.length) != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><div align="center"> <img src="/Blog/Java/Java-IO/DP-Decorator-java.io.png" width="500"> </div><br></p><p>Java I/O 使用了<strong>装饰者模式来实现。以 InputStream</strong> 为例，</p><ul><li>InputStream 是抽象组件；</li><li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li><li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能，例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li></ul><p><strong>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br></pre></td></tr></table></figure><p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p><h1 id="四、字符操作"><a href="#四、字符操作" class="headerlink" title="四、字符操作"></a>四、字符操作</h1><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p><ul><li>InputStreamReader 实现从字节流解码成字符流；</li><li>OutputStreamWriter 实现字符流编码成为字节流。</li></ul><p>逐行输出文本文件的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFileContent</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileReader fileReader = <span class="keyword">new</span> FileReader(filePath);</span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span></span><br><span class="line">    <span class="comment">// 在调用 BufferedReader 的 close() 方法时会去调用 fileReader 的 close() 方法</span></span><br><span class="line">    <span class="comment">// 因此只要一个 close() 调用即可</span></span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p><p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p><ul><li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li><li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li><li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li></ul><p>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p><p><strong>Java 使用双字节编码 UTF-16be</strong>，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。<strong>char 类型占 16 位</strong>，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p><p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"中文"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(bytes, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure><p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。<strong>getBytes() 的默认编码方式与平台有关，一般为 UTF-8。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes();</span><br></pre></td></tr></table></figure><h1 id="五、对象操作"><a href="#五、对象操作" class="headerlink" title="五、对象操作"></a>五、对象操作</h1><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p><ul><li>序列化：ObjectOutputStream.writeObject()</li><li>反序列化：ObjectInputStream.readObject()</li></ul><p>序列化的类需要<strong>实现 Serializable 接口</strong>，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    A a1 = <span class="keyword">new</span> A(<span class="number">123</span>, <span class="string">"abc"</span>);</span><br><span class="line">    String objectFile = <span class="string">"file/a1"</span>;</span><br><span class="line">    </span><br><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(objectFile));<span class="comment">// 序列化字节流初始化（用装饰者模式包装File输出字节流）</span></span><br><span class="line">    objectOutputStream.writeObject(a1);<span class="comment">// 序列化输出a1对象到文件</span></span><br><span class="line">    objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(objectFile));</span><br><span class="line">    A a2 = (A) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    </span><br><span class="line">    System.out.println(a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line"></span><br><span class="line">    A(<span class="keyword">int</span> x, String y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x = "</span> + x + <span class="string">"  "</span> + <span class="string">"y = "</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p><p><strong>transient</strong> <strong>关键字可以使一些属性不会被序列化</strong>。</p><p><strong>ArrayList 中存储数据的数组是用 transient 修饰的</strong>，因为这个数组是<strong>动态扩展</strong>的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure><h1 id="六、网络操作"><a href="#六、网络操作" class="headerlink" title="六、网络操作"></a>六、网络操作</h1><p>Java 中的网络支持：</p><ul><li><strong>InetAddress</strong>：用于表示网络上的硬件资源，即 <strong>IP 地址</strong>；</li><li><strong>URL</strong>：统一资源定位符；</li><li><strong>Sockets</strong>：使用 <strong>TCP</strong> 协议实现网络通信；</li><li><strong>Datagram</strong>：使用 <strong>UDP</strong> 协议实现网络通信。</li></ul><h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>没有公有的构造函数，只能通过静态方法来创建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress.getByName(String host);</span><br><span class="line">InetAddress.getByAddress(<span class="keyword">byte</span>[] address);</span><br></pre></td></tr></table></figure><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>可以直接从 URL 中读取字节流数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字节流 */</span></span><br><span class="line">    InputStream is = url.openStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字符流 */</span></span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(is, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提供缓存功能 */</span></span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h2><ul><li>ServerSocket：服务器端类</li><li>Socket：客户端类</li><li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li></ul><p><div align="center"> <img src="/Java-IO//ClienteServidorSockets1521731145260.jpg"> </div><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 监听指定的端口</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">55533</span>;</span><br><span class="line">    ServerSocket server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// server将一直等待连接的到来</span></span><br><span class="line">    System.out.println(<span class="string">"server将一直等待连接的到来"</span>);</span><br><span class="line">    Socket socket = server.accept();<span class="comment">// 等待一个连接</span></span><br><span class="line">    <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">    InputStream inputStream = socket.getInputStream();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">      sb.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len,<span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"get message from client: "</span> + sb);</span><br><span class="line">    inputStream.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    server.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端监听一个端口，等待连接的到来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> yiwangzhibujian.onlysend;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 要连接的服务端IP地址和端口</span></span><br><span class="line">    String host = <span class="string">"127.0.0.1"</span>; </span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">55533</span>;</span><br><span class="line">    <span class="comment">// 与服务端建立连接</span></span><br><span class="line">    Socket socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">    <span class="comment">// 建立连接后获得输出流</span></span><br><span class="line">    OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">    String message=<span class="string">"你好  yiwangzhibujian"</span>;</span><br><span class="line">    socket.getOutputStream().write(message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">    write.flush();</span><br><span class="line">    outputStream.close();</span><br><span class="line">    socket.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于客户端往Socket的输出流里面写数据传递给服务端要注意一点，如果写操作之后程序不是对应着输出流的关闭，而是进行其他阻塞式的操作（比如从输入流里面读数据），记住要flush一下，只有这样服务端才能收到客户端发送的数据，否则可能会引起两边无限的互相等待。 </p><h2 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h2><ul><li>DatagramPacket：数据包类</li><li>DatagramSocket：通信类</li></ul><h1 id="七、NIO"><a href="#七、NIO" class="headerlink" title="七、NIO"></a>七、NIO</h1><ul><li><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">Java NIO Tutorial</a></li><li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO 浅析</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">IBM: NIO 入门</a></li></ul><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p><p><img src="/Blog/Java/Java-IO/NIO.jpg" alt="NIO"></p><h2 id="流与块"><a href="#流与块" class="headerlink" title="流与块"></a>流与块</h2><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p><p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p><p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p><p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p><h2 id="通道与缓冲区"><a href="#通道与缓冲区" class="headerlink" title="通道与缓冲区"></a>通道与缓冲区</h2><h3 id="1-通道（Channel）"><a href="#1-通道（Channel）" class="headerlink" title="1. 通道（Channel）"></a>1. 通道（Channel）</h3><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p><p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p><p>通道包括以下类型：</p><ul><li>FileChannel：从文件中读写数据；</li><li>DatagramChannel：通过 UDP 读写网络中数据；</li><li>SocketChannel：通过 TCP 读写网络中数据；</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><h4>多路复用：Channel信道</h4><p>多路复用连接中的一条独立的双向数据流通道。信道是建立在真是的TCP连接内的虚拟连接，数据发送接收都用信道。对于操作系统来说，建立和销毁TCP连接都是非常昂贵的开销，所以引入了信道，用来复用一条TCP连接。</p><h3 id="2-缓冲区"><a href="#2-缓冲区" class="headerlink" title="2. 缓冲区"></a>2. 缓冲区</h3><p><strong>发送给一个通道的所有数据都必须首先放到缓冲区中</strong>，同样地，<strong>从通道中读取的任何数据都要先读到缓冲区中</strong>。也就是说，<strong>不会直接对通道进行读写数据，而是要先经过缓冲区。</strong></p><p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><p>缓冲区包括以下类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><h2 id="缓冲区状态变量"><a href="#缓冲区状态变量" class="headerlink" title="缓冲区状态变量"></a>缓冲区状态变量</h2><ul><li>capacity：最大容量；</li><li>position：当前已经读写的字节数；</li><li>limit：还可以读写的字节数。</li></ul><p>状态变量的改变过程举例：</p><p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p><p><div align="center"> <img src="/Blog/Java/Java-IO/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png"> </div><br></p><p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。</p><p><div align="center"> <img src="/Blog/Java/Java-IO/80804f52-8815-4096-b506-48eef3eed5c6.png"> </div><br></p><p>③ 在<strong>将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法</strong>，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p><p><div align="center"> <img src="/Blog/Java/Java-IO/952e06bd-5a65-4cab-82e4-dd1536462f38.png"> </div><br></p><p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p><p><div align="center"> <img src="/Blog/Java/Java-IO/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png"> </div><br></p><p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p><p><div align="center"> <img src="/Blog/Java/Java-IO/67bf5487-c45d-49b6-b9c0-a058d8c68902.png"> </div><br></p><h2 id="文件-NIO-实例"><a href="#文件-NIO-实例" class="headerlink" title="文件 NIO 实例"></a>文件 NIO 实例</h2><p>以下展示了使用 NIO 快速复制文件的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fastCopy</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得源文件的输入字节流 */</span></span><br><span class="line">    FileInputStream fin = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输入字节流的文件通道 */</span></span><br><span class="line">    FileChannel fcin = fin.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取目标文件的输出字节流 */</span></span><br><span class="line">    FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(dist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输出字节流的通道 */</span></span><br><span class="line">    FileChannel fcout = fout.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为缓冲区分配 1024 个字节 */</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从输入通道中读取数据到缓冲区中 */</span></span><br><span class="line">        <span class="keyword">int</span> r = fcin.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read() 返回 -1 表示 EOF */</span></span><br><span class="line">        <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 切换读写 */</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 把缓冲区的内容写入输出文件中 */</span></span><br><span class="line">        fcout.write(buffer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择器（Selector）"><a href="#选择器（Selector）" class="headerlink" title="选择器（Selector）"></a>选择器（Selector）</h2><p>NIO 常常被叫做<strong>非阻塞 IO</strong>，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p><p>NIO 实现了 IO 多路复用中的 Reactor 模型，<strong>一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件</strong>。</p><p>通过<strong>配置监听的通道 Channel 为非阻塞</strong>，那么<strong>当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel</strong>，找到 IO 事件已经到达的 Channel 执行。<strong>类似一个观察者</strong></p><p>因为创建和切换线程的开销很大，因此<strong>使用一个线程来处理多个事件</strong>而不是一个线程处理一个事件<strong>具有更好的性能。</strong></p><p>应该注意的是，<strong>只有套接字 Channel 才能配置为非阻塞</strong>，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p><p><div align="center"> <img src="/Blog/Java/Java-IO/4d930e22-f493-49ae-8dff-ea21cd6895dc.png"> </div><br></p><h3 id="1-创建选择器"><a href="#1-创建选择器" class="headerlink" title="1. 创建选择器"></a>1. 创建选择器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h3 id="2-将通道注册到选择器上"><a href="#2-将通道注册到选择器上" class="headerlink" title="2. 将通道注册到选择器上"></a>2. 将通道注册到选择器上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();<span class="comment">// 开启ServerSocket通道</span></span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">// 通道配置为非阻塞模式</span></span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);<span class="comment">// 通道注册到选择器上</span></span><br></pre></td></tr></table></figure><p><strong>通道必须配置为非阻塞模式</strong>，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p><p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>它们在 SelectionKey 的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h3 id="3-监听事件"><a href="#3-监听事件" class="headerlink" title="3. 监听事件"></a>3. 监听事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br></pre></td></tr></table></figure><p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p><h3 id="4-获取到达的事件"><a href="#4-获取到达的事件" class="headerlink" title="4. 获取到达的事件"></a>4. 获取到达的事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-事件循环"><a href="#5-事件循环" class="headerlink" title="5. 事件循环"></a>5. 事件循环</h3><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="套接字-NIO-实例"><a href="#套接字-NIO-实例" class="headerlink" title="套接字 NIO 实例"></a>套接字 NIO 实例</h2><p><img src="/Blog/Java/Java-IO/NIO.jpg" alt="NIO"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();<span class="comment">// 选择器开启</span></span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();<span class="comment">// ServerSocket通道开启</span></span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">// 设置为非阻塞</span></span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT); <span class="comment">// 在selector上注册为监听新连接事件</span></span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = ssChannel.socket();<span class="comment">// 获得ServerSocket实例</span></span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);<span class="comment">// 捆绑地址和端口</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">// 主线程死循环执行选择器监听</span></span><br><span class="line"></span><br><span class="line">            selector.select();<span class="comment">// 阻塞地监听，知道有事件到达</span></span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<span class="comment">// 已选择键集</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;<span class="comment">// 若是新连接事件</span></span><br><span class="line"></span><br><span class="line">                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();<span class="comment">// 取得被选中的ServerSocket通道</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    SocketChannel sChannel = ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">// Socket通道设置为非阻塞</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这个新连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);<span class="comment">// 通道注册到选择器为读事件</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;<span class="comment">// 若是读事件</span></span><br><span class="line"></span><br><span class="line">                    SocketChannel sChannel = (SocketChannel) key.channel();<span class="comment">// 获取触发读事件的Socket通道</span></span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));<span class="comment">// 调用了下面的方法读取内容</span></span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                keyIterator.remove();<span class="comment">// 本次事件处理完毕，移除key</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);<span class="comment">// 声明字节缓存</span></span><br><span class="line">        StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            buffer.clear();<span class="comment">// 读到缓存之前清理缓存</span></span><br><span class="line">            <span class="keyword">int</span> n = sChannel.read(buffer);<span class="comment">// 读取到缓存</span></span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();<span class="comment">// 从写模式切换到读模式</span></span><br><span class="line">            <span class="keyword">int</span> limit = buffer.limit();</span><br><span class="line">            <span class="keyword">char</span>[] dst = <span class="keyword">new</span> <span class="keyword">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">                dst[i] = (<span class="keyword">char</span>) buffer.get(i);<span class="comment">// 从缓存逐字节读取缓存</span></span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        String s = <span class="string">"hello world"</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p><p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p><p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>NIO 与普通 I/O 的区别主要有以下两点：</p><ul><li>NIO 是<strong>非阻塞的</strong></li><li>NIO <strong>面向块</strong>，I/O 面向流</li></ul><h1 id="八、参考资料"><a href="#八、参考资料" class="headerlink" title="八、参考资料"></a>八、参考资料</h1><ul><li>Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002.</li><li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">IBM: NIO 入门</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" target="_blank" rel="noopener">IBM: 深入分析 Java I/O 的工作机制</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.htm" target="_blank" rel="noopener">IBM: 深入分析 Java 中的中文编码问题</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" target="_blank" rel="noopener">IBM: Java 序列化的高级认识</a></li><li><a href="http://blog.csdn.net/shimiso/article/details/24990499" target="_blank" rel="noopener">NIO 与传统 IO 的区别</a></li><li><a href="http://stg-tud.github.io/sedc/Lecture/ws13-14/5.3-Decorator.html#mode=document" target="_blank" rel="noopener">Decorator Design Pattern</a></li><li><a href="http://labojava.blogspot.com/2012/12/socket-multicast.html" target="_blank" rel="noopener">Socket Multicast</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java 的 I/O 大概可以分成以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘操作：File&lt;/li&gt;
&lt;li&gt;字节操作：InputStream 和 OutputStream&lt;/li&gt;
&lt;li&gt;字符操作：Reader 和 Writer&lt;/li&gt;
&lt;li&gt;对象操作：Serializable&lt;/li&gt;
&lt;li&gt;网络操作：Socket&lt;/li&gt;
&lt;li&gt;新的输入/输出：NIO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考了CYC2018的博文：&lt;a href=&quot;https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Java%20基础.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github-CYC2018&lt;/a&gt;🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="NIO" scheme="https://uncleaaron.github.io/Blog/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java基础复习</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java基础复习/</id>
    <published>2018-08-04T03:32:47.000Z</published>
    <updated>2018-08-24T03:32:34.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文大致复习了Java的基础内容：数据类型，String，运算，类型转换，OOP的封装，继承，多态，Object方法包括equals，hashCode，clone，还有final、static关键字，反射，异常，泛型，注解，枚举类型</p><p>参考了github-CYC2018的笔记做的总结，在此基础上补充了一点自己需要补充的内容🖊 </p></blockquote><a id="more"></a><h1 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h1><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>八个基本类型：</p><ul><li>boolean / 1</li><li>byte / 8</li><li><strong>char / 16</strong>      // 注意！Java的char有16位！因为Java用的是UTF-16BE编码，中文和英文都是2个字节</li><li>short / 16</li><li>int / 32</li><li>float / 32</li><li>long / 64</li><li>double / 64</li></ul><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱和拆箱完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;<span class="comment">// 自动装箱，会调用Integer.valueOf(2)方法，尝试从缓存池获取缓存对象，若已经存在，则取缓存中已存在的Integer值为2的对象（是Integer不是int）</span></span><br><span class="line"><span class="keyword">int</span> y = x;<span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure><h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 区别在于：new Integer(123) 每次都会创建一个新对象，而Integer.valueOf(123) 可能会使用缓存对象，因此多次使用Integer.valueOf(123)会取得同一个对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>valueOf() 方法的实现比较简单，先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p><p>Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><h1 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>String被声明为final，因此不可继承</p><p>内部实现：char数组，数组也是final。意味着value数组初始化之后就不能再引用其他数组。String内部没有改变value数组的方法，保证了String的不可变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><h2 id="String不可变的好处"><a href="#String不可变的好处" class="headerlink" title="String不可变的好处"></a>String不可变的好处</h2><ol><li>可以缓存hash值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，只需要进行一次计算。 </li><li>构成了String Pool常量池：String常量池</li><li>安全性：String经常作为参数，不可变保证了连接传输的安全</li><li>线程安全</li></ol><h2 id="String的编码"><a href="#String的编码" class="headerlink" title="String的编码"></a>String的编码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String value = <span class="keyword">new</span> String(str.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure><h2 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h2><p>String不可变，所以是线程安全的</p><p>StringBuffer非线程安全</p><p>StringBuffer线程安全，内部使用synchronized同步</p><h2 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h2><p>使用 String.intern() 可以保证相同内容的字符串变量引用相同的内存对象。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用，这个方法首先把 s1 引用的对象放到 String Pool（字符串常量池）中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s4 = <span class="string">"bbb"</span>;</span><br><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 Java 7 之前，字符串常量池被放在运行时常量池中，它属于永久代。而在 Java 7，字符串常量池被放在堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h1 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Java参数传递是以值传递，不是引用传递。传进方法的都是值拷贝。传进的值只是拷贝，方法内修改无效，但是修改指针所指的内容是有效的。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>Java不允许隐式向下转型（包括精度损失下降的基本类型的转换也不允许：double→long-&gt;int→short→byte，double→float，float→long都不行）</p><h3 id="隐式向下转换的特例：基本类型的-，-，-，-运算"><a href="#隐式向下转换的特例：基本类型的-，-，-，-运算" class="headerlink" title="隐式向下转换的特例：基本类型的+=，/=，-=，*=运算"></a>隐式向下转换的特例：基本类型的+=，/=，-=，*=运算</h3><p>因为字面量1是int类型，它比short类型精度要高，因此不能隐式将int向下转型为short：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;// 这是错误的，1是int类型，s1 + 1会隐式向上转型为int，不能再赋值给short类型的s1。</span></span><br></pre></td></tr></table></figure><p>但是使用 += 运算符可以执行隐式类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;<span class="comment">// +=，/=等都可以。因为其内部做了显式转换，相当于下面显式转换</span></span><br></pre></td></tr></table></figure><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = (<span class="keyword">short</span>) (s1 + <span class="number">1</span>);<span class="comment">// 显式转换OK</span></span><br></pre></td></tr></table></figure><h3 id="float和double"><a href="#float和double" class="headerlink" title="float和double"></a>float和double</h3><p>double不能隐式转换为float ！</p><p>1.1属于double类型，不能直接将1.1赋值给float变量，因为这是向下转型，Java不能隐式向下转型，因为这会造成精度下降。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1// 注意！错误的转型</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span><span class="comment">// 1.1f字面量才是float类型</span></span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">1</span><span class="comment">// 字面量是整数也是可以的</span></span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>Java7开始，switch语句中可以使用String作为判断条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;<span class="comment">// 声明String</span></span><br><span class="line"><span class="keyword">switch</span> (s) &#123;<span class="comment">// 使用String判断</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:<span class="comment">//true</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 不支持 long，double，float，是因为 switch 的设计初衷是为那些只需要对少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p><p>Switch支持char, byte, short, int, Character, Byte, Short, Integer, String, or an enum</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>优先级从高到低</p><p><strong><code>~</code></strong>：按位取反</p><p><strong><code>&lt;&lt;</code></strong>：左移位（低位补0）</p><p><strong><code>&gt;&gt;</code></strong>：右移位（高位补符号位）</p><p><strong><code>&gt;&gt;&gt;</code></strong>：无符号右移位（高位补0）</p><p><code>&amp;</code>：按位与</p><p><strong><code>^</code></strong>：按位异或</p><p><strong><code>|</code></strong>：按位或</p><h1 id="四、封装、继承、多态"><a href="#四、封装、继承、多态" class="headerlink" title="四、封装、继承、多态"></a>四、封装、继承、多态</h1><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>java的四个访问权限：private、default、protected、public，(其中default不是访问权限修饰符)</p><table><thead><tr><th>权限</th><th>类内</th><th>同包</th><th>不同包子类</th><th>不同包非子类</th><th>备注</th></tr></thead><tbody><tr><td><strong>private</strong></td><td>√</td><td>××</td><td>××</td><td>××</td><td>类私有</td></tr><tr><td>default</td><td>√</td><td>√</td><td>××</td><td>××</td><td>默认，包访问权限</td></tr><tr><td><strong>protected</strong></td><td>√</td><td>√</td><td>√</td><td>××</td><td>保护，包与子类访问权限，修饰成员</td></tr><tr><td><strong>public</strong></td><td>√</td><td>√</td><td>√</td><td>√</td><td>公开</td></tr></tbody></table><p>成员可见：其他类可以用这个类的实例对象访问到该成员</p><p>类可见：其他类可以用这个类创建实例对象</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="子类构造函数的约束"><a href="#子类构造函数的约束" class="headerlink" title="子类构造函数的约束"></a>子类构造函数的约束</h3><p>子父类中的构造函数的特点：　　</p><ol><li><p><strong>在子类的构造函数中第一行有默认隐式的super();</strong></p><p>所以在子类构造对象时，发现，访问子类构造函数时，父类构造函数也运行了。 </p></li><li><p><strong>子类构造函数默认调用的是父类中的空参数构造函数</strong>，<strong>如需调用父类中的含参构造，可以在子类构造函数中定义</strong>super(args)。</p></li><li><p><strong>如果父类中没有定义空参构造，那么子类构造必须用super(args)明确</strong>要调用父类的哪个构造函数。</p></li><li><p>若<strong>子类构造函数使用this()调用了本类构造函数，那么该构造函数的隐藏super()就没有了</strong>，因为super()和this()都只能定义第一行，只能有一个。</p><p><strong>但子类中一定有其他的构造函数会访问到父类的构造函数</strong>。</p></li></ol><p>注意：super()语句必须要定义在子类构造函数的第一行。因为<strong>父类的初始化动作要先完成</strong>。</p><h2 id="重写与重载（多态）"><a href="#重写与重载（多态）" class="headerlink" title="重写与重载（多态）"></a>重写与重载（多态）</h2><h3 id="重写（及重写的返回值类型、访问权限要求）"><a href="#重写（及重写的返回值类型、访问权限要求）" class="headerlink" title="重写（及重写的返回值类型、访问权限要求）"></a>重写（及重写的返回值类型、访问权限要求）</h3><ul><li>重写（Override）存在于继承体系中，指子类实现了一个与父类在<strong>方法声明上完全相同</strong>的一个方法，<ul><li><strong>返回值类型</strong>：<strong>子类小于或等于父类</strong>的返回值类型；</li><li><strong>方法访问级别</strong>：<strong>子类不低于父类</strong>；子类中重写方法的访问级别不允许低于父类的访问级别。这是为了<strong>确保可以使用父类实例的地方都可以使用子类实例</strong>，也就是确保满足里氏替换原则。</li></ul></li></ul><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li>重载（Overload）存在于同一个类中，指一个方法与已经存在的<strong>方法名称相同</strong>，但是<strong>参数类型、个数、顺序至少有一个不同</strong>。应该注意的是，返回值不同，其它都相同不算是重载。</li></ul><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>访问父类的关键字</p><ul><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而完成一些初始化的工作。</li><li>访问父类的成员：如果子类覆盖了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);<span class="comment">// 访问父类构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();<span class="comment">// 访问父类的方法</span></span><br><span class="line">        System.out.println(<span class="string">"SuperExtendExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。 </p><p>如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessWithInnerClassExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;<span class="comment">// 私有内部类，成员可以暴露</span></span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccessWithInnerClassExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerClass.x; <span class="comment">// 直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><strong>抽象类</strong>和<strong>抽象方法</strong>都用<strong><code>abstract</code></strong>声明。抽象方法一定位于抽象类中。</p><p>抽象类<strong>不能被实例化</strong>，需要继承抽象类才能实例化其子类。这是它和普通类最大的区别。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClassExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;<span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;<span class="comment">// 实例方法</span></span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>从Java8开始，<strong>接口可以拥有默认的方法实现，此时用<code>default</code>修饰方法体</strong>（因为不支持默认方法的接口维护成本太高了，在Java8以前，一个接口想添加新的方法，需要修改所有的实现类；有的可能需要用适配器转接默认实现，如Spring的WebMvcConfig接口和WebMvcConfigAdaptor）</p><p>接口的成员（字段和方法）默认都是public的，并且不允许定义为其他访问权限private或protected。</p><p>接口的字段默认都是public static final的常量。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">123</span>; <span class="comment">// public static final 的常量</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;<span class="comment">// public的接口方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;<span class="comment">// 默认方法实现，用default修饰</span></span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类和接口比较"><a href="#抽象类和接口比较" class="headerlink" title="抽象类和接口比较"></a>抽象类和接口比较</h3><ul><li><strong>一个类可以实现多个接口，只能继承最多一个类或者抽象类</strong></li><li>接口的字段只能是public static final的，抽象类没这个限制</li><li>接口的方法只能是public的，抽象类没这个限制</li></ul><p>简单说，抽象类只是比普通类少了点方法实现，其他无太大差别。而接口不一样，必须是公开的。</p><p>抽象类是IS-A关系，子类对象必须能够替换掉父类对象</p><p>接口是Like-A关系，是一种契约，不需要完全实现</p><h3 id="选择抽象类还是接口？"><a href="#选择抽象类还是接口？" class="headerlink" title="选择抽象类还是接口？"></a>选择抽象类还是接口？</h3><p>很多情况下，接口优先与抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且，Java8开始，接口也能有默认方法实现，使得修改接口的成本也变得很低。</p><p><strong>使用接口：</strong></p><p>需要让不相关的类都<strong>实现一个方法</strong>，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法； </p><p>需要使用<strong>多继承</strong></p><p><strong>使用抽象类：</strong></p><ul><li>需要在几个相关的类中<strong>共享代码</strong></li><li>需要能<strong>控制</strong>继承来的成员的访问权限，而不都是public</li><li>需要<strong>继承</strong>非静态（non-static）和非常量（non-final）的字段。</li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类的特点"><a href="#内部类的特点" class="headerlink" title="内部类的特点"></a>内部类的特点</h3><ul><li>内部类提供了更好的封装。只有外部类能访问内部类</li><li>内部类可以直接访问外部类的属性和方法，即使是private。因为内部类是成员</li><li>外部类不能直接访问内部类的属性和方法。要用 内部类实例.xxx</li></ul><h3 id="内部类分类"><a href="#内部类分类" class="headerlink" title="内部类分类"></a>内部类分类</h3><p>内部类有4种：成员内部类，局部内部类，匿名内部类，静态内部类。</p><ol><li><p><strong>成员内部类</strong>：作为外部类的一个成员存在，与外部类的属性、方法并列，不能直接访问</p><ul><li><p><strong>非静态内部类中不能存在static成员</strong>。</p></li><li><p>非静态内部类中<strong>可以调用外部类的任何成员</strong>，不管是静态的还是非静态的 </p></li><li><p><strong>创建：</strong>非静态内部类要依靠外部类实例.内部类创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.InnerClass inner = <span class="keyword">new</span> OuterClass().new InnerClass();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>局部内部类</strong>：在方法中定义的内部类，与局部变量类似，不能加访问限定符。其范围为定义它的代码块。</p></li><li><p><strong>匿名内部类</strong>：在方法中new的接口或抽象类实现。若实现的方法只有一个，可以用lambda表达式代替。</p><ul><li>无构造方法（因为没有类名）</li><li>无静态成员或方法</li><li>无访问修饰符</li></ul><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类，实现的是ActionListener接口</span></span><br><span class="line">        <span class="keyword">new</span> ActionListener()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"click action..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.onAction();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态内部类</strong>：定义在外部类中，用static定义。</p><ul><li>静态内部类<strong>不可以使用任何外围类的非static成员</strong>变量和方法。</li><li>静态内部类不依附外部类，<strong>可以直接创建</strong></li></ul></li></ol><h3 id="静态内部类和非静态内部类对比"><a href="#静态内部类和非静态内部类对比" class="headerlink" title="静态内部类和非静态内部类对比"></a>静态内部类和非静态内部类对比</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String outerName;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass1</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 1. 在静态内部类中可以存在静态成员 */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String _innerName = <span class="string">"static variable"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 2. 静态内部类只能访问外部类的静态成员变量和方法</span></span><br><span class="line"><span class="comment">             *    不能访问外部类的非静态成员变量和方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(<span class="string">"OutClass name :"</span> + outerName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass2</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 1. 非静态内部类中不能存在静态成员 */</span></span><br><span class="line">        <span class="keyword">public</span> String _innerName = <span class="string">"no static variable"</span>;</span><br><span class="line">        <span class="comment">/* 2. 非静态内部类中可以调用外部类的任何成员,不管是静态的还是非静态的 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"OuterClass name："</span> + outerName);</span><br><span class="line">            System.out.println(<span class="string">"OuterClass age："</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 3. 外部类能直接访问静态内部类静态元素 */</span></span><br><span class="line">        System.out.println(InnerClass1._innerName);</span><br><span class="line">        <span class="comment">/* 4. 静态内部类可以直接创建实例不需要依赖于外部类 */</span></span><br><span class="line">        <span class="keyword">new</span> InnerClass1().display();</span><br><span class="line">        <span class="comment">/* 4. 非静态内部的创建需要依赖于外部类 */</span></span><br><span class="line">        OuterClass.InnerClass2 inner2 = <span class="keyword">new</span> OuterClass().new InnerClass2();</span><br><span class="line">        <span class="comment">/* 3. 非静态内部类的成员需要使用非静态内部类的实例访问 */</span></span><br><span class="line">        System.out.println(inner2._innerName);</span><br><span class="line">        inner2.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类参考链接：</p><ul><li><a href="https://blog.csdn.net/suifeng3051/article/details/51791812" target="_blank" rel="noopener">https://blog.csdn.net/suifeng3051/article/details/51791812</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3811445.html</a></li></ul><h1 id="五、Object通用方法"><a href="#五、Object通用方法" class="headerlink" title="五、Object通用方法"></a>五、Object通用方法</h1><h2 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h2><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><h3 id="equal-与"><a href="#equal-与" class="headerlink" title="equal()与=="></a>equal()与==</h3><p>对于基本类型，==判断两个值是否相等，基本类型没有equals()方法。</p><p>对于引用类型，==判断两个实例是否引用指针是否指向同一个对象，而equals()判断引用的对象是否等价。</p><p>对于包装类型，要使用equals()比较数值（如IntegerCache只保存-127~128的值，其他的值都为新对象在堆上产生，不能用==，要使用<code>integer.equals()</code>）</p><p>若未重写equals()，equals的实现就是==</p><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p>hashCode() 返回散列值，而 equals() 是用来判断两个实例是否等价。</p><p><strong>等价的两个实例散列值一定要相同，但是散列值相同的两个实例不一定等价。</strong> (相当于hashCode将对象分到桶里，而equals再区分到底等不等) </p><p>HashSet中会先识别hashCode是否相等，再识别equals是否相等，以此判断两个对象是否为同一个对象。 </p><h3 id="hashCode-与equal"><a href="#hashCode-与equal" class="headerlink" title="hashCode()与equal()"></a>hashCode()与equal()</h3><p><strong>重写equals时一定要重写hashCode()方法</strong>，保证两个等价的实例的hashCode也相等。</p><p><strong>不同时重写equals和hashCode的后果</strong>：</p><ul><li>可能导致<strong>数据的不唯一</strong>。（HashSet中会认为是不同的对象，导致存储了两次同样的数据）</li><li><strong>内存泄漏</strong>（开发人员在删除HashSet元素时，自认为已经删除一个引用，但其实还保留了另一个相同内容的副本，导致该对象长时间得不到释放，造成内存泄漏） </li></ul><h3 id="实现hashCode"><a href="#实现hashCode" class="headerlink" title="实现hashCode"></a>实现hashCode</h3><p>理想的散列函数应当具有均匀性，即不相等的实例应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><p>一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    int result = 17;</span><br><span class="line">    result = 31 * result + x;</span><br><span class="line">    result = 31 * result + y;</span><br><span class="line">    result = 31 * result + z;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 </p><h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><h3 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h3><p>clone() 是 Object 的 protected 方法，<strong>一个类不显式去重写 clone()和实现Cloneable接口，其它类就不能调用该类实例的 clone() 方法</strong>。 </p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;<span class="comment">// 实现Cloneable接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;<span class="comment">// 重写clone()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><ul><li><strong>浅拷贝：拷贝实例和实例的引用</strong>。拷贝实例和原始实例的引用类型<strong>引用同一个对象</strong>；</li><li><strong>深拷贝：拷贝实例引用指向的对象</strong>。拷贝实例和原始实例的引用类型<strong>引用不同对象</strong>。</li></ul><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneConstructorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CloneConstructorExample e1 = <span class="keyword">new</span> CloneConstructorExample();</span><br><span class="line">CloneConstructorExample e2 = <span class="keyword">new</span> CloneConstructorExample(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h1 id="六、关键字"><a href="#六、关键字" class="headerlink" title="六、关键字"></a>六、关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>常量</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态</p><h1 id="七、反射"><a href="#七、反射" class="headerlink" title="七、反射"></a>七、反射</h1><p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 <strong>Class.forName</strong>(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p><strong>反射可以提供运行时的类信息，并且这个类在运行时才加载进来</strong>，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>反射可以不通过访问权限访问，破坏了封装性。</p><h3 id="获得Class对象（Class）"><a href="#获得Class对象（Class）" class="headerlink" title="获得Class对象（Class）"></a>获得Class对象（Class）</h3><blockquote><p>forName, getClass</p></blockquote><p><strong><code>Class.forName(&quot;Class全类名&quot;)</code></strong>    // 1. 使用Class类的forName静态方法</p><p><strong><code>Class&lt;?&gt; klass = ins.getClass()</code></strong>    // 2. 调用某个对象的getClass()方法 </p><p><strong><code>Class&lt;?&gt; klass = ClassA.class</code></strong>    // 3. 直接获取某一个类对象的class</p><p><strong><code>Class&lt;?&gt; klass = Integer.TYPE</code></strong>    // 直接获取某一个对象的class</p><h3 id="获取构造器（Constructor）"><a href="#获取构造器（Constructor）" class="headerlink" title="获取构造器（Constructor）"></a>获取构造器（Constructor）</h3><blockquote><p>class.getConstructor</p></blockquote><p>通过Class类的getConstructor方法得到Constructor类的一个实例，Constructor类有一个newInstance方法可以创建一个对象实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clz.getConstructor(args.class)；//参数为原方法参数的类型</span><br></pre></td></tr></table></figure><h3 id="创建实例（Instance）"><a href="#创建实例（Instance）" class="headerlink" title="创建实例（Instance）"></a>创建实例（Instance）</h3><blockquote><p>class.newInstance, constructor.newInstance</p></blockquote><p>先获得class对象，如Class clz</p><ol><li><p>使用Class对象的newInstance()创建Class对象对应类的实例。</p><p><strong><code>Object ins = clz.newInstance()</code></strong></p></li><li><p>指定构造器创建实例：先通过Class对象获取Constructor构造器对象，再通过Constructor对象的newInstance()方法创建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clz.getConstructor(args.class)；<span class="comment">//参数为原方法参数的类型</span></span><br><span class="line">Object obj = constructor.newInstance(args);</span><br></pre></td></tr></table></figure></li></ol><h3 id="获取方法（method）"><a href="#获取方法（method）" class="headerlink" title="获取方法（method）"></a>获取方法（method）</h3><blockquote><p>clz.getMethods();</p></blockquote><p>获取某个Class对象的方法集合（无视访问权限，不包括继承的方法）</p><p><strong><code>Method[] methods = clz.getDeclaredMethods();</code></strong></p><p>获取某个Class对象的公用方法集合（public），包括继承的公用方法</p><p><strong><code>Method[] methods = clz.getMethods()</code></strong></p><p>获取一个特定的方法。其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象 </p><p><strong><code>clz.getMethod(String methodName, Class&lt;?&gt;... paramTypes)</code></strong></p><p><strong><code>clz.getDeclaredMethod(String methodName, Class&lt;?&gt;... paramTypes)</code></strong></p><h3 id="获取成员变量（Field）"><a href="#获取成员变量（Field）" class="headerlink" title="获取成员变量（Field）"></a>获取成员变量（Field）</h3><p><strong><code>getField(String name)</code></strong></p><p><strong><code>getDeclaredField(String name)</code></strong></p><p><strong><code>getFields()</code></strong></p><p><strong><code>getDeclaredFields()</code></strong></p><h3 id="调用方法（method-invoke）"><a href="#调用方法（method-invoke）" class="headerlink" title="调用方法（method.invoke）"></a>调用方法（method.invoke）</h3><p><strong><code>method.invoke(Object obj, Object...args)</code></strong>  // 参数为要调用方法的实例对象和参数列表</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;<span class="comment">// 在此之外声明了一个Testor的类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clz = Testor.class;</span><br><span class="line">        Object obj = clz.newInstance();<span class="comment">//创建Testor的实例</span></span><br><span class="line">        Method method = clz.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class);<span class="comment">// 获取Testor类的add方法</span></span><br><span class="line">        Object result = method.invoke(obj,<span class="number">1</span>,<span class="number">4</span>);<span class="comment">//调用method对应的方法 =&gt; add(1,4)</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否为某个类的实例（isInstance）"><a href="#判断是否为某个类的实例（isInstance）" class="headerlink" title="判断是否为某个类的实例（isInstance）"></a>判断是否为某个类的实例（isInstance）</h3><p>一般地，我们用<strong>instanceof关键字来判断是否为某个类的实例</strong>。同时我们<strong>也可以借助反射中Class对象的isInstance()方法</strong>来判断是否为某个类的实例，它是一个Native方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;<span class="comment">// Class对象的方法，用法：clz.inInstance(obj)</span></span><br></pre></td></tr></table></figure><h3 id="反射创建数组"><a href="#反射创建数组" class="headerlink" title="反射创建数组"></a>反射创建数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object array = java.lang.reflect.Array.newInstance(Class elementClass, <span class="keyword">int</span> length);<span class="comment">//实例array</span></span><br><span class="line">java.lang.reflect.Array.set(array, <span class="number">0</span>, elem);<span class="comment">// 往array插入值</span></span><br><span class="line">Array.get(array, <span class="number">0</span>);<span class="comment">// 读取值</span></span><br></pre></td></tr></table></figure><h1 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h1><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。</p><ul><li><p>Error：表示 JVM 无法处理的错误。</p></li><li><p>Exception：表示程序可捕捉可处理的异常。分为两种：</p><ul><li><strong>受检异常</strong> ：编译期可预测的，必须处理的异常，需要用 try…catch… 语句捕获并处理，或用throws子句抛出，否则编译无法通过。</li><li><strong>非受检异常</strong> ：RuntimeException，运行时异常，不要求强制处理。</li></ul></li></ul><p><img src="/Blog/Java/Java基础复习/异常类图.png" alt="异常类图"></p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>五个关键字，分别是：<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>、<code>throws</code> </p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>如果<strong>一个方法可以导致一个异常但不处理它</strong>，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常。要做到这点，我们可以在方法声明中包含一个<code>throws</code>子句。一个<code>throws</code>子句列举了一个方法可能引发的所有异常类型。 </p><h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>用户自定义异常类，只需继承<code>Exception</code>类即可。</p><p>在程序中使用自定义异常类，大体可分为以下几个步骤:</p><ul><li>创建自定义异常类。</li><li>在方法中通过<code>throw</code>关键字抛出异常对象。</li><li>如果在当前抛出异常的方法中处理异常，可以使用<code>try-catch</code>语句捕获并处理；否则在方法的声明处通过<code>throws</code>关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常方法的调用者中捕获并处理异常。</li></ul><p>本节参考：<a href="https://www.tianmaying.com/tutorial/Java-Exception" target="_blank" rel="noopener">Java异常处理-详解</a></p><h1 id="九、泛型"><a href="#九、泛型" class="headerlink" title="九、泛型"></a>九、泛型</h1><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><h2 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h2><p>extend super</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>？</p><p>T</p><h2 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h2><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息</p><ul><li><a href="http://www.importnew.com/24029.html" target="_blank" rel="noopener">Java 泛型详解</a></li></ul><h1 id="十、注解"><a href="#十、注解" class="headerlink" title="十、注解"></a>十、注解</h1><p>Annotation类型定义为@interface。</p><ol><li><p>所有的Annotation会自动继承java.lang.Annotation接口，并且不能再去继承别的类或接口。.   </p></li><li><p>参数成员只能用public或默认(default)这两个访问权修饰   </p></li><li>参数成员只能用8种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.   </li><li>要获取类方法和字段的注解信息，必须通过反射获取 Annotation对象，除此之外没有获取注解的方法   </li><li>注解也可以没有定义成员, 可以用于标记 </li></ol><p>PS:自定义注解需要使用到元注解 </p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>@Documented –注解是否将包含在JavaDoc中</p><p>@Retention –什么时候使用该注解（RUNTIME运行, CLASS类加载, SOURCE编译期）</p><p>@Target –注解用于什么地方（可用ElementType的参数）</p><p>@Inherited – 是否允许子类继承该注解</p><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><ol><li><p>@Override</p><p>java.lang.Override是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java编译器将以一个编译错误来警示。</p></li><li><p>@Deprecated</p><p>Deprecated也是一种标记类型注解。当一个类型或者类型成员或父类使用@Deprecated修饰的话，编译器将不鼓励使用这个被标注的程序元素。</p></li><li><p>@SuppressWarnings</p><p>SuppressWarning不是一个标记类型注解。抑制警告。它有一个类型为String[]的成员，这个成员的值为被禁止的警告名。对于javac编译器来讲，被-Xlint选项有效的警告名也同样对@SuppressWarings有效，同时编译器忽略掉无法识别的警告名。</p><p>@SuppressWarnings(“unchecked”) </p></li></ol><h2 id="自定义注解实例"><a href="#自定义注解实例" class="headerlink" title="自定义注解实例"></a>自定义注解实例</h2><p>编写注解，注解处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水果颜色注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitColor &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 颜色枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Color&#123; BLUE,RED,GREEN&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 颜色属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Color <span class="title">fruitColor</span><span class="params">()</span> <span class="keyword">default</span> Color.GREEN</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本节参考：<a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html" target="_blank" rel="noopener">注解Annotation实现原理及自定义注解例子</a></li></ul><h1 id="十一、枚举类型"><a href="#十一、枚举类型" class="headerlink" title="十一、枚举类型"></a>十一、枚举类型</h1><table><thead><tr><th>返回类型</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>compareTo(E o)</code></td><td>比较此枚举与指定对象的顺序</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object other)</code></td><td>当指定对象等于此枚举常量时，返回 true。</td></tr><tr><td><code>Class&lt;?&gt;</code></td><td><code>getDeclaringClass()</code></td><td>返回与此枚举常量的枚举类型相对应的 Class 对象</td></tr><tr><td><code>String</code></td><td><strong><code>name()</code></strong></td><td>返回此枚举常量的名称，在其枚举声明中对其进行声明</td></tr><tr><td><code>int</code></td><td><strong><code>ordinal()</code></strong></td><td>返回枚举常量的序数（它在枚举声明中的位置，从0开始）</td></tr><tr><td><code>String</code></td><td><strong><code>toString()</code></strong></td><td>返回枚举常量的名称，它包含在声明中</td></tr><tr><td><code>static&lt;T extends Enum&lt;T&gt;&gt; T</code></td><td><strong><code>static valueOf(Class&lt;T&gt; enumType, String name)</code></strong></td><td>返回带指定名称的指定枚举类型的枚举常量。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day2 &#123;</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>),<span class="comment">// 这种写法都是调用构造函数</span></span><br><span class="line">    TUESDAY(<span class="string">"星期二"</span>),<span class="comment">// 这些都是本类型的实例，名为TUSDAY的Day2类型，类似多例模式</span></span><br><span class="line">    WEDNESDAY(<span class="string">"星期三"</span>),</span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>),</span><br><span class="line">    FRIDAY(<span class="string">"星期五"</span>),</span><br><span class="line">    SATURDAY(<span class="string">"星期六"</span>),</span><br><span class="line">    SUNDAY(<span class="string">"星期日"</span>);<span class="comment">// 以上枚举实例，记住要用分号结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">// 中文描述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造,防止被外部调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day2</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc=desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义方法,返回描述,跟常规类的定义没区别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Day2 day:Day2.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"name:"</span>+day.name()+</span><br><span class="line">                    <span class="string">",desc:"</span>+day.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     输出结果:</span></span><br><span class="line"><span class="comment">     name:MONDAY,desc:星期一</span></span><br><span class="line"><span class="comment">     name:TUESDAY,desc:星期二</span></span><br><span class="line"><span class="comment">     name:WEDNESDAY,desc:星期三</span></span><br><span class="line"><span class="comment">     name:THURSDAY,desc:星期四</span></span><br><span class="line"><span class="comment">     name:FRIDAY,desc:星期五</span></span><br><span class="line"><span class="comment">     name:SATURDAY,desc:星期六</span></span><br><span class="line"><span class="comment">     name:SUNDAY,desc:星期日</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参考资料：<a href="https://blog.csdn.net/javazejian/article/details/71333103" target="_blank" rel="noopener">Java枚举类型enum</a></li></ul><h1 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h1><h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h2><p>Arrays.asList()返回的List是数组的一个快照，底层数据实际上还是原数组，修改数组会修改这个asList()返回的List。而且不能在返回的List上添加删除元素。</p><p>Arrays.asList返回的ArrayList不是我们常用的java.util.arraylist，而是其自己工具类的一个<strong>静态私有内部类</strong>，没有提供add方法。</p><p>因此，除非确信array.aslist后长度不会增加，否则谨慎使用：List abc=Arrays.asList(“a”,”b”,”c”)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文大致复习了Java的基础内容：数据类型，String，运算，类型转换，OOP的封装，继承，多态，Object方法包括equals，hashCode，clone，还有final、static关键字，反射，异常，泛型，注解，枚举类型&lt;/p&gt;
&lt;p&gt;参考了github-CYC2018的笔记做的总结，在此基础上补充了一点自己需要补充的内容🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java8-Stream流-复习</title>
    <link href="https://uncleaaron.github.io/Blog/Java/java8-Stream%E6%B5%81-%E5%A4%8D%E4%B9%A0/"/>
    <id>https://uncleaaron.github.io/Blog/Java/java8-Stream流-复习/</id>
    <published>2018-08-03T07:03:51.000Z</published>
    <updated>2018-08-03T07:03:51.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="default1" scheme="https://uncleaaron.github.io/Blog/tags/default1/"/>
    
      <category term="default2" scheme="https://uncleaaron.github.io/Blog/tags/default2/"/>
    
  </entry>
  
  <entry>
    <title>java8其中两个新特性-lambda表达式和Stream流-复习</title>
    <link href="https://uncleaaron.github.io/Blog/Java/java8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%A4%8D%E4%B9%A0/"/>
    <id>https://uncleaaron.github.io/Blog/Java/java8-lambda表达式-复习/</id>
    <published>2018-08-03T07:02:16.000Z</published>
    <updated>2018-08-03T08:37:01.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>去除类定义和类方法，只留下方法使用的参数表和方法实现</p><p>如下：</p><p><code>(params) -&gt; { statements; }</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String a = <span class="string">"test1"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(<span class="string">"testa"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"testc"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替代的类只有一个方法的时候才能生效，否则java识别不出应该用哪个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量作用域：不能修改匿名方法外的变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="default1" scheme="https://uncleaaron.github.io/Blog/tags/default1/"/>
    
      <category term="default2" scheme="https://uncleaaron.github.io/Blog/tags/default2/"/>
    
  </entry>
  
  <entry>
    <title>java集合框架-汇总复习</title>
    <link href="https://uncleaaron.github.io/Blog/Java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E6%B1%87%E6%80%BB%E5%A4%8D%E4%B9%A0/"/>
    <id>https://uncleaaron.github.io/Blog/Java/java集合框架-汇总复习/</id>
    <published>2018-08-03T07:01:55.000Z</published>
    <updated>2018-08-06T03:20:33.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注</p><p><a href="https://www.jianshu.com/p/bfdb5ffa0ae2" target="_blank" rel="noopener">Java1.8集合框架索引总结</a> 这里有人整合了一段，可以阅读一下</p><p>此外，有人总结的面试题<a href="https://blog.csdn.net/qq_26947195/article/details/79755944" target="_blank" rel="noopener">Java集合框架面试总结</a></p><p>这个博主讲的非常精髓，有空也要读一下<a href="https://www.cnblogs.com/xiaoxi/p/6089984.html" target="_blank" rel="noopener">Java集合框架综述</a>🖊</p></blockquote><a id="more"></a><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>Collection集合：Set，List，Queue</p><p>Map图：（与Collection不同族）HashMap，HashTable，TreeMap，ConcurrentHashMap</p><p><img src="/Blog/Java/java集合框架-汇总复习/Collection类图.png" alt="类图"></p><p><img src="/Blog/Java/java集合框架-汇总复习/Map类图-简易.png" alt="Map类图-简易"></p><h1 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><strong>特点</strong>：<strong>查询快，增删慢</strong></p><p><strong>实现</strong>：<strong>动态数组</strong>，支持随机访问</p><p>默认大小10，默认扩展50%+1个</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。 </p><p><strong>特点</strong>：<strong>增删块，查询慢</strong></p><p><strong>实现</strong>：<strong>双向链表</strong></p><p>实现了Deque<strong>双向队列</strong>（offer入队，pool出队，peek查看）</p><p>可用作<strong>Stack栈</strong>（push入栈，pop出栈，peek查看）</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>与ArrayList相似，数组</p><p><strong>线程安全</strong>（synchronized），效率低，不推荐</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>LIFO先进后出，继承了Vector</p><p>数组</p><p>线程安全，效率低，不推荐</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>无序，按照Hash算法存储元素，</p><p><strong>实现</strong>：<strong>基于HashMap</strong>存储元素（先检查hashCode再检查equals）</p><p><strong>特点</strong>：<strong>存储性能和查询性能良好</strong>，<strong>不支持有序</strong>操作（用Iterator遍历的结果是不确定的）</p><p>非线程安全</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p><strong>可排序</strong>的Set结构</p><p><strong>实现</strong>：<strong>红黑树</strong>，基于TreeMap实现（底层维护一个TreeMap）</p><p>支持自然排序和定制排序</p><p>但是查找效率不如 HashSet：HashSet 查找时间复杂度为 O(1)，TreeSet 则为 O(logN) </p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>HashSet的子类</p><p><strong>实现</strong>：<strong>双向链表</strong> 维护<strong>元素顺序</strong></p><p>特点：具有 HashSet 的查找效率，有插入顺序</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HashSet性能最高</p><p>实现排序Set：用TreeSet</p><p>实现插入顺序：用LinkedHashSet</p><p>Set中尽量只添加不可变对象</p><p>上述三个Set都是线程不安全的，若需要并发访问，需要手动实现同步。（例Collection.synchronizedSet方法）</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>实现双向队列（offer入队，pool出队，peek查看）</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>优先队列</p><p><strong>实现：堆结构</strong></p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>Entry数组保存key-value</p><p>存储和查询时<strong>先根据HashCode决定在数组</strong>的位置，<strong>再根据equals决定</strong>其在该数组位置上的<strong>链表</strong>中的存储位置；</p><p>用<strong>链地址法</strong>解决Hash冲突（解决hash冲突的办法有1. 开放地址法 2. 再哈希法 3. 链地址法 4. 建立公共溢出区）</p><p><img src="/Blog/Java/java集合框架-汇总复习/HashMap.jpg" alt="HashMap"></p><p>默认大小16，加载因子为0.75，可以使用Collections.synchronizeMap(hashMap)实现同步</p><p>Java8开始，一个桶存储的链表长度&gt;8时，链表将转为红黑树</p><p>关于hashMap的总结这里还有更多：<a href="https://blog.csdn.net/weixin_37864013/article/details/77428919" target="_blank" rel="noopener">HashMap总结：链接</a></p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p><strong>实现：双向链表</strong> 维护元素的顺序，</p><p>顺序：<strong>插入</strong>顺序 或 <strong>最近最少使用</strong>（LRU）顺序。 </p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>实现：红黑树</p><p>TreeMap集合默认会对键进行排序，所以键必须实现自然排序和定制排序中的一种 </p><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>数据结构 HashMap 一致，但它是线程安全的，但Hashtable则会锁定整个map</p><p>它是遗留类，不应该去使用它。</p><p>现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 </p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>线程安全：分段锁机制：ConcurrentHashMap仅仅锁定map的某个部分</p><p>高效的线程安全</p><h3 id="Map类集合K-V能不能存储null值的情况"><a href="#Map类集合K-V能不能存储null值的情况" class="headerlink" title="Map类集合K/V能不能存储null值的情况"></a>Map类集合K/V能不能存储null值的情况</h3><p><img src="/Blog/Java/java集合框架-汇总复习/Map的是否允许null值.png" alt="Map的是否允许null值"></p><p>只有HashMap可以都为null，以及Tree只允许Value为null（key要排序），其他都不能为null</p><h1 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/bfdb5ffa0ae2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java1.8集合框架索引总结&lt;/a&gt; 这里有人整合了一段，可以阅读一下&lt;/p&gt;
&lt;p&gt;此外，有人总结的面试题&lt;a href=&quot;https://blog.csdn.net/qq_26947195/article/details/79755944&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java集合框架面试总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个博主讲的非常精髓，有空也要读一下&lt;a href=&quot;https://www.cnblogs.com/xiaoxi/p/6089984.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java集合框架综述&lt;/a&gt;🖊&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="Java集合框架" scheme="https://uncleaaron.github.io/Blog/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引</title>
    <link href="https://uncleaaron.github.io/Blog/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E7%B4%A2%E5%BC%95/"/>
    <id>https://uncleaaron.github.io/Blog/数据库/Mysql索引/</id>
    <published>2018-08-03T07:01:55.000Z</published>
    <updated>2018-08-18T09:15:16.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><ol><li>索引分为主键 Primary Key、普通索引 Index、唯一索引 Unique、全文索引 FullText、空间索引 Spatial </li><li>Mysql的存储引擎分为InnoDB、MyISAM、Memory</li><li>其中InnoDB和MyISAM普遍使用B+Tree实现索引，但是InnoDB的索引结构就是数据文件本身，MyISAM的索引文件与数据分离</li><li>索引的最左匹配原则和索引使用策略   🖊</li></ol></blockquote><a id="more"></a><h1 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h1><p>我们知道，MySQL 查询数据是从第一条记录开始依次查找，直到读完整个表或者找到匹配的行。数据库表的数据量越大，MySQL 查询所花费的时间就越多。索引的出现就是为了改善查询性能的。MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。从本质上来讲，索引是一种以空间换时间的技术。因为索引的建立是需要占用磁盘物理空间的。</p><p>索引的目的在于提高查询效率，这个过程可以类比查字典：假如我们需要查询 <code>mysql</code> 这个单词，我们通常会先在字母表里找到字母 <code>m</code>，这样我们就定位到了 <code>m</code> 开头的单词在词典的位置，然后根据定位到的位置从下往下找到 <code>y</code> 字母，最后找到剩下的 <code>sql</code>。索引就相当于字典里的字母表。如果不使用字母表，想要找到<code>mysql</code> 这个单词，我们就需要把字典从头开始翻一遍，直到翻到<code>m</code> 开头的单词在词典的位置，这个过程重复而浪费时间。</p><p>通过使用索引技术，MySQL 可以大大减少存储引擎需要扫描的数据量，把磁盘 IO 的随机读取变成顺序读取，从而加快查询效率。</p><h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><h3 id="主键索引（Primary-Key）"><a href="#主键索引（Primary-Key）" class="headerlink" title="主键索引（Primary Key）"></a>主键索引（Primary Key）</h3><p>特殊的唯一索引，不允许有空值。一个表只能由一个主键。一般在建表同时指定</p><h3 id="普通索引（INDEX）"><a href="#普通索引（INDEX）" class="headerlink" title="普通索引（INDEX）"></a>普通索引（INDEX）</h3><p>MySQL 允许对两个或两个以上的列上创建索引，我们习惯上称之为联合索引（又叫复合索引，或者组合索引）。实际上，单列索引可以看成联合索引元素数为1的特例。</p><p>这是最基本的索引，它没有任何限制。可以在创建表的时候指定，也可以在修改表结构的时候指定。</p><h3 id="唯一索引（Unique）"><a href="#唯一索引（Unique）" class="headerlink" title="唯一索引（Unique）"></a>唯一索引（Unique）</h3><p>唯一索引列的值必须唯一，但可以为空值。可以是联合索引，但列值的组合必须唯一。</p><h3 id="全文索引（FullText）"><a href="#全文索引（FullText）" class="headerlink" title="全文索引（FullText）"></a>全文索引（FullText）</h3><p>全文索引是一种特殊类型的索引，通过建立倒排索引，快速匹配文档的方式。它查找的是文本中的关键字，而不是直接比较索引中的值。全文索引跟其它几种索引类型的匹配方式完全不一样。它有许多需要注意的细节，比如停用词、词干和复数、布尔搜索等。另外，<strong>只有字段类型为 <code>char</code>、<code>varchar</code> 和 <code>text</code>的字段才能设置全文索引</strong>。</p><h3 id="空间索引（Spatial）"><a href="#空间索引（Spatial）" class="headerlink" title="空间索引（Spatial）"></a>空间索引（Spatial）</h3><p>空间索引用于地理数据存储，无需前缀查询，而是会从所有维度来索引数据。 </p><p>下表是 MySQL 中常见的存储引擎对索引类型的支持情况：</p><table><thead><tr><th>索引类型</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>PRIMARY KEY</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>INDEX</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Unique</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>FULLTEXT</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>SPATIAL</td><td>支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h3 id="索引数据结构类型（Index-Type）"><a href="#索引数据结构类型（Index-Type）" class="headerlink" title="索引数据结构类型（Index Type）"></a>索引数据结构类型（Index Type）</h3><p>前面说到，不同存储引擎的索引的工作方式并不一样，这是因为存储引擎底层使用的数据结构及算法不一样。在 MySQL 中，某些存储引擎允许在创建索引时指定索引的数据结构类型，下表是常见存储引擎支持的索引的数据结构类型：</p><table><thead><tr><th>存储引擎</th><th>允许的数据结构类型</th></tr></thead><tbody><tr><td>InnoDB</td><td>BTREE（聚集索引实现：数据文件本身就是索引文件）</td></tr><tr><td>MyISAM</td><td>BTREE（非聚集实现：通过索引文件定位数据文件）</td></tr><tr><td>Memory</td><td>HASH（默认）, BTREE</td></tr></tbody></table><blockquote><p>需要注意的是，用户不能为全文索引和空间索引指定数据结构类型：全文索引的实现取决于存储引擎，而空间索引被实现为 RTREE 数据结构。 </p></blockquote><h4 id="MyISAM-索引实现"><a href="#MyISAM-索引实现" class="headerlink" title="MyISAM 索引实现"></a>MyISAM 索引实现</h4><p>MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址。下图是 MyISAM 索引的原理图：</p><p><img src="https://segmentfault.com/img/bVbaFIR?w=752&amp;h=565" alt="图片描述"></p><p>这里设表一共有三列，假设我们以 Col1 为主键，则上图是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是<strong>主索引要求 key 是唯一的</strong>，而<strong>辅助索引的 key 可以重复</strong>。如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示：</p><p><img src="https://segmentfault.com/img/bVbaFLU?w=744&amp;h=563" alt="图片描述"></p><p>同样也是一颗 B+Tree，data 域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。</p><blockquote><p>MyISAM 的索引方式也叫做“非聚集”的，之所以这么称呼是为了与 InnoDB 的聚集索引区分。</p></blockquote><h4 id="InnoDB-索引实现"><a href="#InnoDB-索引实现" class="headerlink" title="InnoDB 索引实现"></a>InnoDB 索引实现</h4><p>虽然 InnoDB 也使用 B+Tree 作为索引结构，但具体实现方式却与 MyISAM 截然不同。</p><p>第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道，MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。<strong>这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。</strong></p><p><img src="https://segmentfault.com/img/bVbaFJ5?w=616&amp;h=275" alt="图片描述"></p><p>上图是 InnoDB 主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集，所以 <strong>InnoDB 要求表必须有主键（MyISAM 可以没有）</strong>，如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话说，<strong>InnoDB 的所有辅助索引都引用主键作为 data 域</strong>。例如，下图为定义在 Col3 上的一个辅助索引：</p><p><img src="https://segmentfault.com/img/bVbaFL1?w=615&amp;h=254" alt="图片描述"></p><p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：<strong>首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</strong></p><h1 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h1><p>Mysql索引查询语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM table_name</span><br></pre></td></tr></table></figure><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>Mysql建表语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name</span><br><span class="line">    [index_type]</span><br><span class="line">    ON tbl_name (index_col_name,...)</span><br><span class="line">    [index_option]</span><br><span class="line">    [algorithm_option | lock_option] ...</span><br><span class="line"></span><br><span class="line"># 下面是创建说明</span><br><span class="line">index_col_name:</span><br><span class="line">    col_name [(length)] [ASC | DESC]</span><br><span class="line"></span><br><span class="line">index_option:</span><br><span class="line">    KEY_BLOCK_SIZE [=] value</span><br><span class="line">  | index_type</span><br><span class="line">  | WITH PARSER parser_name</span><br><span class="line">  | COMMENT &apos;string&apos;</span><br><span class="line">  | &#123;VISIBLE | INVISIBLE&#125;</span><br><span class="line"></span><br><span class="line">index_type:</span><br><span class="line">    USING &#123;BTREE | HASH&#125;</span><br><span class="line"></span><br><span class="line">algorithm_option:</span><br><span class="line">    ALGORITHM [=] &#123;DEFAULT|INPLACE|COPY&#125;</span><br><span class="line"></span><br><span class="line">lock_option:</span><br><span class="line">    LOCK [=] &#123;DEFAULT|NONE|SHARED|EXCLUSIVE&#125;</span><br></pre></td></tr></table></figure><h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name(col_name)</span><br></pre></td></tr></table></figure><h3 id="Alter"><a href="#Alter" class="headerlink" title="Alter"></a>Alter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name (col_name)</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name</span><br></pre></td></tr></table></figure><h3 id="Alter-1"><a href="#Alter-1" class="headerlink" title="Alter"></a>Alter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP INDEX index_name</span><br></pre></td></tr></table></figure><h1 id="索引使用策略"><a href="#索引使用策略" class="headerlink" title="索引使用策略"></a>索引使用策略</h1><h2 id="1-最左前缀原理"><a href="#1-最左前缀原理" class="headerlink" title="1. 最左前缀原理*"></a>1. 最左前缀原理*</h2><p>MySQL 对联合索引的顺序是敏感的。例如我们建立了一个 ( a, b, c, d ) 顺序的索引，假如现在需要执行这样一个 <code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> WHERE 查询语句：</p><ul><li><strong>MySQL 会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止索引的匹配</strong>。因此 d 字段是没有办法使用索引的。</li><li>查询条件用到了索引中列的精确匹配，<strong>但是中间某个条件未提供，此时也是没有办法使用索引的</strong>。</li></ul><p>例如我们有一个 (a,b,c) 顺序的索引，假如现在需要执行一个 <code>a = 1 and c = 2</code> 的 WHERE 查询，因为 b 未提供，所以查询只用到了索引的第一列，而后面的 c 虽然也在索引中，但是由于 b 不存在而无法和左前缀连接，因此 c 字段也是没有办法使用索引的。</p><blockquote><p><strong>有一点需要注意，在精确匹配（<code>=</code> 和 <code>IN</code>）中索引的顺序可以是任意的</strong>，MySQL 的查询优化器会帮用户优化成索引可以识别的形式。比如对于 (a,b,c) 顺序的索引来说，<code>a = 1 and b = 2 and c = 3</code> 和 <code>a = 1 and c = 3 and b = 2</code>、<code>c = 3 and a = 1 and b = 2</code> 等 SQL 语句效果都是一样的。 </p><p>前缀匹配是可以用到索引的（<code>like ‘xxx%’</code>）</p></blockquote><h2 id="2-选择区分度高的列作为索引"><a href="#2-选择区分度高的列作为索引" class="headerlink" title="2. 选择区分度高的列作为索引"></a>2. 选择区分度高的列作为索引</h2><p>尽量选择区分度高的列作为索引，区分度的公式是 <code>count(distinct col)/count(*)</code>，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要 join 的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p><h2 id="3-更新非常频繁的字段不适合创建索引"><a href="#3-更新非常频繁的字段不适合创建索引" class="headerlink" title="3. 更新非常频繁的字段不适合创建索引"></a>3. 更新非常频繁的字段不适合创建索引</h2><p>维护索引是需要空间和时间成本的，对于更新非常频繁的字段，例如通过该字段的查询并不是很多，可能几个小时或是更长才会执行一次，但是更新反而比查询更频繁，此时创建索引就失去了意义，反而降低了 MySQL 的性能。</p><h2 id="4-尽量的扩展索引，不要新建索引"><a href="#4-尽量的扩展索引，不要新建索引" class="headerlink" title="4. 尽量的扩展索引，不要新建索引"></a>4. 尽量的扩展索引，不要新建索引</h2><p>尽量的扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加 (a,b) 的索引，那么只需要修改原来的索引即可。</p><h2 id="5-数据量少的表不建立索引"><a href="#5-数据量少的表不建立索引" class="headerlink" title="5. 数据量少的表不建立索引"></a>5. 数据量少的表不建立索引</h2><p><strong>数据量小的表最好不要使用索引</strong>，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果；</p><h1 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h1><ul><li><strong>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</strong></li></ul><p>相比业务，从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p><p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p><p><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/13.png" alt="img"></p><p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p><p><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/14.png" alt="img"></p><p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p><h2 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h2><ol><li><p>创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加</p></li><li><p><strong>索引也需要占空间</strong>，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值</p></li><li><p><strong>当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度</strong></p></li></ol><h1 id="用Explain分析查询"><a href="#用Explain分析查询" class="headerlink" title="用Explain分析查询"></a>用Explain分析查询</h1><h2 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN select * from table_name</span><br></pre></td></tr></table></figure><h2 id="分析字段："><a href="#分析字段：" class="headerlink" title="分析字段："></a>分析字段：</h2><p><img src="https://images2015.cnblogs.com/blog/874710/201612/874710-20161214144949198-761711481.png" alt="img"></p><h2 id="Explain解释"><a href="#Explain解释" class="headerlink" title="Explain解释"></a>Explain解释</h2><p>id：SELECT识别符。这是SELECT的查询序列号,也就是一条语句中，该select是第几次出现。</p><p>select_type：所使用的SELECT查询类型</p><ul><li>SIMPLE： 表示此查询不包含 UNION 查询或子查询</li><li>PRIMARY： 表示此查询是最外层的查询</li><li>SUBQUERY： 子查询中的第一个 SELECT</li><li>UNION： 表示此查询是 UNION 的第二或随后的查询</li><li>DEPENDENT UNION： UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li>UNION RESULT, UNION 的结果</li><li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li><li>DERIVED：衍生，表示导出表的SELECT（FROM子句的子查询）</li></ul><p>table：被查询数据表的名字，按被读取的先后顺序排列</p><p><strong>type</strong>：通过 type 字段，我们判断此次查询是 全表扫描 还是 索引扫描等。</p><ul><li><p>system: 表中只有一条数据， 这个类型是特殊的 const 类型。</p></li><li><p>const: 针对主键或唯一索引的等值查询扫描，最多只返回一行数据。 const 查询速度非常快， 因为它仅仅读取一次即可。例如下面的这个查询，它使用了主键索引，因此 type 就是 const 类型的：explain select * from user_info where id = 2；</p></li><li><p>eq_ref: 此类型通常出现在多表的 join 查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果。并且查询的比较操作通常是 =，查询效率较高。例如：explain select * from user_info, order_info where user_info.id = order_info.user_id;</p></li><li><p>ref: 此类型通常出现在多表的 join 查询，针对于非唯一或非主键索引，或者是使用了 最左前缀 规则索引的查询。例如下面这个例子中， 就使用到了 ref 类型的查询：explain select * from user_info, order_info where user_info.id = order_info.user_id AND order_info.user_id = 5</p></li><li><p>range: 表示使用索引范围查询，通过索引字段范围获取表中部分数据记录。这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中。例如下面的例子就是一个范围查询：explain select * from user_info  where id between 2 and 8；</p></li><li><p>index: 表示全索引扫描(full index scan)，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型则仅仅扫描所有的索引， 而不扫描数据。index 类型通常出现在：所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据。当是这种情况时，Extra 字段 会显示 Using index。</p></li><li><p>ALL: 表示全表扫描，这个类型的查询是性能最差的查询之一。通常来说， 我们的查询不应该出现 ALL 类型的查询，因为这样的查询在数据量大的情况下，对数据库的性能是巨大的灾难。 如一个查询是 ALL 类型查询， 那么一般来说可以对相应的字段添加索引来避免。</p><p>通常来说, 不同的 type 类型的性能关系如下: </p><p><strong>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</strong></p><p>ALL 类型因为是全表扫描， 因此在相同的查询条件下，它是速度最慢的。而 index 类型的查询虽然不是全表扫描，但是它扫描了所有的索引，因此比 ALL 类型的稍快.后面的几种类型都是利用了索引来查询数据，因此可以过滤部分或大部分数据，因此查询效率就比较高了。 </p></li></ul><p><strong>possible_keys</strong>：MySQL在搜索数据记录时可以选用的各个索引</p><p><strong>key</strong>：实际选用的索引</p><p><strong>key_len</strong>：表示查询优化器使用了索引的字节数（也就是使用的索引个数），这个字段可以评估组合索引是否完全被使用。</p><p>ref：这个表示显示索引的哪一列被使用了 。也可能是const常量。</p><p><strong>rows</strong>：MySQL在估算本次sql要查找到结果集需要扫描读取的数据行数 。原则上越少越好</p><p>extra：提供了与关联操作有关的信息，没有则什么都不写。　　　</p><p>以上内容来自网络，参考文章：</p><ul><li><a href="https://segmentfault.com/a/1190000014906118" target="_blank" rel="noopener">Mysql索引</a></li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">Mysql索引背后的数据结构及算法原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;索引分为主键 Primary Key、普通索引 Index、唯一索引 Unique、全文索引 FullText、空间索引 Spatial &lt;/li&gt;
&lt;li&gt;Mysql的存储引擎分为InnoDB、MyISAM、Memory&lt;/li&gt;
&lt;li&gt;其中InnoDB和MyISAM普遍使用B+Tree实现索引，但是InnoDB的索引结构就是数据文件本身，MyISAM的索引文件与数据分离&lt;/li&gt;
&lt;li&gt;索引的最左匹配原则和索引使用策略   🖊&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://uncleaaron.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="https://uncleaaron.github.io/Blog/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>java类加载-简单总结</title>
    <link href="https://uncleaaron.github.io/Blog/Java/java%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>https://uncleaaron.github.io/Blog/Java/java类加载-简单总结/</id>
    <published>2018-08-02T11:07:20.000Z</published>
    <updated>2018-08-02T12:21:48.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>这几天简单阅读了《深入理解Java虚拟机》的类加载章节，简单总结了一些内容，类加载器的部分之后会补充🖊 </p></blockquote><a id="more"></a><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p><strong>加载→验证→准备→解析→初始化===&gt;使用===&gt;卸载</strong></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>（不要和类加载搞混）加载阶段虚拟机所完成的3件事</p><ol><li>通过类名定义此类的二进制字节流</li><li>将静态结构存储结构转化进方法区的运行时数据结构</li><li>生成java.lang.Class对象，存入方法区，作为该类入口</li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>通过验证确保Class文件的字节流包含的信息符合当前虚拟机的要求，确保其不会威胁虚拟机自身</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>正式为类分配方法区内存空间（不是指对象），并设置类变量初始值(0值)。（这里仅仅分配static类变量，实例变量在实例对象时加入堆）</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>将常量池的符号引用替换为直接引用</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>这是类加载的最后一步，这个阶段才真正开始执行代码，执行类构造器<code>&lt;clinit&gt; ()</code>（由所有类变量赋值操作和静态语句块合并成）。</p><ul><li>类构造器的合并是按语句出现顺序排序的，静态语句块只能<strong>访问</strong>到定义在静态语句块之前的变量。（定义在其之后的变量只能赋值不能访问）如下所示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;<span class="comment">// 可以给变量赋值</span></span><br><span class="line">        System.out.println(i);<span class="comment">// 这是错误的，不可以访问定义在static语句块之后的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父类的类构造器一定会先执行完毕于子类的类构造器（也意味着其静态语句块先于子类的变量赋值操作）</li><li>接口没有静态语句块，但还有变量初始化的赋值操作，也会生成\&lt;client>()方法，但其不需要先执行父接口的类构造器（因为接口只有真正引用到了父接口时，父接口才会初始化)</li></ul><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>类中有且仅有4种主动引用情况执行类初始化，其他情况（被动引用）都不会初始化类</p><ol><li>遇到<strong>new、getstatic、putstatic、invokestatic</strong>这4个字节码指令<ul><li>new：使用new关键字实例化对象。</li><li>getstatic：读引用一个类的静态字段。(已经在编译期把结果放入常量池的final静态字段除外)</li><li>putstatic：写引用一个类的静态字段。(已经在编译期把结果放入常量池的final静态字段除外)</li><li>invokestatic：调用一个类的静态方法。(已经在编译期把结果放入常量池的final静态常量除外)</li></ul></li><li><strong>初始化类时，若父类也未初始化，先初始化父类</strong><ul><li><strong>接口初始化：只有真正引用到了父接口时，才会初始化。</strong></li></ul></li><li><strong>反射</strong>调用类</li><li>虚拟机<strong>启动</strong>时会先初始化包含<strong>main</strong>()方法的类</li></ol><p>演示几个不会触发类初始化的被动引用示例：</p><p>下面有三个示例</p><ul><li>通过类引用final静态常量，因为final静态常量已经在编译期进入常量池，本质上不会调用到类，不触发初始化</li><li><strong>通过子类引用父类的静态字段，不会导致子类初始化</strong></li><li>数组声明不触发初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"SuperClass init."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用value时，会初始化这个SuperClass类（这里的不是常量）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 引用Final_Value时，不会初始化SuperClass</span></span><br><span class="line">    <span class="comment">//    因为static final变量在编译期就已经放到了常量池里，本质上没直接引用到定义常量的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Final_Value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SonClass init."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 引用类的Final_Value时，不会触发初始化</span></span><br><span class="line">    <span class="comment">//    因为static final变量在编译期就已经放到了常量池里，本质上没直接引用到定义常量的类</span></span><br><span class="line">        System.out.println(SuperClass.Final_Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 通过子类引用父类的静态字段，不会导致子类的初始化！</span></span><br><span class="line">        System.out.println(SonClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 通过数组定义类，很明显不会触发初始化过程</span></span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这几天简单阅读了《深入理解Java虚拟机》的类加载章节，简单总结了一些内容，类加载器的部分之后会补充🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2.0 Cache自定义key/value序列化</title>
    <link href="https://uncleaaron.github.io/Blog/JavaWeb/Cache%E8%87%AA%E5%AE%9A%E4%B9%89key-value%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://uncleaaron.github.io/Blog/JavaWeb/Cache自定义key-value序列化/</id>
    <published>2018-08-01T13:06:58.000Z</published>
    <updated>2018-08-01T13:15:05.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Sping Boot2.0.3变化太多了，今天写redis缓存配置的时候又发现了RedisCacheManage的配置又相比SpringBoot 1.5变化了很多，再这再备注一下🖊 </p></blockquote><a id="more"></a><h1 id="SpringBoot2-0-Cache自定义key-value序列化"><a href="#SpringBoot2-0-Cache自定义key-value序列化" class="headerlink" title="SpringBoot2.0 Cache自定义key/value序列化"></a>SpringBoot2.0 Cache自定义key/value序列化</h1><h3 id="1、pom依赖"><a href="#1、pom依赖" class="headerlink" title="1、pom依赖"></a>1、pom依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2、配置yml"><a href="#2、配置yml" class="headerlink" title="2、配置yml"></a>2、配置yml</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cache:</span><br><span class="line">    redis:</span><br><span class="line">      use-key-prefix: <span class="keyword">true</span></span><br><span class="line">      time-to-live: <span class="number">1</span>d</span><br><span class="line">  redis:</span><br><span class="line">    port: <span class="number">6379</span></span><br><span class="line">    host: ip</span><br><span class="line">    password: pwd</span><br><span class="line">    database: <span class="number">0</span></span><br><span class="line">    timeout: <span class="number">1</span>s</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: <span class="number">8</span></span><br><span class="line">        max-idle: <span class="number">50</span></span><br><span class="line">        min-idle: <span class="number">0</span></span><br><span class="line">        max-wait: -<span class="number">1</span>ms</span><br></pre></td></tr></table></figure><h3 id="3、自定义CacheConfiguration-类"><a href="#3、自定义CacheConfiguration-类" class="headerlink" title="3、自定义CacheConfiguration 类"></a>3、自定义CacheConfiguration 类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j2;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.cache.redis"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Duration timeToLive = Duration.ZERO;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeToLive</span><span class="params">(Duration timeToLive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeToLive = timeToLive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(<span class="keyword">this</span>.timeToLive)</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(keySerializer()))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer()))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line"></span><br><span class="line">        RedisCacheManager redisCacheManager = RedisCacheManager.builder(connectionFactory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .transactionAware()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"自定义RedisCacheManager加载完成"</span>);</span><br><span class="line">        <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String,Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        redisTemplate.setKeySerializer(keySerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(keySerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(valueSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(valueSerializer());</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"自定义RedisTemplate加载完成"</span>);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedisSerializer&lt;String&gt; <span class="title">keySerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedisSerializer&lt;Object&gt; <span class="title">valueSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Sping Boot2.0.3变化太多了，今天写redis缓存配置的时候又发现了RedisCacheManage的配置又相比SpringBoot 1.5变化了很多，再这再备注一下🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java 开发问题总结" scheme="https://uncleaaron.github.io/Blog/tags/Java-%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
      <category term="SpringBoot" scheme="https://uncleaaron.github.io/Blog/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>第6章 Java并发容器和框架</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC6%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java并发编程艺术/第6章-Java并发容器和框架/</id>
    <published>2018-07-25T11:55:32.000Z</published>
    <updated>2018-07-26T12:47:29.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="default1" scheme="https://uncleaaron.github.io/Blog/tags/default1/"/>
    
      <category term="default2" scheme="https://uncleaaron.github.io/Blog/tags/default2/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾收集GC和内存分配策略</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86GC%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java垃圾收集GC和内存分配策略/</id>
    <published>2018-07-23T12:17:47.000Z</published>
    <updated>2018-07-23T12:19:31.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域划分以及内存溢出异常</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java内存区域划分以及内存溢出异常/</id>
    <published>2018-07-21T11:54:55.000Z</published>
    <updated>2018-07-23T12:15:41.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Java虚拟机的内存区域主要分为：程序计数器，虚拟机栈，本地方法栈，Java堆，方法区🖊 </p><p>其中，<strong>栈</strong>描述<strong>方法</strong>执行，及方法的<em>局部变量和引用</em>；<strong>堆</strong>描述<strong>对象</strong>；<strong>方法区</strong>描述<strong>类</strong>和常量</p><p>其中，栈结构线程私有，堆结构线程共享（方法区描述类，也是堆结构）</p></blockquote><a id="more"></a><h1 id="Java虚拟机运行时数据区域"><a href="#Java虚拟机运行时数据区域" class="headerlink" title="Java虚拟机运行时数据区域"></a>Java虚拟机运行时数据区域</h1><p><img src="/Blog/Java/Java内存区域划分以及内存溢出异常/Java虚拟机运行时数据区.png" alt="Java虚拟机运行时数据区"></p><blockquote><p>上图理解：</p><p><strong>堆</strong>结构线程共享，描述所有的对象（类在方法区中，方法区也是堆）；</p><p><strong>栈</strong>和计数器线程私有，描述方法执行</p></blockquote><p>Java虚拟机在运行时会把它所管理的内存划分为若干个不同的数据区域。大致分为以下：</p><ol><li><p><strong>程序计数器</strong>：在Java中，每个线程都有一个独立的程序计数器，独立存储，该段内存是线程私有的</p></li><li><p><strong>Java虚拟机栈：</strong>描述<strong>方法执行</strong>的内存模型：</p><ul><li><p>每个方法在执行的同时会创建<strong>栈帧</strong>用于存储<strong>局部变量表</strong>、动态链接等信息。</p></li><li><p>其中，局部变量表存放基本类型、对象引用、returnAddress类型。其内存空间大小分配在编译期间就可以完全确定，之后也不会改变。</p></li><li>线程私有的，生命周期与线程相同。</li><li>当线程请求的栈深度大于虚拟机允许的深度，抛出StackOverFlowError异常</li><li>可动态扩展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li><li><p><strong>本地方法栈</strong>：描述<strong>Native方法</strong>的内存模型，其他与虚拟机栈一样。</p></li><li><p><strong>Java堆</strong>：<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。</p><ul><li>被<strong>所有线程共享</strong>这一块内存区域，是Java虚拟机所管理的最大一块内存</li><li>堆是<strong>GC垃圾收集器管理</strong>的主要区域（在普遍使用的分代手机算法中，堆可分为：新生代和老年代）</li><li>对线程来说，还划分出多个线程私有的<strong>本地线程分配缓冲区（TLAB）</strong></li><li>以上无论如何划分，堆存放的都是对象实例，划分只是为了更好地回收和分配内存</li><li>可动态扩展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li><li><p><strong>方法区</strong>：<strong>存储Class</strong>文件的相关信息：已被加载的<strong>类信息</strong>、<strong>常量</strong>、（类变量）静态变量、编译后的代码等</p><ul><li>所有线程共享</li><li><strong>运行时常量池</strong>：Class文件的常量池的信息，在类加载后进入方法区的运行时常量池<ul><li>Java不要求常量一定要编译时产生，可以运行期间产生放入方法区常量池，例如String.intern()</li><li>（此外Class文件中还有类版本、字段、方法、接口等描述信息）</li></ul></li><li>这部分的GC较少，在此区域GC主要为了针对常量池回收和类型卸载。</li><li>其实它也是堆结构，但是要与Java堆区分，称为“Non-Heap”非堆</li><li>可动态拓展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li><li><p><strong>直接内存</strong>：</p><ul><li>可动态拓展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li></ol><h1 id="OutOfMemoryError异常-内存溢出"><a href="#OutOfMemoryError异常-内存溢出" class="headerlink" title="OutOfMemoryError异常(内存溢出)"></a>OutOfMemoryError异常(内存溢出)</h1><p>申请的内存空间超过了系统实际分配的空间<strong>（系统无法满足内存申请）</strong> ，就会发生OutOfMemory异常（以下简称OOM）</p><p>除了程序计数器外，其他几个运行时区域都有可能发生OOM异常</p><h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>堆用于存储对象实例，只要不断创建对象，并且保证GC Roots到对象之间有可达路径以避免对象被垃圾回收，那么对象数量在到达堆最大容量限制是抛出内存溢出OOM异常。</p><p>分清楚是内存泄漏还是内存溢出</p><p><strong>内存泄漏：</strong>申请内存后，无法释放已申请的内存空间 。</p><blockquote><p>比如，你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。 </p></blockquote><p><strong>内存溢出：</strong>申请内存时，没有足够的内存供申请者使用。</p><blockquote><p>比如：给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，内存不够用，就会报OOM，此时内存溢出。</p><p>又比如：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。   </p></blockquote><h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>（HotSpot虚拟机不区分这两个栈）</p><p><strong>StackOverFlow</strong>Error：线程请求的栈深度大于虚拟机允许的深度</p><p><strong>OutOfMemory</strong>Error：扩展栈时无法申请到足够的内存</p><p>单线程测试下，无论是栈容量少，还是栈帧太大，都抛出了StackOverFlow异常</p><p>而在多线程下，通过不断建立内存用量大的线程，迅速耗尽内存空间，会抛出OOM</p><h2 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h2><p>通过<strong>不断产生动态类</strong>（如<strong>反射</strong>和<strong>动态代理</strong>、<strong>JSP</strong>等<strong>会加载Class</strong>的操作），在运行时产生大量的类去填满方法区，直到溢出，抛出OOM。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java虚拟机的内存区域主要分为：程序计数器，虚拟机栈，本地方法栈，Java堆，方法区🖊 &lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;栈&lt;/strong&gt;描述&lt;strong&gt;方法&lt;/strong&gt;执行，及方法的&lt;em&gt;局部变量和引用&lt;/em&gt;；&lt;strong&gt;堆&lt;/strong&gt;描述&lt;strong&gt;对象&lt;/strong&gt;；&lt;strong&gt;方法区&lt;/strong&gt;描述&lt;strong&gt;类&lt;/strong&gt;和常量&lt;/p&gt;
&lt;p&gt;其中，栈结构线程私有，堆结构线程共享（方法区描述类，也是堆结构）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java对象创建、内部数据、如何访问(HotSpot虚拟机下）</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%AF%B9%E8%B1%A1-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java对象-HotSpot虚拟机下/</id>
    <published>2018-07-21T11:54:55.000Z</published>
    <updated>2018-07-23T11:44:44.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>对象创建</strong>：查找类型，确认类加载，分配内存，初始化内存，设置对象，init🖊</p><p><strong>对象构造</strong>：对象头（Markword，类型指针），实例数据</p><p><strong>对象访问定位</strong>：从栈上的引用访问到对象，需要查找到堆中的对象，然后通过对象中的类型指针找到其类型 </p></blockquote><a id="more"></a><h1 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h1><p>这里讲的是普通的Java对象，不包括数组或Class对象</p><ol><li>虚拟机遇到new指令时，<strong>检查指令参数是否能在常量池中定位到这个类的符号引用</strong></li><li>检查这个符号引用代表的类<strong>是否已经被加载、解析和初始化</strong>过</li><li>若未加载，<strong>执行相应的类加载</strong>过程</li><li>为新生对象<strong>分配内存</strong>。需要内存大小在编译时就可完全确定。分配方式有几种，“空闲列表”、“指针碰撞”、“CAS+失败重试保证原子性”，“分配TLAB本地线程分配缓冲”</li><li>对<strong>内存空间初始化零值</strong>。这一步保证了对象的实例字段在不赋初始值就可以直接使用，能访问到队形数据类型所对应的零值</li><li>虚拟机对<strong>对象进行设置</strong>。例如是哪个类、对象哈希码、GC分代年龄、是否设置偏向锁等，对对象头Object Header设置。</li><li><strong>执行<code>init</code>方法</strong>，按照程序员意愿初始化对象。这样才算是真正被完全生产出来对象（在这之前对象内都还是零值）</li></ol><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><ul><li>对象头：MarkWord+类型指针<ul><li>MarkWord：对象自身运行时的设置数据：哈希码HashCode，GC分代年龄，锁状态，持有锁，偏向线程ID等</li><li>类型指针：指向类元数据，虚拟机通过这个指针确定对象的类型</li></ul></li><li>实例数据：包括对象定义的数据，而且还包括从父类继承的、子类定义的数据</li><li>对齐填充：补位的无意义填充</li></ul><h1 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h1><p>Java程序是如何通过引用定位到对象实例数据和类型数据的？</p><p>虚拟机有两钟可实现的方式：</p><ul><li>句柄方式：Java堆中划分出一个句柄池，其中每个句柄存放对象实例数据和类型数据各自的地址信息。特点是稳定，对象被移动只改变句柄不改变reference。</li><li>直接指针：Java堆的对象还存放一个类型的指针。速度更快，节省了1次指针定位的时间开销。（这正是HotSpot虚拟机的实现方式）</li></ul><p><img src="/Blog/Java/Java对象-HotSpot虚拟机下/通过句柄访问对象.png" alt="通过句柄访问对象"></p><p><img src="/Blog/Java/Java对象-HotSpot虚拟机下/通过类型指针访问对象.png" alt="通过类型指针访问对象"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;对象创建&lt;/strong&gt;：查找类型，确认类加载，分配内存，初始化内存，设置对象，init🖊&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象构造&lt;/strong&gt;：对象头（Markword，类型指针），实例数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象访问定位&lt;/strong&gt;：从栈上的引用访问到对象，需要查找到堆中的对象，然后通过对象中的类型指针找到其类型 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库规范及解读</title>
    <link href="https://uncleaaron.github.io/Blog/DataBase/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8F%8A%E8%A7%A3%E8%AF%BB/"/>
    <id>https://uncleaaron.github.io/Blog/DataBase/MySQL数据库规范及解读/</id>
    <published>2018-07-19T07:16:08.000Z</published>
    <updated>2018-07-19T08:36:24.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>使用Mysql的准则 🖊 </p></blockquote><a id="more"></a><h2 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h2><blockquote><p>第一条：必须使用InnoDB存储引擎</p></blockquote><p>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</p><blockquote><p>第二条：必须使用utf8(utf8mb4)字符集</p></blockquote><p>解读：万国码，无需转码，无乱码风险，节省空间，utf8mb4是utf8的超集，由于近年移动设备的增多，emoji表情以及部分不常见汉字在utf8下会表现为乱码，故需要升级至utf8mb4</p><blockquote><p>第三条：数据表、数据字段必须加入中文注释</p></blockquote><p>解读：N年后谁会知道这个a1,a2,a3字段是干嘛的</p><blockquote><p>第四条：禁止使用存储过程、视图、触发器、Event</p></blockquote><p>解读：高并发<strong>大数据</strong>的互联网业务，<strong>架构</strong>设计思路是<em>“解放<strong>数据库</strong>CPU，将计算转移到服务层“</em>，并发量大的情况下，这些功能很可能将数据库拖死，<em>业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”</em>。数据库擅长存储与索引，CPU计算还是上移吧</p><blockquote><p>第五条：禁止存储大文件或者大照片</p></blockquote><p>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI多好</p><h2 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h2><blockquote><p>第一条：只允许<em>使用内网域名，而不是ip连接数据库</em></p></blockquote><p>解读：虽然IP访问更快，域名访问需要内网dns，但是对于大数据库的扩展和迁库考虑，域名更好</p><blockquote><p>第二条：线上环境、开发环境、<strong>测试</strong>环境数据库内网域名遵循命名规范</p></blockquote><p>业务名称：xxx<br>线上环境：dj.xxx.db<br>开发环境：dj.xxx.rdb<br>测试环境：dj.xxx.tdb<br>从库在名称后加-s标识，备库在名称后加-ss标识<br>线上从库：dj.xxx-s.db<br>线上备库：dj.xxx-sss.db</p><blockquote><p>第三条：库名、表名、字段名：小写，下划线风格，不超过32个字符，禁止拼音英文混用</p></blockquote><p>解读：见名知意，方便后续维护</p><blockquote><p>第四条：表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</p></blockquote><p>解读：见名知意，方便后续维护</p><h2 id="三、表和字段设计规范"><a href="#三、表和字段设计规范" class="headerlink" title="三、表和字段设计规范"></a>三、表和字段设计规范</h2><blockquote><p>第一条：禁止使用外键，如果有外键完整性约束，需要应用程序控制</p></blockquote><p>解读：<em>外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql的性能</em>，甚至会造成死锁。高并发情况下容易造成数据库性能，<em>大数据高并发业务场景数据库使用以性能优先</em></p><blockquote><p>第二条：必须把字段定义为NOT NULL并且提供默认值</p></blockquote><p>解读：<br>a) null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化<br>b) null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多<br>c) null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标识<br>d) 对null的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。<em>如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录</em></p><blockquote><p>第三条：禁止使用TEXT、BLOB类型</p></blockquote><p>解读：会浪费更多的磁盘和内存空间，<em>非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能</em></p><blockquote><p>第四条：禁止使用小数存储国币</p></blockquote><p>解读：曾经踩过这样的坑，100元分3天摊销，每天摊销(100/3)元，结果得到3个33.33。后来实施对账系统，始终有几分钱对不齐，郁闷了很久（不是几分钱的事，是业务方质疑的眼神让研发很不爽），最后发现是除法惹的祸<br>解决方案：使用“分”作为单位，这样数据库里就是整数了</p><blockquote><p>第五条：必须使用varchar(20)存储手机号</p></blockquote><p>解读：<br>a) 涉及到区号或者国家代号，可能出现+-()<br>b) 手机号会去做数学运算么？<br>c) varchar可以支持模糊查询，例如：like“138%”</p><blockquote><p>第六条：禁止使用ENUM，可使用TINYINT代替</p></blockquote><p>解读：<br>a) 增加新的ENUM值要做DDL操作<br>b) ENUM的内部实际存储就是整数，你以为自己定义的是字符串？</p><blockquote><p>第七条：表必须有主键，例如自增主键</p></blockquote><p>解读：<br>a) 主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用<br>b) 主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率<br>c) 无主键的表删除，在row模式的主从架构，会导致备库夯住</p><h2 id="四、索引设计规范"><a href="#四、索引设计规范" class="headerlink" title="四、索引设计规范"></a>四、索引设计规范</h2><blockquote><p>第一条：单表索引建议控制在5个以内</p></blockquote><p>解读：一个好的索引设计，可以让你的效率提高几十甚至几百倍，但过多反而适得其反</p><blockquote><p>第二条：单索引字段数不允许超过5个</p></blockquote><p>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了</p><blockquote><p>第三条：禁止在更新十分频繁、区分度不高的属性上建立索引</p></blockquote><p>解读：<br>a) 更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能<br>b) “性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似</p><blockquote><p>第四条:建立组合索引，必须把区分度高的字段放在前面</p></blockquote><p>解读：能够更加有效的过滤数据</p><h2 id="五、SQL使用规范"><a href="#五、SQL使用规范" class="headerlink" title="五、SQL使用规范"></a>五、SQL使用规范</h2><blockquote><p>第一条：禁止使用SELECT *，只获取必要的字段，需要显示说明列属性</p></blockquote><p>解读：<br>a) 读取不需要的列会增加CPU、IO、NET消耗<br>b) 不能有效的利用覆盖索引<br>c) 使用<code>SELECT *</code>容易在增加或者删除字段后出现程序BUG</p><blockquote><p>第二条：禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性</p></blockquote><p>解读：容易在增加或者删除字段后出现程序BUG</p><blockquote><p>第三条：禁止使用属性隐式转换</p></blockquote><p>解读：SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中phone索引，猜猜为什么？<br>int数据类型优先级高于varcher， 该查询会把phone转换为int，因此需要把表中所有数据改成int，所以必须全盘扫描<br>phone是varchar类型，SQL语句带入的是整形，故不会命中索引，加个引号就好了：<br>SELECT uid FROM t_user WHERE phone=’13812345678’</p><blockquote><p>第四条：禁止在WHERE条件的属性上使用函数或者表达式</p></blockquote><p>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描<br>正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</p><blockquote><p>第五条：禁止大表使用JOIN查询，禁止大表使用子查询</p></blockquote><p>解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能，大表指的是数据量在1000万以上的表</p><blockquote><p>第六条：禁止使用OR条件，必须改为IN查询</p></blockquote><p>解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？</p><blockquote><p>第七条：禁止使用负向查询，以及%开头的模糊查询</p></blockquote><p>解读：<br>a) 负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描<br>b) %开头的模糊查询，会导致全表扫描<br>一般来说，WHERE过滤条件不会只带这么一个“负向查询条件”，还会有其他过滤条件，举个例子：查询沈剑已完成订单之外的订单（好拗口）：<br>SELECT oid FROM t_order WHERE uid=123 AND status != 1;<br>订单表5000w数据，但uid=123就会迅速的将数据量过滤到很少的级别（uid建立了索引），此时再接上一个负向的查询条件就无所谓了，扫描的行数本身就会很少<br>但如果要查询所有已完成订单之外的订单：<br>SELECT oid FROM t_order WHERE status != 1;<br>这就挂了，立马CPU100%，status索引会失效，负向查询导致全表扫描</p><blockquote><p>第八条：应用程序必须捕获SQL异常，并有相应处理</p></blockquote><p>解读：方便维护，及时“查漏补缺”</p><p><strong>总结：大数据量高并发的互联网业务，极大影响数据库性能的都不让用，不让用哟。</strong></p><p>转自：<a href="https://zhuanlan.zhihu.com/p/32586602" target="_blank" rel="noopener">知乎：SangSir</a>的文章</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用Mysql的准则 🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>领域模型中的实体类的4种类型VO,DTO,DO,PO</title>
    <link href="https://uncleaaron.github.io/Blog/Java/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%9A%844%E7%A7%8D%E7%B1%BB%E5%9E%8BVO-DTO-DO-PO/"/>
    <id>https://uncleaaron.github.io/Blog/Java/领域模型中的实体类的4种类型VO-DTO-DO-PO/</id>
    <published>2018-07-19T07:14:08.000Z</published>
    <updated>2018-07-21T16:58:40.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>经常会接触到VO，DO，DTO的概念，本文从领域建模中的实体划分和项目中的实际应用情况两个角度，对这几个概念进行简析 🖊 </p></blockquote><a id="more"></a><p>在项目应用中，VO对应于页面上需要显示的数据（表单），DO对应于数据库中存储的数据（数据表），DTO对应于除二者之外需要进行传递的数据。 </p><p>领域模型中的实体类分为四种类型：VO、DTO、DO、PO，各种实体类用于不同业务层次间的交互，并会在层次内实现实体类之间的转化。</p><p>业务分层为：视图层（VIEW+ACTION），服务层（SERVICE），持久层（DAO） </p><p>相应各层间实体的传递如下图：  </p><p> <img src="/Blog/Java/领域模型中的实体类的4种类型VO-DTO-DO-PO/领域模型.jpg" alt="领域模型"></p><p>项目中我们并没有严格遵循这种传递关系，但这种和业务层次的关联对我们理解各实体类的作用是有帮助的。（我们没有接触到PO的原因，我理解为ORM对PO进行了封装） </p><p>概念：</p><ul><li><strong>VO（View Object）</strong>：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</li><li><strong>DTO（Data Transfer Object）</strong>：数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。</li><li><strong>DO（Domain Object）</strong>：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</li><li><strong>PO（PersistentObject）</strong>：持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。 </li></ul><p>模型：</p><p> 下面以一个时序图建立简单模型来描述上述对象在三层架构应用中的位置 </p><ul><li><p>用户发出请求（可能是填写表单），表单的数据在展示层被匹配为VO。</p></li><li><p>展示层把VO转换为服务层对应方法所要求的DTO，传送给服务层。 l 服务层首先根据DTO的数据构造（或重建）一个DO，调用DO的业务方法完成具体业务。 </p></li><li>服务层把DO转换为持久层对应的PO（可以使用ORM工具，也可以不用），调用持久层的持久化方法，把PO传递给它，完成持久化操作。</li><li><p>对于一个逆向操作，如读取数据，也是用类似的方式转换和传递，略。</p><p>三、项目中的实体类</p></li></ul><p>项目中常见的实体类有VO，DO和DTO，命名规则也常是以相应字符串结尾，如VO.Java。</p><p>但是DTO不总是遵循这个规则，而通常与他的用途有关，如写成Query.java，表示存储了一个查询条件。</p><p>项目中实体类出现的业务层次也没有这么严格，例如我们可以在视图层就组装一个DO，也可以将一个VO从持久层传出来，所以与业务分层相关联的划分方法显得有些冗余。</p><p>从项目代码中抽象出的理解是：VO对应于页面上需要显示的数据，DO对应于数据库中存储的数据，DTO对应于除二者之外需要进行传递的数据。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;经常会接触到VO，DO，DTO的概念，本文从领域建模中的实体划分和项目中的实际应用情况两个角度，对这几个概念进行简析 🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>WebMvcConfigurerAdapter在Spring5.0中被弃用</title>
    <link href="https://uncleaaron.github.io/Blog/JavaWeb/WebMvcConfigurerAdaptor%E5%9C%A8Spring5.0%E8%A2%AB%E5%BC%83%E7%94%A8/"/>
    <id>https://uncleaaron.github.io/Blog/JavaWeb/WebMvcConfigurerAdaptor在Spring5.0被弃用/</id>
    <published>2018-07-17T12:41:09.000Z</published>
    <updated>2018-07-27T14:59:34.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>今天用Sping Boot2.0.3写项目编写WebMvc的JavaConfig时，发现WebMvcConfigurerAdapter已经被标注弃用，便去找了下Spring的API，发现官方开始推荐<strong>直接实现WebMvcConfigurer接口</strong>的方式来配置SpringMVC。（原因在Java8接口默认方法替代了原来适配器的作用）🖊 </p></blockquote><a id="more"></a><h2 id="在SpringBoot2-0及Spring-5-0-WebMvcConfigurerAdapter已被废弃，目前找到解决方案就有两种"><a href="#在SpringBoot2-0及Spring-5-0-WebMvcConfigurerAdapter已被废弃，目前找到解决方案就有两种" class="headerlink" title="在SpringBoot2.0及Spring 5.0 WebMvcConfigurerAdapter已被废弃，目前找到解决方案就有两种"></a>在SpringBoot2.0及Spring 5.0 WebMvcConfigurerAdapter已被废弃，目前找到解决方案就有两种</h2><hr><h3 id="1-直接实现WebMvcConfigurer-（官方推荐）"><a href="#1-直接实现WebMvcConfigurer-（官方推荐）" class="headerlink" title="1. 直接实现WebMvcConfigurer （官方推荐）"></a>1. 直接实现WebMvcConfigurer （官方推荐）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfg</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-直接继承WebMvcConfigurationSupport"><a href="#2-直接继承WebMvcConfigurationSupport" class="headerlink" title="2. 直接继承WebMvcConfigurationSupport"></a>2. 直接继承WebMvcConfigurationSupport</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfg</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebMvcConfigurerAdapter的官方api描述"><a href="#WebMvcConfigurerAdapter的官方api描述" class="headerlink" title="WebMvcConfigurerAdapter的官方api描述"></a>WebMvcConfigurerAdapter的官方api描述</h3><p>WebMvcConfigurerAdapter – Deprecated.<br>as of 5.0 WebMvcConfigurer has default methods (made possible by a Java 8 baseline) and can be implemented directly without the need for this adapter.<br>An implementation of WebMvcConfigurer with empty methods allowing subclasses to override only the methods they’re interested in.</p><blockquote><p>Java8中WebMvcConfigurer实现了默认方法，不需要这个适配器了。</p><p>因为WebMvcConfigurer接口实现了默认方法，使用者可以自由实现想配置的方法</p></blockquote><p>解释：</p><p>在Java8以前，因为实现接口的时候每个接口方法必须需要实现，所以导致编写JavaConfig配置类很困难，不能自由选择配置类，所以Spring5.0以前用一个适配器抽象类实现了WebMvcConfigurer的所有方法（但其实都是空的），这样可以满足用户可以选择自己需要的配置功能进行选择性配置，而不需要全部实现。</p><p>而现在Java8提供了接口默认实现方法，接口的默认方法完全替代了这个适配器类的目的，可以满足仅在接口层面用户就能选择自己想实现的方法，没有实现的方法就用默认方法代替，原来的适配器就多余了。因此推荐第一种方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;今天用Sping Boot2.0.3写项目编写WebMvc的JavaConfig时，发现WebMvcConfigurerAdapter已经被标注弃用，便去找了下Spring的API，发现官方开始推荐&lt;strong&gt;直接实现WebMvcConfigurer接口&lt;/strong&gt;的方式来配置SpringMVC。（原因在Java8接口默认方法替代了原来适配器的作用）🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java 开发问题总结" scheme="https://uncleaaron.github.io/Blog/tags/Java-%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
      <category term="Spring" scheme="https://uncleaaron.github.io/Blog/tags/Spring/"/>
    
  </entry>
  
</feed>
