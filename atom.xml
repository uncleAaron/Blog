<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StormAaron的技术站</title>
  
  
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="https://uncleaaron.github.io/Blog/"/>
  <updated>2018-08-06T02:39:57.544Z</updated>
  <id>https://uncleaaron.github.io/Blog/</id>
  
  <author>
    <name>Aaron.H</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础复习</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java基础复习/</id>
    <published>2018-08-04T03:32:47.000Z</published>
    <updated>2018-08-06T02:39:57.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文大致复习了Java的基础内容：数据类型，String，运算，类型转换，OOP的封装，继承，多态，Object方法包括equals，hashCode，clone，还有final、static关键字，反射，异常，泛型，注解，枚举类型</p><p>参考了github-CYC2018的笔记做的总结，在此基础上补充了一点自己需要补充的内容🖊 </p></blockquote><a id="more"></a><h1 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h1><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>八个基本类型：</p><ul><li>boolean / 1</li><li>byte / 8</li><li>char / 8</li><li>short / 16</li><li>int / 32</li><li>float / 32</li><li>long / 64</li><li>double / 64</li></ul><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱和拆箱完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;<span class="comment">// 自动装箱，会调用Integer.valueOf(2)方法，尝试从缓存池获取缓存对象，若已经存在，则取缓存中已存在的Integer值为2的对象（是Integer不是int）</span></span><br><span class="line"><span class="keyword">int</span> y = x;<span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure><h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 区别在于：new Integer(123) 每次都会创建一个新对象，而Integer.valueOf(123) 可能会使用缓存对象，因此多次使用Integer.valueOf(123)会取得同一个对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>valueOf() 方法的实现比较简单，先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p><p>Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><h1 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>String被声明为final，因此不可继承</p><p>内部实现：char数组，数组也是final。意味着value数组初始化之后就不能再引用其他数组。String内部没有改变value数组的方法，保证了String的不可变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><h2 id="String不可变的好处"><a href="#String不可变的好处" class="headerlink" title="String不可变的好处"></a>String不可变的好处</h2><ol><li>可以缓存hash值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，只需要进行一次计算。 </li><li>构成了String Pool常量池：String常量池</li><li>安全性：String经常作为参数，不可变保证了连接传输的安全</li><li>线程安全</li></ol><h2 id="String的编码"><a href="#String的编码" class="headerlink" title="String的编码"></a>String的编码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String value = <span class="keyword">new</span> String(str.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure><h2 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h2><p>String不可变，所以是线程安全的</p><p>StringBuffer非线程安全</p><p>StringBuffer线程安全，内部使用synchronized同步</p><h2 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h2><p>使用 String.intern() 可以保证相同内容的字符串变量引用相同的内存对象。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用，这个方法首先把 s1 引用的对象放到 String Pool（字符串常量池）中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s4 = <span class="string">"bbb"</span>;</span><br><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 Java 7 之前，字符串常量池被放在运行时常量池中，它属于永久代。而在 Java 7，字符串常量池被放在堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h1 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Java参数传递是以值传递，不是引用传递。传进方法的都是值拷贝。传进的值只是拷贝，方法内修改无效，但是修改指针所指的内容是有效的。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>Java不允许隐式向下转型（包括精度损失下降的基本类型的转换也不允许：double→long-&gt;int→short→byte，double→float，float→long都不行）</p><h3 id="隐式向下转换的特例：基本类型的-，-，-，-运算"><a href="#隐式向下转换的特例：基本类型的-，-，-，-运算" class="headerlink" title="隐式向下转换的特例：基本类型的+=，/=，-=，*=运算"></a>隐式向下转换的特例：基本类型的+=，/=，-=，*=运算</h3><p>因为字面量1是int类型，它比short类型精度要高，因此不能隐式将int向下转型为short：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;// 这是错误的，1是int类型，s1 + 1会隐式向上转型为int，不能再赋值给short类型的s1。</span></span><br></pre></td></tr></table></figure><p>但是使用 += 运算符可以执行隐式类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;<span class="comment">// +=，/=等都可以。因为其内部做了显式转换，相当于下面显式转换</span></span><br></pre></td></tr></table></figure><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = (<span class="keyword">short</span>) (s1 + <span class="number">1</span>);<span class="comment">// 显式转换OK</span></span><br></pre></td></tr></table></figure><h3 id="float和double"><a href="#float和double" class="headerlink" title="float和double"></a>float和double</h3><p>double不能隐式转换为float ！</p><p>1.1属于double类型，不能直接将1.1赋值给float变量，因为这是向下转型，Java不能隐式向下转型，因为这会造成精度下降。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1// 注意！错误的转型</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span><span class="comment">// 1.1f字面量才是float类型</span></span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">1</span><span class="comment">// 字面量是整数也是可以的</span></span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>Java7开始，switch语句中可以使用String作为判断条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;<span class="comment">// 声明String</span></span><br><span class="line"><span class="keyword">switch</span> (s) &#123;<span class="comment">// 使用String判断</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:<span class="comment">//true</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 不支持 long，double，float，是因为 switch 的设计初衷是为那些只需要对少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p><p>Switch支持char, byte, short, int, Character, Byte, Short, Integer, String, or an enum</p><h1 id="四、封装、继承、多态"><a href="#四、封装、继承、多态" class="headerlink" title="四、封装、继承、多态"></a>四、封装、继承、多态</h1><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>java的四个访问权限：private、default、protected、public，(其中default不是访问权限修饰符)</p><table><thead><tr><th>权限</th><th>类内</th><th>同包</th><th>不同包子类</th><th>不同包非子类</th><th>备注</th></tr></thead><tbody><tr><td><strong>private</strong></td><td>√</td><td>××</td><td>××</td><td>××</td><td>类私有</td></tr><tr><td>default</td><td>√</td><td>√</td><td>××</td><td>××</td><td>默认，包访问权限</td></tr><tr><td><strong>protected</strong></td><td>√</td><td>√</td><td>√</td><td>××</td><td>保护，包与子类访问权限，修饰成员</td></tr><tr><td><strong>public</strong></td><td>√</td><td>√</td><td>√</td><td>√</td><td>公开</td></tr></tbody></table><p>成员可见：其他类可以用这个类的实例对象访问到该成员</p><p>类可见：其他类可以用这个类创建实例对象</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="子类构造函数的约束"><a href="#子类构造函数的约束" class="headerlink" title="子类构造函数的约束"></a>子类构造函数的约束</h3><p>子父类中的构造函数的特点：　　</p><ol><li><p><strong>在子类的构造函数中第一行有默认隐式的super();</strong></p><p>所以在子类构造对象时，发现，访问子类构造函数时，父类构造函数也运行了。 </p></li><li><p><strong>子类构造函数默认调用的是父类中的空参数构造函数</strong>，<strong>如需调用父类中的含参构造，可以在子类构造函数中定义</strong>super(args)。</p></li><li><p><strong>如果父类中没有定义空参构造，那么子类构造必须用super(args)明确</strong>要调用父类的哪个构造函数。</p></li><li><p>若<strong>子类构造函数使用this()调用了本类构造函数，那么该构造函数的隐藏super()就没有了</strong>，因为super()和this()都只能定义第一行，只能有一个。</p><p><strong>但子类中一定有其他的构造函数会访问到父类的构造函数</strong>。</p></li></ol><p>注意：super()语句必须要定义在子类构造函数的第一行。因为<strong>父类的初始化动作要先完成</strong>。</p><h2 id="重写与重载（多态）"><a href="#重写与重载（多态）" class="headerlink" title="重写与重载（多态）"></a>重写与重载（多态）</h2><h3 id="重写（及重写的返回值类型、访问权限要求）"><a href="#重写（及重写的返回值类型、访问权限要求）" class="headerlink" title="重写（及重写的返回值类型、访问权限要求）"></a>重写（及重写的返回值类型、访问权限要求）</h3><ul><li>重写（Override）存在于继承体系中，指子类实现了一个与父类在<strong>方法声明上完全相同</strong>的一个方法，<ul><li><strong>返回值类型</strong>：<strong>子类小于或等于父类</strong>的返回值类型；</li><li><strong>方法访问级别</strong>：<strong>子类不低于父类</strong>；子类中重写方法的访问级别不允许低于父类的访问级别。这是为了<strong>确保可以使用父类实例的地方都可以使用子类实例</strong>，也就是确保满足里氏替换原则。</li></ul></li></ul><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li>重载（Overload）存在于同一个类中，指一个方法与已经存在的<strong>方法名称相同</strong>，但是<strong>参数类型、个数、顺序至少有一个不同</strong>。应该注意的是，返回值不同，其它都相同不算是重载。</li></ul><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>访问父类的关键字</p><ul><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而完成一些初始化的工作。</li><li>访问父类的成员：如果子类覆盖了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);<span class="comment">// 访问父类构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();<span class="comment">// 访问父类的方法</span></span><br><span class="line">        System.out.println(<span class="string">"SuperExtendExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。 </p><p>如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessWithInnerClassExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;<span class="comment">// 私有内部类，成员可以暴露</span></span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccessWithInnerClassExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerClass.x; <span class="comment">// 直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><strong>抽象类</strong>和<strong>抽象方法</strong>都用<strong><code>abstract</code></strong>声明。抽象方法一定位于抽象类中。</p><p>抽象类<strong>不能被实例化</strong>，需要继承抽象类才能实例化其子类。这是它和普通类最大的区别。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClassExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;<span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;<span class="comment">// 实例方法</span></span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>从Java8开始，<strong>接口可以拥有默认的方法实现，此时用<code>default</code>修饰方法体</strong>（因为不支持默认方法的接口维护成本太高了，在Java8以前，一个接口想添加新的方法，需要修改所有的实现类；有的可能需要用适配器转接默认实现，如Spring的WebMvcConfig接口和WebMvcConfigAdaptor）</p><p>接口的成员（字段和方法）默认都是public的，并且不允许定义为其他访问权限private或protected。</p><p>接口的字段默认都是public static final的常量。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">123</span>; <span class="comment">// public static final 的常量</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;<span class="comment">// public的接口方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;<span class="comment">// 默认方法实现，用default修饰</span></span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类和接口比较"><a href="#抽象类和接口比较" class="headerlink" title="抽象类和接口比较"></a>抽象类和接口比较</h3><ul><li><strong>一个类可以实现多个接口，只能继承最多一个类或者抽象类</strong></li><li>接口的字段只能是public static final的，抽象类没这个限制</li><li>接口的方法只能是public的，抽象类没这个限制</li></ul><p>简单说，抽象类只是比普通类少了点方法实现，其他无太大差别。而接口不一样，必须是公开的。</p><p>抽象类是IS-A关系，子类对象必须能够替换掉父类对象</p><p>接口是Like-A关系，是一种契约，不需要完全实现</p><h3 id="选择抽象类还是接口？"><a href="#选择抽象类还是接口？" class="headerlink" title="选择抽象类还是接口？"></a>选择抽象类还是接口？</h3><p>很多情况下，接口优先与抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且，Java8开始，接口也能有默认方法实现，使得修改接口的成本也变得很低。</p><p><strong>使用接口：</strong></p><p>需要让不相关的类都<strong>实现一个方法</strong>，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法； </p><p>需要使用<strong>多继承</strong></p><p><strong>使用抽象类：</strong></p><ul><li>需要在几个相关的类中<strong>共享代码</strong></li><li>需要能<strong>控制</strong>继承来的成员的访问权限，而不都是public</li><li>需要<strong>继承</strong>非静态（non-static）和非常量（non-final）的字段。</li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类的特点"><a href="#内部类的特点" class="headerlink" title="内部类的特点"></a>内部类的特点</h3><ul><li>内部类提供了更好的封装。只有外部类能访问内部类</li><li>内部类可以直接访问外部类的属性和方法，即使是private。因为内部类是成员</li><li>外部类不能直接访问内部类的属性和方法。要用 内部类实例.xxx</li></ul><h3 id="内部类分类"><a href="#内部类分类" class="headerlink" title="内部类分类"></a>内部类分类</h3><p>内部类有4种：成员内部类，局部内部类，匿名内部类，静态内部类。</p><ol><li><p><strong>成员内部类</strong>：作为外部类的一个成员存在，与外部类的属性、方法并列，不能直接访问</p><ul><li><p><strong>非静态内部类中不能存在static成员</strong>。</p></li><li><p>非静态内部类中<strong>可以调用外部类的任何成员</strong>，不管是静态的还是非静态的 </p></li><li><p><strong>创建：</strong>非静态内部类要依靠外部类实例.内部类创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.InnerClass inner = <span class="keyword">new</span> OuterClass().new InnerClass();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>局部内部类</strong>：在方法中定义的内部类，与局部变量类似，不能加访问限定符。其范围为定义它的代码块。</p></li><li><p><strong>匿名内部类</strong>：在方法中new的接口或抽象类实现。若实现的方法只有一个，可以用lambda表达式代替。</p><ul><li>无构造方法（因为没有类名）</li><li>无静态成员或方法</li><li>无访问修饰符</li></ul><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类，实现的是ActionListener接口</span></span><br><span class="line">        <span class="keyword">new</span> ActionListener()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"click action..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.onAction();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态内部类</strong>：定义在外部类中，用static定义。</p><ul><li>静态内部类<strong>不可以使用任何外围类的非static成员</strong>变量和方法。</li><li>静态内部类不依附外部类，<strong>可以直接创建</strong></li></ul></li></ol><h3 id="静态内部类和非静态内部类对比"><a href="#静态内部类和非静态内部类对比" class="headerlink" title="静态内部类和非静态内部类对比"></a>静态内部类和非静态内部类对比</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String outerName;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass1</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 1. 在静态内部类中可以存在静态成员 */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String _innerName = <span class="string">"static variable"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 2. 静态内部类只能访问外部类的静态成员变量和方法</span></span><br><span class="line"><span class="comment">             *    不能访问外部类的非静态成员变量和方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(<span class="string">"OutClass name :"</span> + outerName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass2</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 1. 非静态内部类中不能存在静态成员 */</span></span><br><span class="line">        <span class="keyword">public</span> String _innerName = <span class="string">"no static variable"</span>;</span><br><span class="line">        <span class="comment">/* 2. 非静态内部类中可以调用外部类的任何成员,不管是静态的还是非静态的 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"OuterClass name："</span> + outerName);</span><br><span class="line">            System.out.println(<span class="string">"OuterClass age："</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 3. 外部类能直接访问静态内部类静态元素 */</span></span><br><span class="line">        System.out.println(InnerClass1._innerName);</span><br><span class="line">        <span class="comment">/* 4. 静态内部类可以直接创建实例不需要依赖于外部类 */</span></span><br><span class="line">        <span class="keyword">new</span> InnerClass1().display();</span><br><span class="line">        <span class="comment">/* 4. 非静态内部的创建需要依赖于外部类 */</span></span><br><span class="line">        OuterClass.InnerClass2 inner2 = <span class="keyword">new</span> OuterClass().new InnerClass2();</span><br><span class="line">        <span class="comment">/* 3. 非静态内部类的成员需要使用非静态内部类的实例访问 */</span></span><br><span class="line">        System.out.println(inner2._innerName);</span><br><span class="line">        inner2.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类参考链接：</p><ul><li><a href="https://blog.csdn.net/suifeng3051/article/details/51791812" target="_blank" rel="noopener">https://blog.csdn.net/suifeng3051/article/details/51791812</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3811445.html</a></li></ul><h1 id="五、Object通用方法"><a href="#五、Object通用方法" class="headerlink" title="五、Object通用方法"></a>五、Object通用方法</h1><h2 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h2><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><h3 id="equal-与"><a href="#equal-与" class="headerlink" title="equal()与=="></a>equal()与==</h3><p>对于基本类型，==判断两个值是否相等，基本类型没有equals()方法。</p><p>对于引用类型，==判断两个实例是否引用指针是否指向同一个对象，而equals()判断引用的对象是否等价。</p><p>对于包装类型，要使用equals()比较数值（如IntegerCache只保存-127~128的值，其他的值都为新对象在堆上产生，不能用==，要使用<code>integer.equals()</code>）</p><p>若未重写equals()，equals的实现就是==</p><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p>hashCode() 返回散列值，而 equals() 是用来判断两个实例是否等价。</p><p><strong>等价的两个实例散列值一定要相同，但是散列值相同的两个实例不一定等价。</strong> (相当于hashCode将对象分到桶里，而equals再区分到底等不等) </p><p>HashSet中会先识别hashCode是否相等，再识别equals是否相等，以此判断两个对象是否为同一个对象。 </p><h3 id="hashCode-与equal"><a href="#hashCode-与equal" class="headerlink" title="hashCode()与equal()"></a>hashCode()与equal()</h3><p><strong>重写equals时一定要重写hashCode()方法</strong>，保证两个等价的实例的hashCode也相等。</p><p><strong>不同时重写equals和hashCode的后果</strong>：</p><ul><li>可能导致<strong>数据的不唯一</strong>。（HashSet中会认为是不同的对象，导致存储了两次同样的数据）</li><li><strong>内存泄漏</strong>（开发人员在删除HashSet元素时，自认为已经删除一个引用，但其实还保留了另一个相同内容的副本，导致该对象长时间得不到释放，造成内存泄漏） </li></ul><h3 id="实现hashCode"><a href="#实现hashCode" class="headerlink" title="实现hashCode"></a>实现hashCode</h3><p>理想的散列函数应当具有均匀性，即不相等的实例应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><p>一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    int result = 17;</span><br><span class="line">    result = 31 * result + x;</span><br><span class="line">    result = 31 * result + y;</span><br><span class="line">    result = 31 * result + z;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 </p><h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><h3 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h3><p>clone() 是 Object 的 protected 方法，<strong>一个类不显式去重写 clone()和实现Cloneable接口，其它类就不能调用该类实例的 clone() 方法</strong>。 </p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;<span class="comment">// 实现Cloneable接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;<span class="comment">// 重写clone()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><ul><li><strong>浅拷贝：拷贝实例和实例的引用</strong>。拷贝实例和原始实例的引用类型<strong>引用同一个对象</strong>；</li><li><strong>深拷贝：拷贝实例引用指向的对象</strong>。拷贝实例和原始实例的引用类型<strong>引用不同对象</strong>。</li></ul><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneConstructorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CloneConstructorExample e1 = <span class="keyword">new</span> CloneConstructorExample();</span><br><span class="line">CloneConstructorExample e2 = <span class="keyword">new</span> CloneConstructorExample(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h1 id="六、关键字"><a href="#六、关键字" class="headerlink" title="六、关键字"></a>六、关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>常量</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态</p><h1 id="七、反射"><a href="#七、反射" class="headerlink" title="七、反射"></a>七、反射</h1><p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 <strong>Class.forName</strong>(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p><strong>反射可以提供运行时的类信息，并且这个类在运行时才加载进来</strong>，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>反射可以不通过访问权限访问，破坏了封装性。</p><h3 id="获得Class对象（Class）"><a href="#获得Class对象（Class）" class="headerlink" title="获得Class对象（Class）"></a>获得Class对象（Class）</h3><blockquote><p>forName, getClass</p></blockquote><p><strong><code>Class.forName(&quot;Class全类名&quot;)</code></strong>    // 1. 使用Class类的forName静态方法</p><p><strong><code>Class&lt;?&gt; klass = ins.getClass()</code></strong>    // 2. 调用某个对象的getClass()方法 </p><p><strong><code>Class&lt;?&gt; klass = ClassA.class</code></strong>    // 3. 直接获取某一个类对象的class</p><p><strong><code>Class&lt;?&gt; klass = Integer.TYPE</code></strong>    // 直接获取某一个对象的class</p><h3 id="获取构造器（Constructor）"><a href="#获取构造器（Constructor）" class="headerlink" title="获取构造器（Constructor）"></a>获取构造器（Constructor）</h3><blockquote><p>class.getConstructor</p></blockquote><p>通过Class类的getConstructor方法得到Constructor类的一个实例，Constructor类有一个newInstance方法可以创建一个对象实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clz.getConstructor(args.class)；//参数为原方法参数的类型</span><br></pre></td></tr></table></figure><h3 id="创建实例（Instance）"><a href="#创建实例（Instance）" class="headerlink" title="创建实例（Instance）"></a>创建实例（Instance）</h3><blockquote><p>class.newInstance, constructor.newInstance</p></blockquote><p>先获得class对象，如Class clz</p><ol><li><p>使用Class对象的newInstance()创建Class对象对应类的实例。</p><p><strong><code>Object ins = clz.newInstance()</code></strong></p></li><li><p>指定构造器创建实例：先通过Class对象获取Constructor构造器对象，再通过Constructor对象的newInstance()方法创建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clz.getConstructor(args.class)；<span class="comment">//参数为原方法参数的类型</span></span><br><span class="line">Object obj = constructor.newInstance(args);</span><br></pre></td></tr></table></figure></li></ol><h3 id="获取方法（method）"><a href="#获取方法（method）" class="headerlink" title="获取方法（method）"></a>获取方法（method）</h3><blockquote><p>clz.getMethods();</p></blockquote><p>获取某个Class对象的方法集合（无视访问权限，不包括继承的方法）</p><p><strong><code>Method[] methods = clz.getDeclaredMethods();</code></strong></p><p>获取某个Class对象的公用方法集合（public），包括继承的公用方法</p><p><strong><code>Method[] methods = clz.getMethods()</code></strong></p><p>获取一个特定的方法。其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象 </p><p><strong><code>clz.getMethod(String methodName, Class&lt;?&gt;... paramTypes)</code></strong></p><p><strong><code>clz.getDeclaredMethod(String methodName, Class&lt;?&gt;... paramTypes)</code></strong></p><h3 id="获取成员变量（Field）"><a href="#获取成员变量（Field）" class="headerlink" title="获取成员变量（Field）"></a>获取成员变量（Field）</h3><p><strong><code>getField(String name)</code></strong></p><p><strong><code>getDeclaredField(String name)</code></strong></p><p><strong><code>getFields()</code></strong></p><p><strong><code>getDeclaredFields()</code></strong></p><h3 id="调用方法（method-invoke）"><a href="#调用方法（method-invoke）" class="headerlink" title="调用方法（method.invoke）"></a>调用方法（method.invoke）</h3><p><strong><code>method.invoke(Object obj, Object...args)</code></strong>  // 参数为要调用方法的实例对象和参数列表</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;<span class="comment">// 在此之外声明了一个Testor的类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clz = Testor.class;</span><br><span class="line">        Object obj = clz.newInstance();<span class="comment">//创建Testor的实例</span></span><br><span class="line">        Method method = clz.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class);<span class="comment">// 获取Testor类的add方法</span></span><br><span class="line">        Object result = method.invoke(obj,<span class="number">1</span>,<span class="number">4</span>);<span class="comment">//调用method对应的方法 =&gt; add(1,4)</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否为某个类的实例（isInstance）"><a href="#判断是否为某个类的实例（isInstance）" class="headerlink" title="判断是否为某个类的实例（isInstance）"></a>判断是否为某个类的实例（isInstance）</h3><p>一般地，我们用<strong>instanceof关键字来判断是否为某个类的实例</strong>。同时我们<strong>也可以借助反射中Class对象的isInstance()方法</strong>来判断是否为某个类的实例，它是一个Native方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;<span class="comment">// Class对象的方法，用法：clz.inInstance(obj)</span></span><br></pre></td></tr></table></figure><h3 id="反射创建数组"><a href="#反射创建数组" class="headerlink" title="反射创建数组"></a>反射创建数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object array = java.lang.reflect.Array.newInstance(Class elementClass, <span class="keyword">int</span> length);<span class="comment">//实例array</span></span><br><span class="line">java.lang.reflect.Array.set(array, <span class="number">0</span>, elem);<span class="comment">// 往array插入值</span></span><br><span class="line">Array.get(array, <span class="number">0</span>);<span class="comment">// 读取值</span></span><br></pre></td></tr></table></figure><h1 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h1><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。</p><ul><li><p>Error：表示 JVM 无法处理的错误。</p></li><li><p>Exception：表示程序可捕捉可处理的异常。分为两种：</p><ul><li><strong>受检异常</strong> ：编译期可预测的，必须处理的异常，需要用 try…catch… 语句捕获并处理，或用throws子句抛出，否则编译无法通过。</li><li><strong>非受检异常</strong> ：RuntimeException，运行时异常，不要求强制处理。</li></ul></li></ul><p><img src="/Blog/Java/Java基础复习/异常类图.png" alt="异常类图"></p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>五个关键字，分别是：<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>、<code>throws</code> </p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>如果<strong>一个方法可以导致一个异常但不处理它</strong>，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常。要做到这点，我们可以在方法声明中包含一个<code>throws</code>子句。一个<code>throws</code>子句列举了一个方法可能引发的所有异常类型。 </p><h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>用户自定义异常类，只需继承<code>Exception</code>类即可。</p><p>在程序中使用自定义异常类，大体可分为以下几个步骤:</p><ul><li>创建自定义异常类。</li><li>在方法中通过<code>throw</code>关键字抛出异常对象。</li><li>如果在当前抛出异常的方法中处理异常，可以使用<code>try-catch</code>语句捕获并处理；否则在方法的声明处通过<code>throws</code>关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常方法的调用者中捕获并处理异常。</li></ul><p>本节参考：<a href="https://www.tianmaying.com/tutorial/Java-Exception" target="_blank" rel="noopener">Java异常处理-详解</a></p><h1 id="九、泛型"><a href="#九、泛型" class="headerlink" title="九、泛型"></a>九、泛型</h1><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><h2 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h2><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h2 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h2><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息</p><ul><li><a href="http://www.importnew.com/24029.html" target="_blank" rel="noopener">Java 泛型详解</a></li></ul><h1 id="十、注解"><a href="#十、注解" class="headerlink" title="十、注解"></a>十、注解</h1><p>Annotation类型定义为@interface。</p><ol><li><p>所有的Annotation会自动继承java.lang.Annotation接口，并且不能再去继承别的类或接口。.   </p></li><li><p>参数成员只能用public或默认(default)这两个访问权修饰   </p></li><li>参数成员只能用8种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.   </li><li>要获取类方法和字段的注解信息，必须通过反射获取 Annotation对象，除此之外没有获取注解的方法   </li><li>注解也可以没有定义成员, 可以用于标记 </li></ol><p>PS:自定义注解需要使用到元注解 </p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>@Documented –注解是否将包含在JavaDoc中</p><p>@Retention –什么时候使用该注解（RUNTIME运行, CLASS类加载, SOURCE编译期）</p><p>@Target –注解用于什么地方（可用ElementType的参数）</p><p>@Inherited – 是否允许子类继承该注解</p><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><ol><li><p>@Override</p><p>java.lang.Override是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java编译器将以一个编译错误来警示。</p></li><li><p>@Deprecated</p><p>Deprecated也是一种标记类型注解。当一个类型或者类型成员或父类使用@Deprecated修饰的话，编译器将不鼓励使用这个被标注的程序元素。</p></li><li><p>@SuppressWarnings</p><p>SuppressWarning不是一个标记类型注解。抑制警告。它有一个类型为String[]的成员，这个成员的值为被禁止的警告名。对于javac编译器来讲，被-Xlint选项有效的警告名也同样对@SuppressWarings有效，同时编译器忽略掉无法识别的警告名。</p><p>@SuppressWarnings(“unchecked”) </p></li></ol><h2 id="自定义注解实例"><a href="#自定义注解实例" class="headerlink" title="自定义注解实例"></a>自定义注解实例</h2><p>编写注解，注解处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水果颜色注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitColor &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 颜色枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Color&#123; BLUE,RED,GREEN&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 颜色属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Color <span class="title">fruitColor</span><span class="params">()</span> <span class="keyword">default</span> Color.GREEN</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本节参考：<a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html" target="_blank" rel="noopener">注解Annotation实现原理及自定义注解例子</a></li></ul><h1 id="十一、枚举类型"><a href="#十一、枚举类型" class="headerlink" title="十一、枚举类型"></a>十一、枚举类型</h1><table><thead><tr><th>返回类型</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>compareTo(E o)</code></td><td>比较此枚举与指定对象的顺序</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object other)</code></td><td>当指定对象等于此枚举常量时，返回 true。</td></tr><tr><td><code>Class&lt;?&gt;</code></td><td><code>getDeclaringClass()</code></td><td>返回与此枚举常量的枚举类型相对应的 Class 对象</td></tr><tr><td><code>String</code></td><td><strong><code>name()</code></strong></td><td>返回此枚举常量的名称，在其枚举声明中对其进行声明</td></tr><tr><td><code>int</code></td><td><strong><code>ordinal()</code></strong></td><td>返回枚举常量的序数（它在枚举声明中的位置，从0开始）</td></tr><tr><td><code>String**</code>**</td><td><strong><code>toString()</code></strong></td><td>返回枚举常量的名称，它包含在声明中</td></tr><tr><td><code>static&lt;T extends Enum&lt;T&gt;&gt; T</code></td><td><strong><code>static valueOf(Class&lt;T&gt; enumType, String name)</code></strong></td><td>返回带指定名称的指定枚举类型的枚举常量。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day2 &#123;</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>),<span class="comment">// 这种写法都是调用构造函数</span></span><br><span class="line">    TUESDAY(<span class="string">"星期二"</span>),<span class="comment">// 这些都是本类型的实例，名为TUSDAY的Day2类型，类似多例模式</span></span><br><span class="line">    WEDNESDAY(<span class="string">"星期三"</span>),</span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>),</span><br><span class="line">    FRIDAY(<span class="string">"星期五"</span>),</span><br><span class="line">    SATURDAY(<span class="string">"星期六"</span>),</span><br><span class="line">    SUNDAY(<span class="string">"星期日"</span>);<span class="comment">// 以上枚举实例，记住要用分号结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">// 中文描述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造,防止被外部调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day2</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc=desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义方法,返回描述,跟常规类的定义没区别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Day2 day:Day2.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"name:"</span>+day.name()+</span><br><span class="line">                    <span class="string">",desc:"</span>+day.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     输出结果:</span></span><br><span class="line"><span class="comment">     name:MONDAY,desc:星期一</span></span><br><span class="line"><span class="comment">     name:TUESDAY,desc:星期二</span></span><br><span class="line"><span class="comment">     name:WEDNESDAY,desc:星期三</span></span><br><span class="line"><span class="comment">     name:THURSDAY,desc:星期四</span></span><br><span class="line"><span class="comment">     name:FRIDAY,desc:星期五</span></span><br><span class="line"><span class="comment">     name:SATURDAY,desc:星期六</span></span><br><span class="line"><span class="comment">     name:SUNDAY,desc:星期日</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参考资料：<a href="https://blog.csdn.net/javazejian/article/details/71333103" target="_blank" rel="noopener">Java枚举类型enum</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文大致复习了Java的基础内容：数据类型，String，运算，类型转换，OOP的封装，继承，多态，Object方法包括equals，hashCode，clone，还有final、static关键字，反射，异常，泛型，注解，枚举类型&lt;/p&gt;
&lt;p&gt;参考了github-CYC2018的笔记做的总结，在此基础上补充了一点自己需要补充的内容🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java8-Stream流-复习</title>
    <link href="https://uncleaaron.github.io/Blog/Java/java8-Stream%E6%B5%81-%E5%A4%8D%E4%B9%A0/"/>
    <id>https://uncleaaron.github.io/Blog/Java/java8-Stream流-复习/</id>
    <published>2018-08-03T07:03:51.000Z</published>
    <updated>2018-08-03T07:03:51.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="default1" scheme="https://uncleaaron.github.io/Blog/tags/default1/"/>
    
      <category term="default2" scheme="https://uncleaaron.github.io/Blog/tags/default2/"/>
    
  </entry>
  
  <entry>
    <title>java8其中两个新特性-lambda表达式和Stream流-复习</title>
    <link href="https://uncleaaron.github.io/Blog/Java/java8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%A4%8D%E4%B9%A0/"/>
    <id>https://uncleaaron.github.io/Blog/Java/java8-lambda表达式-复习/</id>
    <published>2018-08-03T07:02:16.000Z</published>
    <updated>2018-08-03T08:37:01.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>去除类定义和类方法，只留下方法使用的参数表和方法实现</p><p>如下：</p><p><code>(params) -&gt; { statements; }</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String a = <span class="string">"test1"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(<span class="string">"testa"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"testc"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替代的类只有一个方法的时候才能生效，否则java识别不出应该用哪个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量作用域：不能修改匿名方法外的变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="default1" scheme="https://uncleaaron.github.io/Blog/tags/default1/"/>
    
      <category term="default2" scheme="https://uncleaaron.github.io/Blog/tags/default2/"/>
    
  </entry>
  
  <entry>
    <title>java集合框架-汇总复习</title>
    <link href="https://uncleaaron.github.io/Blog/Java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E6%B1%87%E6%80%BB%E5%A4%8D%E4%B9%A0/"/>
    <id>https://uncleaaron.github.io/Blog/Java/java集合框架-汇总复习/</id>
    <published>2018-08-03T07:01:55.000Z</published>
    <updated>2018-08-03T14:27:29.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注</p><p><a href="https://www.jianshu.com/p/bfdb5ffa0ae2" target="_blank" rel="noopener">Java1.8集合框架索引总结</a> 这里有人整合了一段，可以阅读一下</p><p>此外，有人总结的面试题<a href="https://blog.csdn.net/qq_26947195/article/details/79755944" target="_blank" rel="noopener">Java集合框架面试总结</a></p><p>这个博主讲的非常精髓，有空也要读一下<a href="https://www.cnblogs.com/xiaoxi/p/6089984.html" target="_blank" rel="noopener">Java集合框架综述</a>🖊</p></blockquote><a id="more"></a><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>Collection集合：Set，List，Queue</p><p>Map图：（与Collection不同族）HashMap，HashTable，TreeMap，ConcurrentHashMap</p><p><img src="/Blog/Java/java集合框架-汇总复习/Collection类图.png" alt="类图"></p><p><img src="/Blog/Java/java集合框架-汇总复习/Map类图-简易.png" alt="Map类图-简易"></p><h1 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>特点：查询快，增删慢</p><p>实现：数组</p><p>默认大小10，默认扩展50%+1个</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>特点：增删块，查询慢</p><p>实现：双向链表</p><p>实现了Deque双向队列（offer入队，pool出队，peek查看）</p><p>兼备Stack的作用（push入栈，pop出栈，peek查看）</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>与ArrayList相似</p><p>数组</p><p>线程安全（synchronized），效率低，不推荐</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>LIFO先进后出，继承了Vector</p><p>数组</p><p>线程安全，效率低，不推荐</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>无序，按照Hash算法存储元素，</p><p>基于HashMap存储元素（先检查hashCode再检查equals）</p><p>存储性能和查询性能良好</p><p>非线程安全</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>可排序的Set结构</p><p>红黑树，基于TreeMap实现（底层维护一个TreeMap）</p><p>支持自然排序和定制排序</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>HashSet的子类</p><p>使用链表维护元素的次序</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HashSet性能最高</p><p>实现排序Set：用TreeSet</p><p>实现插入顺序：用LinkedHashSet</p><p>Set中尽量只添加不可变对象</p><p>上述三个Set都是线程不安全的，若需要并发访问，需要手动实现同步。（例Collection.synchronizedSet方法）</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>Entry数组保存key-value</p><p>存储时先根据HashCode决定在数组的位置</p><p>用的是链地址法解决Hash冲突（解决hash冲突的办法有1. 开放地址法 2. 再哈希法 3. 链地址法 4. 建立公共溢出区）</p><p>关于hashMap的总结这里还有更多：<a href="https://blog.csdn.net/weixin_37864013/article/details/77428919" target="_blank" rel="noopener">HashMap总结：链接</a></p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">HashMap：HashMap在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#默认大小16，加载因子为0.75，可以使用Collections.synchronizeMap(hashMap)实现同步</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">LinkedHashMap：相对于HashMap，插入的时候有序，所以排序的时候</span></span><br><span class="line"><span class="meta">#</span><span class="bash">HashTable：数据结构与HashMap一致，只不过HashMap线程安全(synchronized)，效率差，需要同步建议使用ConcurrentHashMap</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ConcurrentHashMap：jdk1.5以后，与HashTable相同是线程安全，但是在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">TreeMap：底层使用的数据结构是红黑树，无序，不允许重复（无序指元素顺序与添加顺序不一致），TreeMap集合默认会对键进行排序，所以键必须实现自然排序和定制排序中的一种</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/bfdb5ffa0ae2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java1.8集合框架索引总结&lt;/a&gt; 这里有人整合了一段，可以阅读一下&lt;/p&gt;
&lt;p&gt;此外，有人总结的面试题&lt;a href=&quot;https://blog.csdn.net/qq_26947195/article/details/79755944&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java集合框架面试总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个博主讲的非常精髓，有空也要读一下&lt;a href=&quot;https://www.cnblogs.com/xiaoxi/p/6089984.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java集合框架综述&lt;/a&gt;🖊&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="default1" scheme="https://uncleaaron.github.io/Blog/tags/default1/"/>
    
      <category term="default2" scheme="https://uncleaaron.github.io/Blog/tags/default2/"/>
    
  </entry>
  
  <entry>
    <title>java类加载-简单总结</title>
    <link href="https://uncleaaron.github.io/Blog/Java/java%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>https://uncleaaron.github.io/Blog/Java/java类加载-简单总结/</id>
    <published>2018-08-02T11:07:20.000Z</published>
    <updated>2018-08-02T12:21:48.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>这几天简单阅读了《深入理解Java虚拟机》的类加载章节，简单总结了一些内容，类加载器的部分之后会补充🖊 </p></blockquote><a id="more"></a><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p><strong>加载→验证→准备→解析→初始化===&gt;使用===&gt;卸载</strong></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>（不要和类加载搞混）加载阶段虚拟机所完成的3件事</p><ol><li>通过类名定义此类的二进制字节流</li><li>将静态结构存储结构转化进方法区的运行时数据结构</li><li>生成java.lang.Class对象，存入方法区，作为该类入口</li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>通过验证确保Class文件的字节流包含的信息符合当前虚拟机的要求，确保其不会威胁虚拟机自身</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>正式为类分配方法区内存空间（不是指对象），并设置类变量初始值(0值)。（这里仅仅分配static类变量，实例变量在实例对象时加入堆）</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>将常量池的符号引用替换为直接引用</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>这是类加载的最后一步，这个阶段才真正开始执行代码，执行类构造器<code>&lt;clinit&gt; ()</code>（由所有类变量赋值操作和静态语句块合并成）。</p><ul><li>类构造器的合并是按语句出现顺序排序的，静态语句块只能<strong>访问</strong>到定义在静态语句块之前的变量。（定义在其之后的变量只能赋值不能访问）如下所示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;<span class="comment">// 可以给变量赋值</span></span><br><span class="line">        System.out.println(i);<span class="comment">// 这是错误的，不可以访问定义在static语句块之后的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父类的类构造器一定会先执行完毕于子类的类构造器（也意味着其静态语句块先于子类的变量赋值操作）</li><li>接口没有静态语句块，但还有变量初始化的赋值操作，也会生成\&lt;client>()方法，但其不需要先执行父接口的类构造器（因为接口只有真正引用到了父接口时，父接口才会初始化)</li></ul><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>类中有且仅有4种主动引用情况执行类初始化，其他情况（被动引用）都不会初始化类</p><ol><li>遇到<strong>new、getstatic、putstatic、invokestatic</strong>这4个字节码指令<ul><li>new：使用new关键字实例化对象。</li><li>getstatic：读引用一个类的静态字段。(已经在编译期把结果放入常量池的final静态字段除外)</li><li>putstatic：写引用一个类的静态字段。(已经在编译期把结果放入常量池的final静态字段除外)</li><li>invokestatic：调用一个类的静态方法。(已经在编译期把结果放入常量池的final静态常量除外)</li></ul></li><li><strong>初始化类时，若父类也未初始化，先初始化父类</strong><ul><li><strong>接口初始化：只有真正引用到了父接口时，才会初始化。</strong></li></ul></li><li><strong>反射</strong>调用类</li><li>虚拟机<strong>启动</strong>时会先初始化包含<strong>main</strong>()方法的类</li></ol><p>演示几个不会触发类初始化的被动引用示例：</p><p>下面有三个示例</p><ul><li>通过类引用final静态常量，因为final静态常量已经在编译期进入常量池，本质上不会调用到类，不触发初始化</li><li><strong>通过子类引用父类的静态字段，不会导致子类初始化</strong></li><li>数组声明不触发初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"SuperClass init."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用value时，会初始化这个SuperClass类（这里的不是常量）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 引用Final_Value时，不会初始化SuperClass</span></span><br><span class="line">    <span class="comment">//    因为static final变量在编译期就已经放到了常量池里，本质上没直接引用到定义常量的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Final_Value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SonClass init."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 引用类的Final_Value时，不会触发初始化</span></span><br><span class="line">    <span class="comment">//    因为static final变量在编译期就已经放到了常量池里，本质上没直接引用到定义常量的类</span></span><br><span class="line">        System.out.println(SuperClass.Final_Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 通过子类引用父类的静态字段，不会导致子类的初始化！</span></span><br><span class="line">        System.out.println(SonClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 通过数组定义类，很明显不会触发初始化过程</span></span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这几天简单阅读了《深入理解Java虚拟机》的类加载章节，简单总结了一些内容，类加载器的部分之后会补充🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2.0 Cache自定义key/value序列化</title>
    <link href="https://uncleaaron.github.io/Blog/JavaWeb/Cache%E8%87%AA%E5%AE%9A%E4%B9%89key-value%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://uncleaaron.github.io/Blog/JavaWeb/Cache自定义key-value序列化/</id>
    <published>2018-08-01T13:06:58.000Z</published>
    <updated>2018-08-01T13:15:05.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Sping Boot2.0.3变化太多了，今天写redis缓存配置的时候又发现了RedisCacheManage的配置又相比SpringBoot 1.5变化了很多，再这再备注一下🖊 </p></blockquote><a id="more"></a><h1 id="SpringBoot2-0-Cache自定义key-value序列化"><a href="#SpringBoot2-0-Cache自定义key-value序列化" class="headerlink" title="SpringBoot2.0 Cache自定义key/value序列化"></a>SpringBoot2.0 Cache自定义key/value序列化</h1><h3 id="1、pom依赖"><a href="#1、pom依赖" class="headerlink" title="1、pom依赖"></a>1、pom依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2、配置yml"><a href="#2、配置yml" class="headerlink" title="2、配置yml"></a>2、配置yml</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cache:</span><br><span class="line">    redis:</span><br><span class="line">      use-key-prefix: <span class="keyword">true</span></span><br><span class="line">      time-to-live: <span class="number">1</span>d</span><br><span class="line">  redis:</span><br><span class="line">    port: <span class="number">6379</span></span><br><span class="line">    host: ip</span><br><span class="line">    password: pwd</span><br><span class="line">    database: <span class="number">0</span></span><br><span class="line">    timeout: <span class="number">1</span>s</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: <span class="number">8</span></span><br><span class="line">        max-idle: <span class="number">50</span></span><br><span class="line">        min-idle: <span class="number">0</span></span><br><span class="line">        max-wait: -<span class="number">1</span>ms</span><br></pre></td></tr></table></figure><h3 id="3、自定义CacheConfiguration-类"><a href="#3、自定义CacheConfiguration-类" class="headerlink" title="3、自定义CacheConfiguration 类"></a>3、自定义CacheConfiguration 类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j2;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.cache.redis"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Duration timeToLive = Duration.ZERO;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeToLive</span><span class="params">(Duration timeToLive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeToLive = timeToLive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(<span class="keyword">this</span>.timeToLive)</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(keySerializer()))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer()))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line"></span><br><span class="line">        RedisCacheManager redisCacheManager = RedisCacheManager.builder(connectionFactory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .transactionAware()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"自定义RedisCacheManager加载完成"</span>);</span><br><span class="line">        <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String,Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        redisTemplate.setKeySerializer(keySerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(keySerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(valueSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(valueSerializer());</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"自定义RedisTemplate加载完成"</span>);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedisSerializer&lt;String&gt; <span class="title">keySerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedisSerializer&lt;Object&gt; <span class="title">valueSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Sping Boot2.0.3变化太多了，今天写redis缓存配置的时候又发现了RedisCacheManage的配置又相比SpringBoot 1.5变化了很多，再这再备注一下🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
      <category term="Java 开发问题总结" scheme="https://uncleaaron.github.io/Blog/tags/Java-%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="SpringBoot" scheme="https://uncleaaron.github.io/Blog/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>第6章 Java并发容器和框架</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC6%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java并发编程艺术/第6章-Java并发容器和框架/</id>
    <published>2018-07-25T11:55:32.000Z</published>
    <updated>2018-07-26T12:47:29.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="default1" scheme="https://uncleaaron.github.io/Blog/tags/default1/"/>
    
      <category term="default2" scheme="https://uncleaaron.github.io/Blog/tags/default2/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾收集GC和内存分配策略</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86GC%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java垃圾收集GC和内存分配策略/</id>
    <published>2018-07-23T12:17:47.000Z</published>
    <updated>2018-07-23T12:19:31.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>前言用<code>&gt;</code>符号标注🖊 </p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前言用&lt;code&gt;&amp;gt;&lt;/code&gt;符号标注🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java对象创建、内部数据、如何访问(HotSpot虚拟机下）</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%AF%B9%E8%B1%A1-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java对象-HotSpot虚拟机下/</id>
    <published>2018-07-21T11:54:55.000Z</published>
    <updated>2018-07-23T11:44:44.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>对象创建</strong>：查找类型，确认类加载，分配内存，初始化内存，设置对象，init🖊</p><p><strong>对象构造</strong>：对象头（Markword，类型指针），实例数据</p><p><strong>对象访问定位</strong>：从栈上的引用访问到对象，需要查找到堆中的对象，然后通过对象中的类型指针找到其类型 </p></blockquote><a id="more"></a><h1 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h1><p>这里讲的是普通的Java对象，不包括数组或Class对象</p><ol><li>虚拟机遇到new指令时，<strong>检查指令参数是否能在常量池中定位到这个类的符号引用</strong></li><li>检查这个符号引用代表的类<strong>是否已经被加载、解析和初始化</strong>过</li><li>若未加载，<strong>执行相应的类加载</strong>过程</li><li>为新生对象<strong>分配内存</strong>。需要内存大小在编译时就可完全确定。分配方式有几种，“空闲列表”、“指针碰撞”、“CAS+失败重试保证原子性”，“分配TLAB本地线程分配缓冲”</li><li>对<strong>内存空间初始化零值</strong>。这一步保证了对象的实例字段在不赋初始值就可以直接使用，能访问到队形数据类型所对应的零值</li><li>虚拟机对<strong>对象进行设置</strong>。例如是哪个类、对象哈希码、GC分代年龄、是否设置偏向锁等，对对象头Object Header设置。</li><li><strong>执行<code>init</code>方法</strong>，按照程序员意愿初始化对象。这样才算是真正被完全生产出来对象（在这之前对象内都还是零值）</li></ol><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><ul><li>对象头：MarkWord+类型指针<ul><li>MarkWord：对象自身运行时的设置数据：哈希码HashCode，GC分代年龄，锁状态，持有锁，偏向线程ID等</li><li>类型指针：指向类元数据，虚拟机通过这个指针确定对象的类型</li></ul></li><li>实例数据：包括对象定义的数据，而且还包括从父类继承的、子类定义的数据</li><li>对齐填充：补位的无意义填充</li></ul><h1 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h1><p>Java程序是如何通过引用定位到对象实例数据和类型数据的？</p><p>虚拟机有两钟可实现的方式：</p><ul><li>句柄方式：Java堆中划分出一个句柄池，其中每个句柄存放对象实例数据和类型数据各自的地址信息。特点是稳定，对象被移动只改变句柄不改变reference。</li><li>直接指针：Java堆的对象还存放一个类型的指针。速度更快，节省了1次指针定位的时间开销。（这正是HotSpot虚拟机的实现方式）</li></ul><p><img src="/Blog/Java/Java对象-HotSpot虚拟机下/通过句柄访问对象.png" alt="通过句柄访问对象"></p><p><img src="/Blog/Java/Java对象-HotSpot虚拟机下/通过类型指针访问对象.png" alt="通过类型指针访问对象"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;对象创建&lt;/strong&gt;：查找类型，确认类加载，分配内存，初始化内存，设置对象，init🖊&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象构造&lt;/strong&gt;：对象头（Markword，类型指针），实例数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象访问定位&lt;/strong&gt;：从栈上的引用访问到对象，需要查找到堆中的对象，然后通过对象中的类型指针找到其类型 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域划分以及内存溢出异常</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java内存区域划分以及内存溢出异常/</id>
    <published>2018-07-21T11:54:55.000Z</published>
    <updated>2018-07-23T12:15:41.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Java虚拟机的内存区域主要分为：程序计数器，虚拟机栈，本地方法栈，Java堆，方法区🖊 </p><p>其中，<strong>栈</strong>描述<strong>方法</strong>执行，及方法的<em>局部变量和引用</em>；<strong>堆</strong>描述<strong>对象</strong>；<strong>方法区</strong>描述<strong>类</strong>和常量</p><p>其中，栈结构线程私有，堆结构线程共享（方法区描述类，也是堆结构）</p></blockquote><a id="more"></a><h1 id="Java虚拟机运行时数据区域"><a href="#Java虚拟机运行时数据区域" class="headerlink" title="Java虚拟机运行时数据区域"></a>Java虚拟机运行时数据区域</h1><p><img src="/Blog/Java/Java内存区域划分以及内存溢出异常/Java虚拟机运行时数据区.png" alt="Java虚拟机运行时数据区"></p><blockquote><p>上图理解：</p><p><strong>堆</strong>结构线程共享，描述所有的对象（类在方法区中，方法区也是堆）；</p><p><strong>栈</strong>和计数器线程私有，描述方法执行</p></blockquote><p>Java虚拟机在运行时会把它所管理的内存划分为若干个不同的数据区域。大致分为以下：</p><ol><li><p><strong>程序计数器</strong>：在Java中，每个线程都有一个独立的程序计数器，独立存储，该段内存是线程私有的</p></li><li><p><strong>Java虚拟机栈：</strong>描述<strong>方法执行</strong>的内存模型：</p><ul><li><p>每个方法在执行的同时会创建<strong>栈帧</strong>用于存储<strong>局部变量表</strong>、动态链接等信息。</p></li><li><p>其中，局部变量表存放基本类型、对象引用、returnAddress类型。其内存空间大小分配在编译期间就可以完全确定，之后也不会改变。</p></li><li>线程私有的，生命周期与线程相同。</li><li>当线程请求的栈深度大于虚拟机允许的深度，抛出StackOverFlowError异常</li><li>可动态扩展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li><li><p><strong>本地方法栈</strong>：描述<strong>Native方法</strong>的内存模型，其他与虚拟机栈一样。</p></li><li><p><strong>Java堆</strong>：<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。</p><ul><li>被<strong>所有线程共享</strong>这一块内存区域，是Java虚拟机所管理的最大一块内存</li><li>堆是<strong>GC垃圾收集器管理</strong>的主要区域（在普遍使用的分代手机算法中，堆可分为：新生代和老年代）</li><li>对线程来说，还划分出多个线程私有的<strong>本地线程分配缓冲区（TLAB）</strong></li><li>以上无论如何划分，堆存放的都是对象实例，划分只是为了更好地回收和分配内存</li><li>可动态扩展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li><li><p><strong>方法区</strong>：<strong>存储Class</strong>文件的相关信息：已被加载的<strong>类信息</strong>、<strong>常量</strong>、（类变量）静态变量、编译后的代码等</p><ul><li>所有线程共享</li><li><strong>运行时常量池</strong>：Class文件的常量池的信息，在类加载后进入方法区的运行时常量池<ul><li>Java不要求常量一定要编译时产生，可以运行期间产生放入方法区常量池，例如String.intern()</li><li>（此外Class文件中还有类版本、字段、方法、接口等描述信息）</li></ul></li><li>这部分的GC较少，在此区域GC主要为了针对常量池回收和类型卸载。</li><li>其实它也是堆结构，但是要与Java堆区分，称为“Non-Heap”非堆</li><li>可动态拓展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li><li><p><strong>直接内存</strong>：</p><ul><li>可动态拓展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li></ol><h1 id="OutOfMemoryError异常-内存溢出"><a href="#OutOfMemoryError异常-内存溢出" class="headerlink" title="OutOfMemoryError异常(内存溢出)"></a>OutOfMemoryError异常(内存溢出)</h1><p>申请的内存空间超过了系统实际分配的空间<strong>（系统无法满足内存申请）</strong> ，就会发生OutOfMemory异常（以下简称OOM）</p><p>除了程序计数器外，其他几个运行时区域都有可能发生OOM异常</p><h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>堆用于存储对象实例，只要不断创建对象，并且保证GC Roots到对象之间有可达路径以避免对象被垃圾回收，那么对象数量在到达堆最大容量限制是抛出内存溢出OOM异常。</p><p>分清楚是内存泄漏还是内存溢出</p><p><strong>内存泄漏：</strong>申请内存后，无法释放已申请的内存空间 。</p><blockquote><p>比如，你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。 </p></blockquote><p><strong>内存溢出：</strong>申请内存时，没有足够的内存供申请者使用。</p><blockquote><p>比如：给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，内存不够用，就会报OOM，此时内存溢出。</p><p>又比如：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。   </p></blockquote><h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>（HotSpot虚拟机不区分这两个栈）</p><p><strong>StackOverFlow</strong>Error：线程请求的栈深度大于虚拟机允许的深度</p><p><strong>OutOfMemory</strong>Error：扩展栈时无法申请到足够的内存</p><p>单线程测试下，无论是栈容量少，还是栈帧太大，都抛出了StackOverFlow异常</p><p>而在多线程下，通过不断建立内存用量大的线程，迅速耗尽内存空间，会抛出OOM</p><h2 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h2><p>通过<strong>不断产生动态类</strong>（如<strong>反射</strong>和<strong>动态代理</strong>、<strong>JSP</strong>等<strong>会加载Class</strong>的操作），在运行时产生大量的类去填满方法区，直到溢出，抛出OOM。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java虚拟机的内存区域主要分为：程序计数器，虚拟机栈，本地方法栈，Java堆，方法区🖊 &lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;栈&lt;/strong&gt;描述&lt;strong&gt;方法&lt;/strong&gt;执行，及方法的&lt;em&gt;局部变量和引用&lt;/em&gt;；&lt;strong&gt;堆&lt;/strong&gt;描述&lt;strong&gt;对象&lt;/strong&gt;；&lt;strong&gt;方法区&lt;/strong&gt;描述&lt;strong&gt;类&lt;/strong&gt;和常量&lt;/p&gt;
&lt;p&gt;其中，栈结构线程私有，堆结构线程共享（方法区描述类，也是堆结构）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库规范及解读</title>
    <link href="https://uncleaaron.github.io/Blog/DataBase/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8F%8A%E8%A7%A3%E8%AF%BB/"/>
    <id>https://uncleaaron.github.io/Blog/DataBase/MySQL数据库规范及解读/</id>
    <published>2018-07-19T07:16:08.000Z</published>
    <updated>2018-07-19T08:36:24.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>使用Mysql的准则 🖊 </p></blockquote><a id="more"></a><h2 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h2><blockquote><p>第一条：必须使用InnoDB存储引擎</p></blockquote><p>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</p><blockquote><p>第二条：必须使用utf8(utf8mb4)字符集</p></blockquote><p>解读：万国码，无需转码，无乱码风险，节省空间，utf8mb4是utf8的超集，由于近年移动设备的增多，emoji表情以及部分不常见汉字在utf8下会表现为乱码，故需要升级至utf8mb4</p><blockquote><p>第三条：数据表、数据字段必须加入中文注释</p></blockquote><p>解读：N年后谁会知道这个a1,a2,a3字段是干嘛的</p><blockquote><p>第四条：禁止使用存储过程、视图、触发器、Event</p></blockquote><p>解读：高并发<strong>大数据</strong>的互联网业务，<strong>架构</strong>设计思路是<em>“解放<strong>数据库</strong>CPU，将计算转移到服务层“</em>，并发量大的情况下，这些功能很可能将数据库拖死，<em>业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”</em>。数据库擅长存储与索引，CPU计算还是上移吧</p><blockquote><p>第五条：禁止存储大文件或者大照片</p></blockquote><p>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI多好</p><h2 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h2><blockquote><p>第一条：只允许<em>使用内网域名，而不是ip连接数据库</em></p></blockquote><p>解读：虽然IP访问更快，域名访问需要内网dns，但是对于大数据库的扩展和迁库考虑，域名更好</p><blockquote><p>第二条：线上环境、开发环境、<strong>测试</strong>环境数据库内网域名遵循命名规范</p></blockquote><p>业务名称：xxx<br>线上环境：dj.xxx.db<br>开发环境：dj.xxx.rdb<br>测试环境：dj.xxx.tdb<br>从库在名称后加-s标识，备库在名称后加-ss标识<br>线上从库：dj.xxx-s.db<br>线上备库：dj.xxx-sss.db</p><blockquote><p>第三条：库名、表名、字段名：小写，下划线风格，不超过32个字符，禁止拼音英文混用</p></blockquote><p>解读：见名知意，方便后续维护</p><blockquote><p>第四条：表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</p></blockquote><p>解读：见名知意，方便后续维护</p><h2 id="三、表和字段设计规范"><a href="#三、表和字段设计规范" class="headerlink" title="三、表和字段设计规范"></a>三、表和字段设计规范</h2><blockquote><p>第一条：禁止使用外键，如果有外键完整性约束，需要应用程序控制</p></blockquote><p>解读：<em>外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql的性能</em>，甚至会造成死锁。高并发情况下容易造成数据库性能，<em>大数据高并发业务场景数据库使用以性能优先</em></p><blockquote><p>第二条：必须把字段定义为NOT NULL并且提供默认值</p></blockquote><p>解读：<br>a) null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化<br>b) null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多<br>c) null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标识<br>d) 对null的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。<em>如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录</em></p><blockquote><p>第三条：禁止使用TEXT、BLOB类型</p></blockquote><p>解读：会浪费更多的磁盘和内存空间，<em>非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能</em></p><blockquote><p>第四条：禁止使用小数存储国币</p></blockquote><p>解读：曾经踩过这样的坑，100元分3天摊销，每天摊销(100/3)元，结果得到3个33.33。后来实施对账系统，始终有几分钱对不齐，郁闷了很久（不是几分钱的事，是业务方质疑的眼神让研发很不爽），最后发现是除法惹的祸<br>解决方案：使用“分”作为单位，这样数据库里就是整数了</p><blockquote><p>第五条：必须使用varchar(20)存储手机号</p></blockquote><p>解读：<br>a) 涉及到区号或者国家代号，可能出现+-()<br>b) 手机号会去做数学运算么？<br>c) varchar可以支持模糊查询，例如：like“138%”</p><blockquote><p>第六条：禁止使用ENUM，可使用TINYINT代替</p></blockquote><p>解读：<br>a) 增加新的ENUM值要做DDL操作<br>b) ENUM的内部实际存储就是整数，你以为自己定义的是字符串？</p><blockquote><p>第七条：表必须有主键，例如自增主键</p></blockquote><p>解读：<br>a) 主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用<br>b) 主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率<br>c) 无主键的表删除，在row模式的主从架构，会导致备库夯住</p><h2 id="四、索引设计规范"><a href="#四、索引设计规范" class="headerlink" title="四、索引设计规范"></a>四、索引设计规范</h2><blockquote><p>第一条：单表索引建议控制在5个以内</p></blockquote><p>解读：一个好的索引设计，可以让你的效率提高几十甚至几百倍，但过多反而适得其反</p><blockquote><p>第二条：单索引字段数不允许超过5个</p></blockquote><p>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了</p><blockquote><p>第三条：禁止在更新十分频繁、区分度不高的属性上建立索引</p></blockquote><p>解读：<br>a) 更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能<br>b) “性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似</p><blockquote><p>第四条:建立组合索引，必须把区分度高的字段放在前面</p></blockquote><p>解读：能够更加有效的过滤数据</p><h2 id="五、SQL使用规范"><a href="#五、SQL使用规范" class="headerlink" title="五、SQL使用规范"></a>五、SQL使用规范</h2><blockquote><p>第一条：禁止使用SELECT *，只获取必要的字段，需要显示说明列属性</p></blockquote><p>解读：<br>a) 读取不需要的列会增加CPU、IO、NET消耗<br>b) 不能有效的利用覆盖索引<br>c) 使用<code>SELECT *</code>容易在增加或者删除字段后出现程序BUG</p><blockquote><p>第二条：禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性</p></blockquote><p>解读：容易在增加或者删除字段后出现程序BUG</p><blockquote><p>第三条：禁止使用属性隐式转换</p></blockquote><p>解读：SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中phone索引，猜猜为什么？<br>int数据类型优先级高于varcher， 该查询会把phone转换为int，因此需要把表中所有数据改成int，所以必须全盘扫描<br>phone是varchar类型，SQL语句带入的是整形，故不会命中索引，加个引号就好了：<br>SELECT uid FROM t_user WHERE phone=’13812345678’</p><blockquote><p>第四条：禁止在WHERE条件的属性上使用函数或者表达式</p></blockquote><p>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描<br>正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</p><blockquote><p>第五条：禁止大表使用JOIN查询，禁止大表使用子查询</p></blockquote><p>解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能，大表指的是数据量在1000万以上的表</p><blockquote><p>第六条：禁止使用OR条件，必须改为IN查询</p></blockquote><p>解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？</p><blockquote><p>第七条：禁止使用负向查询，以及%开头的模糊查询</p></blockquote><p>解读：<br>a) 负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描<br>b) %开头的模糊查询，会导致全表扫描<br>一般来说，WHERE过滤条件不会只带这么一个“负向查询条件”，还会有其他过滤条件，举个例子：查询沈剑已完成订单之外的订单（好拗口）：<br>SELECT oid FROM t_order WHERE uid=123 AND status != 1;<br>订单表5000w数据，但uid=123就会迅速的将数据量过滤到很少的级别（uid建立了索引），此时再接上一个负向的查询条件就无所谓了，扫描的行数本身就会很少<br>但如果要查询所有已完成订单之外的订单：<br>SELECT oid FROM t_order WHERE status != 1;<br>这就挂了，立马CPU100%，status索引会失效，负向查询导致全表扫描</p><blockquote><p>第八条：应用程序必须捕获SQL异常，并有相应处理</p></blockquote><p>解读：方便维护，及时“查漏补缺”</p><p><strong>总结：大数据量高并发的互联网业务，极大影响数据库性能的都不让用，不让用哟。</strong></p><p>转自：<a href="https://zhuanlan.zhihu.com/p/32586602" target="_blank" rel="noopener">知乎：SangSir</a>的文章</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用Mysql的准则 🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>领域模型中的实体类的4种类型VO,DTO,DO,PO</title>
    <link href="https://uncleaaron.github.io/Blog/Java/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%9A%844%E7%A7%8D%E7%B1%BB%E5%9E%8BVO-DTO-DO-PO/"/>
    <id>https://uncleaaron.github.io/Blog/Java/领域模型中的实体类的4种类型VO-DTO-DO-PO/</id>
    <published>2018-07-19T07:14:08.000Z</published>
    <updated>2018-07-21T16:58:40.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>经常会接触到VO，DO，DTO的概念，本文从领域建模中的实体划分和项目中的实际应用情况两个角度，对这几个概念进行简析 🖊 </p></blockquote><a id="more"></a><p>在项目应用中，VO对应于页面上需要显示的数据（表单），DO对应于数据库中存储的数据（数据表），DTO对应于除二者之外需要进行传递的数据。 </p><p>领域模型中的实体类分为四种类型：VO、DTO、DO、PO，各种实体类用于不同业务层次间的交互，并会在层次内实现实体类之间的转化。</p><p>业务分层为：视图层（VIEW+ACTION），服务层（SERVICE），持久层（DAO） </p><p>相应各层间实体的传递如下图：  </p><p> <img src="/Blog/Java/领域模型中的实体类的4种类型VO-DTO-DO-PO/领域模型.jpg" alt="领域模型"></p><p>项目中我们并没有严格遵循这种传递关系，但这种和业务层次的关联对我们理解各实体类的作用是有帮助的。（我们没有接触到PO的原因，我理解为ORM对PO进行了封装） </p><p>概念：</p><ul><li><strong>VO（View Object）</strong>：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</li><li><strong>DTO（Data Transfer Object）</strong>：数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。</li><li><strong>DO（Domain Object）</strong>：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</li><li><strong>PO（PersistentObject）</strong>：持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。 </li></ul><p>模型：</p><p> 下面以一个时序图建立简单模型来描述上述对象在三层架构应用中的位置 </p><ul><li><p>用户发出请求（可能是填写表单），表单的数据在展示层被匹配为VO。</p></li><li><p>展示层把VO转换为服务层对应方法所要求的DTO，传送给服务层。 l 服务层首先根据DTO的数据构造（或重建）一个DO，调用DO的业务方法完成具体业务。 </p></li><li>服务层把DO转换为持久层对应的PO（可以使用ORM工具，也可以不用），调用持久层的持久化方法，把PO传递给它，完成持久化操作。</li><li><p>对于一个逆向操作，如读取数据，也是用类似的方式转换和传递，略。</p><p>三、项目中的实体类</p></li></ul><p>项目中常见的实体类有VO，DO和DTO，命名规则也常是以相应字符串结尾，如VO.Java。</p><p>但是DTO不总是遵循这个规则，而通常与他的用途有关，如写成Query.java，表示存储了一个查询条件。</p><p>项目中实体类出现的业务层次也没有这么严格，例如我们可以在视图层就组装一个DO，也可以将一个VO从持久层传出来，所以与业务分层相关联的划分方法显得有些冗余。</p><p>从项目代码中抽象出的理解是：VO对应于页面上需要显示的数据，DO对应于数据库中存储的数据，DTO对应于除二者之外需要进行传递的数据。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;经常会接触到VO，DO，DTO的概念，本文从领域建模中的实体划分和项目中的实际应用情况两个角度，对这几个概念进行简析 🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>WebMvcConfigurerAdapter在Spring5.0中被弃用</title>
    <link href="https://uncleaaron.github.io/Blog/JavaWeb/WebMvcConfigurerAdaptor%E5%9C%A8Spring5.0%E8%A2%AB%E5%BC%83%E7%94%A8/"/>
    <id>https://uncleaaron.github.io/Blog/JavaWeb/WebMvcConfigurerAdaptor在Spring5.0被弃用/</id>
    <published>2018-07-17T12:41:09.000Z</published>
    <updated>2018-07-27T14:59:34.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>今天用Sping Boot2.0.3写项目编写WebMvc的JavaConfig时，发现WebMvcConfigurerAdapter已经被标注弃用，便去找了下Spring的API，发现官方开始推荐<strong>直接实现WebMvcConfigurer接口</strong>的方式来配置SpringMVC。（原因在Java8接口默认方法替代了原来适配器的作用）🖊 </p></blockquote><a id="more"></a><h2 id="在SpringBoot2-0及Spring-5-0-WebMvcConfigurerAdapter已被废弃，目前找到解决方案就有两种"><a href="#在SpringBoot2-0及Spring-5-0-WebMvcConfigurerAdapter已被废弃，目前找到解决方案就有两种" class="headerlink" title="在SpringBoot2.0及Spring 5.0 WebMvcConfigurerAdapter已被废弃，目前找到解决方案就有两种"></a>在SpringBoot2.0及Spring 5.0 WebMvcConfigurerAdapter已被废弃，目前找到解决方案就有两种</h2><hr><h3 id="1-直接实现WebMvcConfigurer-（官方推荐）"><a href="#1-直接实现WebMvcConfigurer-（官方推荐）" class="headerlink" title="1. 直接实现WebMvcConfigurer （官方推荐）"></a>1. 直接实现WebMvcConfigurer （官方推荐）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfg</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-直接继承WebMvcConfigurationSupport"><a href="#2-直接继承WebMvcConfigurationSupport" class="headerlink" title="2. 直接继承WebMvcConfigurationSupport"></a>2. 直接继承WebMvcConfigurationSupport</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfg</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebMvcConfigurerAdapter的官方api描述"><a href="#WebMvcConfigurerAdapter的官方api描述" class="headerlink" title="WebMvcConfigurerAdapter的官方api描述"></a>WebMvcConfigurerAdapter的官方api描述</h3><p>WebMvcConfigurerAdapter – Deprecated.<br>as of 5.0 WebMvcConfigurer has default methods (made possible by a Java 8 baseline) and can be implemented directly without the need for this adapter.<br>An implementation of WebMvcConfigurer with empty methods allowing subclasses to override only the methods they’re interested in.</p><blockquote><p>Java8中WebMvcConfigurer实现了默认方法，不需要这个适配器了。</p><p>因为WebMvcConfigurer接口实现了默认方法，使用者可以自由实现想配置的方法</p></blockquote><p>解释：</p><p>在Java8以前，因为实现接口的时候每个接口方法必须需要实现，所以导致编写JavaConfig配置类很困难，不能自由选择配置类，所以Spring5.0以前用一个适配器抽象类实现了WebMvcConfigurer的所有方法（但其实都是空的），这样可以满足用户可以选择自己需要的配置功能进行选择性配置，而不需要全部实现。</p><p>而现在Java8提供了接口默认实现方法，接口的默认方法完全替代了这个适配器类的目的，可以满足仅在接口层面用户就能选择自己想实现的方法，没有实现的方法就用默认方法代替，原来的适配器就多余了。因此推荐第一种方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;今天用Sping Boot2.0.3写项目编写WebMvc的JavaConfig时，发现WebMvcConfigurerAdapter已经被标注弃用，便去找了下Spring的API，发现官方开始推荐&lt;strong&gt;直接实现WebMvcConfigurer接口&lt;/strong&gt;的方式来配置SpringMVC。（原因在Java8接口默认方法替代了原来适配器的作用）🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
      <category term="Java 开发问题总结" scheme="https://uncleaaron.github.io/Blog/tags/Java-%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="Spring" scheme="https://uncleaaron.github.io/Blog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>使SpringMVC支持跨域访问的几种解决方法</title>
    <link href="https://uncleaaron.github.io/Blog/JavaWeb/%E4%BD%BFSpringMVC%E6%94%AF%E6%8C%81%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://uncleaaron.github.io/Blog/JavaWeb/使SpringMVC支持跨域访问的几种解决方法/</id>
    <published>2018-07-17T12:41:09.000Z</published>
    <updated>2018-07-21T14:48:33.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>由于最近又开始写博客，刚好碰到的开发问题都重新总结一下。</p><p>今天在写Controller的时候又想起<strong>跨域访问</strong>支持的问题，在这里总结一下我以前用过的方法🖊 </p></blockquote><a id="more"></a><h1 id="1-在Controller类或方法上加入-CrossOrigin注解"><a href="#1-在Controller类或方法上加入-CrossOrigin注解" class="headerlink" title="1. 在Controller类或方法上加入@CrossOrigin注解"></a>1. 在Controller类或方法上加入@CrossOrigin注解</h1><p><strong>@CrossOrigin</strong>有两个参数</p><p>origins：允许访问的域列表</p><p>maxAge：飞行前响应的缓存持续时间的最大年龄（以秒为单位） </p><h2 id="1-1-使方法支持跨域访问"><a href="#1-1-使方法支持跨域访问" class="headerlink" title="1.1. 使方法支持跨域访问"></a>1.1. 使方法支持跨域访问</h2><p>在方法上加<strong><code>@CrossOrigin</code></strong>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/crossDomain2"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">crossDomain2</span><span class="params">(HttpServletRequest req, HttpServletResponse res, String name)</span></span>&#123;</span><br><span class="line">    ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-使Controller类支持跨域访问"><a href="#1-2-使Controller类支持跨域访问" class="headerlink" title="1.2. 使Controller类支持跨域访问"></a>1.2. 使Controller类支持跨域访问</h2><p>在类上添加<strong><code>@CrossOrigin</code></strong>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="meta">@CrossOrigin</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;  </span><br><span class="line">    ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-重写WebMvcConfigurerAdapter-addCorsMapping方法"><a href="#2-重写WebMvcConfigurerAdapter-addCorsMapping方法" class="headerlink" title="2. 重写WebMvcConfigurerAdapter.addCorsMapping方法"></a>2. 重写WebMvcConfigurerAdapter.addCorsMapping方法</h1><ol><li>写一个Conroller的基类Cors，继承<strong><code>WebMvcConfigurerAdapter</code></strong>类，并重写<strong><code>addCorsMappings(CorsRegistry)</code></strong>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cors</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">        .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">        .allowedMethods(<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"OPTIONS"</span>, <span class="string">"DELETE"</span>, <span class="string">"PATCH"</span>)</span><br><span class="line">          .allowCredentials(<span class="keyword">true</span>).maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实现的Controller继承这个基类Cors</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStarter</span> <span class="keyword">extends</span> <span class="title">Cors</span> </span>&#123;<span class="comment">//继承了刚才实现的WebMvcConfigurerAdapter的子类Cors，从而实现支持跨域访问</span></span><br><span class="line">    <span class="comment">// 省略具体方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-直接拦截在header上加入响应头"><a href="#3-直接拦截在header上加入响应头" class="headerlink" title="3. 直接拦截在header上加入响应头"></a>3. 直接拦截在header上加入响应头</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>); <span class="comment">//自定义中间件，设置跨域需要的响应头。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;由于最近又开始写博客，刚好碰到的开发问题都重新总结一下。&lt;/p&gt;
&lt;p&gt;今天在写Controller的时候又想起&lt;strong&gt;跨域访问&lt;/strong&gt;支持的问题，在这里总结一下我以前用过的方法🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
      <category term="Java 开发问题总结" scheme="https://uncleaaron.github.io/Blog/tags/Java-%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2.x中静态资源会被自定义拦截器拦截</title>
    <link href="https://uncleaaron.github.io/Blog/JavaWeb/SpringBoot2.x%E4%B8%AD%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AF%B9%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>https://uncleaaron.github.io/Blog/JavaWeb/SpringBoot2.x中拦截器对静态资源的影响/</id>
    <published>2018-07-17T12:41:09.000Z</published>
    <updated>2018-07-28T19:09:19.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>今天用Sping Boot2.0.3写项目编写WebMvc的JavaConfig时，SpringBoot2.x中静态资源会被自定义拦截器拦截，研究了大半天，总结一下我的方法，若有更好的方法欢迎讨论，向大佬们学习一下🖊 </p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置视图映射(页面跳转)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">"/index.html"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">        registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">        registry.addViewController(<span class="string">"/main.html"</span>).setViewName(<span class="string">"dashboard"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置拦截器</span></span><br><span class="line"><span class="comment">     * SpringBoot-2.x和Spring5.0的静态资源也会执行自定义的拦截器，因此在配置拦截器的时候需要指定排除静态资源的访问路径</span></span><br><span class="line"><span class="comment">     * 因此配置拦截器的时候还要拦截静态资源的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LoginHandleInterceptor()).addPathPatterns(<span class="string">"/**"</span>)    <span class="comment">// 拦截全局路径请求，下为放行某些url的请求</span></span><br><span class="line">                .excludePathPatterns(<span class="string">"/"</span>, <span class="string">"/index.html"</span>, <span class="string">"/user/login"</span>, <span class="string">"/resources/**"</span>);    <span class="comment">// 1. 注意这个/resources/**是我自定义的资源路径 2. 不要拦截需要请求的路径，比如这里的/user/login</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义静态资源URL</span></span><br><span class="line"><span class="comment">     * 使用了自定义拦截器后SpringBoot2.x的静态资源也会使用这个拦截器，</span></span><br><span class="line"><span class="comment">     * 而且好像屏蔽了自动配置的静态资源Handlers设置，</span></span><br><span class="line"><span class="comment">     * 上面的拦截器移除似乎需要这个方法进行解释路径url，之后才能在拦截器里才能使用这些url。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 在这里注册了一个静态资源url为/resources/**，但是这样的话，每个静态资源前面都需要加上/resources/前缀</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">"/resources/**"</span>).addResourceLocations(<span class="string">"classpath:/META-INF/resources/"</span>, <span class="string">"classpath:/static/"</span>, <span class="string">"classpath:/resources/"</span>, <span class="string">"classpath:/public/"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>  <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Signin Template for Bootstrap<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap core CSS --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意这里路径因为上面的WebMvcCOnfig类中设置了静态资源定位URL，为/resources/开头，所以要加上/resource/ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/css/bootstrap.min.css"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/resources/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Custom styles for this template --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/css/signin.css"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/resources/css/signin.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-signin"</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/user/login&#125;"</span> <span class="attr">th:method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"mb-4"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/resources/images/bootstrap-solid.svg&#125;"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"72"</span> <span class="attr">height</span>=<span class="string">"72"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"h3 mb-3 font-weight-normal"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.tips&#125;"</span>&gt;</span>Please sign in<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 错误消息提示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: red;"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;msg&#125;"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not #strings.isEmpty(msg)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"inputEmail"</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"inputEmail"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"Username"</span> <span class="attr">th:placeholder</span>=<span class="string">"#&#123;login.username&#125;"</span> <span class="attr">required</span> <span class="attr">autofocus</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"inputPassword"</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"inputPassword"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"Password"</span> <span class="attr">th:placeholder</span>=<span class="string">"#&#123;login.password&#125;"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"checkbox mb-3"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"remember-me"</span>&gt;</span> [[#&#123;login.remember&#125;]]</span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-lg btn-primary btn-block"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.btn&#125;"</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"mt-5 mb-3 text-muted"</span>&gt;</span>&amp;copy; 2017-2018<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/index.html(l='zh_CN')&#125;"</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/index.html(l='en_US')&#125;"</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;今天用Sping Boot2.0.3写项目编写WebMvc的JavaConfig时，SpringBoot2.x中静态资源会被自定义拦截器拦截，研究了大半天，总结一下我的方法，若有更好的方法欢迎讨论，向大佬们学习一下🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
      <category term="Java 开发问题总结" scheme="https://uncleaaron.github.io/Blog/tags/Java-%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="Spring" scheme="https://uncleaaron.github.io/Blog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Linux程序设计</title>
    <link href="https://uncleaaron.github.io/Blog/Linux/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://uncleaaron.github.io/Blog/Linux/Linux程序设计/</id>
    <published>2018-06-16T16:05:10.000Z</published>
    <updated>2018-07-17T02:20:53.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>简单总结了Shell脚本设计，C in Linux 的编程和编译，以及GTK+的简单原理</p></blockquote><a id="more"></a><h1 id="Shell程序设计"><a href="#Shell程序设计" class="headerlink" title="Shell程序设计"></a>Shell程序设计</h1><h2 id="bash程序执行步骤"><a href="#bash程序执行步骤" class="headerlink" title="bash程序执行步骤"></a>bash程序执行步骤</h2><ol><li>编辑保存<code>vi</code></li><li>赋可执行权限<code>chmod</code></li><li><code>./filename.sh</code>执行</li></ol><h2 id="bash程序结构"><a href="#bash程序结构" class="headerlink" title="bash程序结构"></a>bash程序结构</h2><p># file.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash****Shell类型****</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释</span></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">funn</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....<span class="comment"># 主过程</span></span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量=值<span class="comment"># "="两边不能留空格</span></span><br></pre></td></tr></table></figure><p>变量都会被默认成字符串</p><h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><p>用户自定义变量要加<code>$</code>，加<code>{}</code>可以同其他字符分开（建议添加）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;xxx&#125;</span></span><br></pre></td></tr></table></figure><h4 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h4><p><strong>会替换</strong><code>$</code><strong>变量</strong>成值。参数中包含空格也要用双引号。</p><h4 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h4><p><strong>字符串</strong>值，不会替换<code>$</code>变量</p><h4 id="倒引号"><a href="#倒引号" class="headerlink" title="倒引号 "></a>倒引号 <code></code></h4><p><strong>替换命令</strong>为其执行结果</p><h3 id="特定变量"><a href="#特定变量" class="headerlink" title="特定变量"></a>特定变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$@</span><span class="comment"># 参数列表（数组）</span></span><br><span class="line">$*<span class="comment"># 参数列表（字符串）</span></span><br><span class="line"><span class="variable">$#</span><span class="comment"># 参数个数</span></span><br><span class="line"><span class="variable">$n</span><span class="comment"># 位置参数$1，$2，$3...$n</span></span><br><span class="line"><span class="variable">$0</span><span class="comment"># 本脚本文件名</span></span><br><span class="line">$$<span class="comment"># 本程序进程号</span></span><br><span class="line">$?<span class="comment"># 上一条命令或函数的返回值</span></span><br><span class="line"><span class="variable">$HOME</span><span class="comment"># 用户主目录</span></span><br></pre></td></tr></table></figure><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><h3 id="expr-命令"><a href="#expr-命令" class="headerlink" title="expr 命令"></a>expr 命令</h3><p>计算算术表达式，支持 <code>+</code>、<code>-</code>、<code>\*</code>、<code>/</code>、<code>%</code>（<em>要<code></code>\</em><code></code>进行转移，否则会错误）</p><p>支持<code>|</code>，<code>&amp;</code>，<code>&gt;</code>，<code>&gt;=</code>，<code>!=</code>，<code>=</code>等逻辑运算，<code>|</code>,<code>&gt;</code>,<code>&lt;</code>要用<code>\</code>转义才能使用</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr arg</span><br></pre></td></tr></table></figure><p>数字符 和 符号 间要<strong>空格</strong></p><p>要改变运算次序的话需要使用<code></code>倒引号</p><figure class="highlight plain"><figcaption><span>`expr 5 \* 7` + 5```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### let 命令</span><br><span class="line"></span><br><span class="line">**语法**：给a赋值（语法中**不用空格**！）</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">let a=(5+7)/3</span><br></pre></td></tr></table></figure><h3 id="…-运算"><a href="#…-运算" class="headerlink" title="$((…))运算"></a>$((…))运算</h3><p>直接运算得出结果</p><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $((5+7))</span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p><strong>0真，1假</strong>（与熟知C语言判断相反）</p><p><strong>语法：</strong>注意！<strong>中括号</strong>两边<strong>要空格</strong>！！！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 条件判断语句 ]</span><br></pre></td></tr></table></figure><p><strong>多重条件判断组合</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-a<span class="comment"># 与</span></span><br><span class="line">-o<span class="comment"># 或</span></span><br><span class="line">!<span class="comment"># 非</span></span><br></pre></td></tr></table></figure><p><strong>算术比较：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a -eq b<span class="comment"># 相等（equal）</span></span><br><span class="line">a -ne b<span class="comment"># 不相等（not equal）</span></span><br><span class="line">a -gt b<span class="comment"># a大于b（greater then）</span></span><br><span class="line">a -ge b<span class="comment"># a大于等于b（greater equal）</span></span><br><span class="line">a -lt b<span class="comment"># a小于b（less then）</span></span><br><span class="line">a -le b<span class="comment"># a小于或等于b（less equal）</span></span><br><span class="line">!expr<span class="comment"># 假则真，真则假</span></span><br></pre></td></tr></table></figure><p><strong>字符比较：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = s2<span class="comment"># 字符串相同</span></span><br><span class="line">s1 != s2<span class="comment"># 字符串不同</span></span><br><span class="line">-n str1<span class="comment"># 字符串不为空</span></span><br><span class="line">-z str1<span class="comment"># 字符串为空</span></span><br></pre></td></tr></table></figure><p><strong>文件判断</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-d file<span class="comment"># 是目录</span></span><br><span class="line">-e file<span class="comment"># 存在</span></span><br><span class="line">-f file<span class="comment"># 是文件</span></span><br></pre></td></tr></table></figure><h3 id="if-分支语句"><a href="#if-分支语句" class="headerlink" title="if 分支语句"></a>if 分支语句</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">elif</span> [ 条件2 ]; <span class="keyword">then</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="case-模式匹配-分支语句"><a href="#case-模式匹配-分支语句" class="headerlink" title="case 模式匹配 分支语句"></a>case 模式匹配 分支语句</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 条件1 <span class="keyword">in</span></span><br><span class="line">模式n)</span><br><span class="line">命令n</span><br><span class="line">;;</span><br><span class="line">*)<span class="comment">#default</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p><strong>模式匹配配对符：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?<span class="comment"># 任意一个字符</span></span><br><span class="line">*<span class="comment"># 任意字符串</span></span><br><span class="line">[]<span class="comment"># 括号中的任意字符</span></span><br><span class="line">[!]<span class="comment"># 不在括号中的任意字符</span></span><br><span class="line">&#123;c1,c2&#125;<span class="comment"># 和c1或者c2匹配都可</span></span><br></pre></td></tr></table></figure><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 [<span class="keyword">in</span> 列表]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>可用 <code>in 1,2,3,4...</code>或者默认使用<code>in $@</code>。其中<code>$@</code>是参数数组</p><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>/until [ 条件 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">function</span>] 函数名()&#123;</span><br><span class="line">    命令</span><br><span class="line">    [<span class="built_in">return</span> xx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果最后不使用return返回，函数返回的就是最后一条命令的返回值</li></ul><h1 id="C-in-Linux"><a href="#C-in-Linux" class="headerlink" title="C in Linux"></a>C in Linux</h1><h2 id="gcc编译过程"><a href="#gcc编译过程" class="headerlink" title="gcc编译过程"></a>gcc编译过程</h2><p><img src="/Blog/Linux/Linux程序设计/gcc编译过程.png" alt="gcc编译过程"></p><h2 id="gcc命令"><a href="#gcc命令" class="headerlink" title="gcc命令"></a>gcc命令</h2><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc [选项] [filename]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c<span class="comment"># 编译.c文件生成.o文件，不生成可执行文件</span></span><br><span class="line">-o filename<span class="comment"># 指定生成文件名称为filename。不设这个选项则默认为filename.xx（根据编译阶段生成后缀文件）</span></span><br><span class="line">-Idir<span class="comment"># 在编译时增加搜索头文件的目录</span></span><br><span class="line">-Ldir<span class="comment"># 在编译时增加搜索库的目录</span></span><br><span class="line">-lname<span class="comment"># 在编译时装在名为libname.a的函数库，需要存在于系统预设目录或-L设置的目录。</span></span><br><span class="line">-g<span class="comment"># 加入调试信息</span></span><br><span class="line">-E<span class="comment"># 生成.i预处理文件</span></span><br><span class="line">-S<span class="comment"># 生成.s汇编文件</span></span><br></pre></td></tr></table></figure><p>总结：在编译过程中。除非使用了”-c”，“-S”,或”-E”选项(或者编译错误阻止了完整的过程)，否则统一完整链接步骤。 </p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><strong>分步编译</strong></p><p>先用<code>-c</code>,<code>-S</code>,<code>-E</code>中断编译过程，生成中间文件，再用<code>gcc 中间文件</code>完成编译</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br><span class="line">gcc -c say_hello.c -o say_hello.o</span><br><span class="line">gcc hello.o say_hello.o -o hello</span><br></pre></td></tr></table></figure><p><strong>一步编译</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c say_hello.c -o hello</span><br></pre></td></tr></table></figure><p><strong>使用<code>-Idirname</code>增加搜索头文件目录</strong></p><p>示例：</p><p>当前目录为./hello.c    ./functions/say_hello.h    ./functions/say_hello.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c <span class="built_in">functions</span>/say_hello.c -o hello -Ifunctions</span><br></pre></td></tr></table></figure><h2 id="make-软件维护工具"><a href="#make-软件维护工具" class="headerlink" title="make 软件维护工具"></a>make 软件维护工具</h2><h3 id="makefile文件"><a href="#makefile文件" class="headerlink" title="makefile文件"></a>makefile文件</h3><p><strong>格式：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">目标文件: 依赖项列表</span></span><br><span class="line">命令</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>依赖项可以不写.h文件，但一定要写清.c文件的路径</p><p>示例：</p><p>当前目录为./hello.c    ./functions/say_hello.h    ./functions/say_hello.c</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:hello.o say_hello.o</span></span><br><span class="line">gcc hello.o say_hello.o -o hello</span><br><span class="line"><span class="section">hello.o:hello.c say_hello.h</span></span><br><span class="line">gcc -c hello.c -o hello.o -Ifunctions</span><br><span class="line"><span class="section">say_hello.o:functions/say_hello.c</span></span><br><span class="line">gcc -c functions/say_hello.c -o say_hello.o -Ifunctions</span><br></pre></td></tr></table></figure><p>makefile可以使用变量宏命令<code>${}</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CC=-Wall-c</span><br><span class="line"><span class="section">hello:$&#123;CC&#125;</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><h3 id="使用makefile"><a href="#使用makefile" class="headerlink" title="使用makefile"></a>使用makefile</h3><p>在存放makefile文件的目录下使用：<code>make</code></p><h2 id="调试工具-gdb"><a href="#调试工具-gdb" class="headerlink" title="调试工具 gdb"></a>调试工具 gdb</h2><ol><li>设置断点</li><li>监视变量</li><li>单步执行</li><li>修改变量值</li></ol><p><strong>进入gdb：</strong><code>gdb</code></p><h3 id="使用gdb"><a href="#使用gdb" class="headerlink" title="使用gdb"></a>使用gdb</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file<span class="comment"># 装入可执行文件</span></span><br><span class="line">list<span class="comment"># 查看源代码</span></span><br><span class="line">quit<span class="comment"># 退出gdb</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行程序</span></span><br><span class="line"><span class="built_in">break</span> &lt;line&gt;<span class="comment"># 设置断点</span></span><br><span class="line">next<span class="comment"># 单步执行</span></span><br><span class="line">step<span class="comment"># 单步执行到函数内部</span></span><br><span class="line">run<span class="comment"># 执行程序</span></span><br><span class="line"><span class="built_in">kill</span><span class="comment"># 终止正在调试的程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视变量</span></span><br><span class="line">watch<span class="comment"># 监视变量</span></span><br><span class="line"><span class="built_in">print</span><span class="comment"># 打印变量</span></span><br></pre></td></tr></table></figure><h2 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h2><h3 id="静态函数库"><a href="#静态函数库" class="headerlink" title="静态函数库"></a>静态函数库</h3><p><strong>库文件名</strong>：<code>libxxxxx.a</code></p><p>静态函数库文件比较大，因为整个函数库的所有代码都会被整合编译到目标代码中，所以使用静态库编译后的程序不需要外部函数库支持，因为都已经编译进去了。但是如果今天函数库改变了就需要重新编译。</p><p><strong>创建</strong></p><p>编译生成.o文件：<code>gcc -c pr1.c pr2.c</code></p><p>链接静态库：<code>ar -rsv libpr.a pr1.o pr2.o</code></p><p><strong>使用</strong></p><p>加载库文件编译：<code>gcc -o main main.c -L./ -lpr</code></p><h3 id="动态函数库"><a href="#动态函数库" class="headerlink" title="动态函数库"></a>动态函数库</h3><p><strong>库文件名：</strong><code>libxxxx.so</code></p><p>动态函数库在编译时没有被编译进目标代码中，当程序执行到时才会调用函数里的相应函数。所以使用动态函数库产生的可执行文件较小。</p><p><strong>创建</strong></p><p>生成动态库：<code>gcc -fpic -shared -o libpr.so pr1.c pr2.c</code></p><p><strong>使用</strong></p><p>调用动态库：<code>gcc -o main_so main.c ./libpr.so</code></p><h1 id="GTK"><a href="#GTK" class="headerlink" title="GTK+"></a>GTK+</h1><h2 id="GTK-控件"><a href="#GTK-控件" class="headerlink" title="GTK+控件"></a>GTK+控件</h2><p><strong>GtkWidget</strong>：GTK控件的父类，所有控件按照此类型返回</p><p>创建控件：<code>GtkWidget * gtk_xxxx_new(GtkNodeType type 或者 void)</code></p><p>设置xxx：<code>void gtk_xxx_set_xxx(GtkNode *xxx, XX message)</code></p><p>读取xxx：<code>xx gtk_xxx_get_xxx(GtkNode *xxx)</code></p><p>存放进窗体：<code>gtk_container_add(GTK_CONTAINER(windowxx), xxxx)</code></p><p>显示窗体：<code>gtk_widget_show_all(window)</code></p><p>界面布局采用横向<code>hbox</code>和纵向<code>vbox</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    GtkWidget *window, *button;<span class="comment">//声明window和button为GtkWidget，后面使用需要类型转换</span></span><br><span class="line">    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);<span class="comment">// 初始化window变量为GTK....类型</span></span><br><span class="line">    gtk_window_set_title(GTK_WINDOW(window), <span class="string">"HELLO WORLD"</span>);<span class="comment">//这里用的大写是类型转换</span></span><br><span class="line">    button = gtk_button_new_with_label(<span class="string">"Hello World"</span>);<span class="comment">// 初始化button变量为button类型</span></span><br><span class="line">    gtk_container_add(GTK_CONTAINER(window)， button)<span class="comment">//类型转换成Container，button放入window</span></span><br><span class="line">    gtk_widget_show_all(window);</span><br><span class="line">    gtk_main();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调函数、信号"><a href="#回调函数、信号" class="headerlink" title="回调函数、信号"></a>回调函数、信号</h2><p>GTK+用信号（signal）和回调函数（callback）处理外部事件。</p><h3 id="信号与回调函数绑定"><a href="#信号与回调函数绑定" class="headerlink" title="信号与回调函数绑定"></a>信号与回调函数绑定</h3><p>采用<code>g_signal_connect</code>函数来完成信号和回调函数绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g_signal_connect(gpointer *object,<span class="comment">// 连接信号的对象</span></span><br><span class="line">                <span class="keyword">const</span> gchar *name,<span class="comment">// 信号名</span></span><br><span class="line">                Gcallback func,<span class="comment">// 回调函数名</span></span><br><span class="line">                gpointer user_data)<span class="comment">// 回调函数参数的指针</span></span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数的<strong>函数原型</strong>（用户自己定义）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback_func</span><span class="params">(GtkWidget *widget,<span class="comment">// 发出信号的控件的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">              gpointer callback_data)</span><span class="comment">// 传递进函数的数据</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;简单总结了Shell脚本设计，C in Linux 的编程和编译，以及GTK+的简单原理&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Vi</title>
    <link href="https://uncleaaron.github.io/Blog/Linux/Vim%E7%AE%80%E6%98%93%E7%AC%94%E8%AE%B0/"/>
    <id>https://uncleaaron.github.io/Blog/Linux/Vim简易笔记/</id>
    <published>2018-06-11T06:37:58.000Z</published>
    <updated>2018-07-16T11:46:30.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>总结了Vi的使用</p></blockquote><a id="more"></a><p><img src="/Blog/Linux/Vim简易笔记/Vi.png" alt="Vi"></p><h2 id="末行模式（进出、搜索、替换）"><a href="#末行模式（进出、搜索、替换）" class="headerlink" title="末行模式（进出、搜索、替换）"></a>末行模式（进出、搜索、替换）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:w<span class="comment"># 保存</span></span><br><span class="line">:w filename<span class="comment"># 另存为</span></span><br><span class="line">:q<span class="comment"># 退出</span></span><br><span class="line">:q!<span class="comment"># 退出不保存</span></span><br><span class="line">:wq<span class="comment"># 退出保存</span></span><br><span class="line">:x<span class="comment"># 加密保存</span></span><br></pre></td></tr></table></figure><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/&lt;pattern&gt;<span class="comment"># 从光标向下搜索</span></span><br><span class="line">?&lt;pattern&gt;<span class="comment"># 从光标向上搜索</span></span><br></pre></td></tr></table></figure><p>n：向下遍历光标</p><p>N：向上遍历光标</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>(:s/x/y普通替换本行第一个。最后加/g替换本行全部 , :%s/x/y 替换全部行第一个，这基础上加/g替换全文)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:s/old/new<span class="comment"># 替换本行首次出现的old</span></span><br><span class="line">:s/old/new/g<span class="comment"># 替换本行全部</span></span><br><span class="line">:%s/old/new/g<span class="comment"># 替换全文（全部行全部）</span></span><br><span class="line">:n,m s/old/new/g<span class="comment">#替换n-m行的全部old</span></span><br></pre></td></tr></table></figure><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><table><thead><tr><th style="text-align:center">h</th><th style="text-align:center">j</th><th style="text-align:center">k</th><th style="text-align:center">l</th></tr></thead><tbody><tr><td style="text-align:center">左</td><td style="text-align:center">下</td><td style="text-align:center">上</td><td style="text-align:center">右</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">k j h l<span class="comment"># 上下左右</span></span><br><span class="line">0<span class="comment"># 行首</span></span><br><span class="line">^<span class="comment"># 行首</span></span><br><span class="line">$<span class="comment"># 行尾</span></span><br><span class="line">w<span class="comment"># 下一个字首</span></span><br><span class="line">b<span class="comment"># 当前字首，已经在字首则到上个字首</span></span><br><span class="line">e<span class="comment"># 当前字尾，已经在字尾则到下个字尾</span></span><br><span class="line">nw<span class="comment"># 右移n字</span></span><br><span class="line">nb<span class="comment"># 左移n字</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">H<span class="comment"># 当前屏幕最顶端（Highest）</span></span><br><span class="line">nH<span class="comment"># 当前屏第n行</span></span><br><span class="line">gg<span class="comment"># 文首</span></span><br><span class="line">G<span class="comment"># 文末</span></span><br><span class="line">n+<span class="comment"># 后跳n行</span></span><br><span class="line">n-<span class="comment"># 前跳n行</span></span><br><span class="line">nG<span class="comment"># 跳到第n行</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="comment"># 本句首</span></span><br><span class="line">)<span class="comment"># 下一句首</span></span><br><span class="line">&#123;<span class="comment"># 本段首</span></span><br><span class="line">&#125;<span class="comment"># 本段末</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+b<span class="comment"># 向上翻一页(back)</span></span><br><span class="line">Ctrl+f<span class="comment"># 向下翻一页（front）</span></span><br><span class="line">Ctrl+u<span class="comment"># 向前翻半页（up）</span></span><br><span class="line">Ctrl+d<span class="comment"># 向下翻半页（down）</span></span><br></pre></td></tr></table></figure><h2 id="编辑指令"><a href="#编辑指令" class="headerlink" title="编辑指令"></a>编辑指令</h2><h3 id="删除（x-d）"><a href="#删除（x-d）" class="headerlink" title="删除（x, d）"></a>删除（x, d）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x<span class="comment"># 删除字符</span></span><br><span class="line">nx<span class="comment"># 删除从光标开始的n个字符</span></span><br><span class="line">dd<span class="comment"># 删除行</span></span><br><span class="line">ndd<span class="comment">#删除包括当前行的n行</span></span><br></pre></td></tr></table></figure><h3 id="复制（y）"><a href="#复制（y）" class="headerlink" title="复制（y）"></a>复制（y）</h3><p>可配合光标移动使用（w, n, ^, $）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yy<span class="comment">#当前行复制</span></span><br><span class="line">nyy<span class="comment">#n行复制</span></span><br><span class="line">yw<span class="comment">#复制到到字胃</span></span><br><span class="line">nyw<span class="comment">#复制光标及其后的n个单词</span></span><br><span class="line">y^<span class="comment">#复制光标到行首</span></span><br><span class="line">y$<span class="comment">#复制光标到行尾</span></span><br></pre></td></tr></table></figure><h3 id="粘贴（p）"><a href="#粘贴（p）" class="headerlink" title="粘贴（p）"></a>粘贴（p）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p<span class="comment"># 光标后粘贴</span></span><br><span class="line">P<span class="comment"># 光标前粘贴</span></span><br></pre></td></tr></table></figure><h3 id="撤销（u）"><a href="#撤销（u）" class="headerlink" title="撤销（u）"></a>撤销（u）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u<span class="comment"># 撤销一步</span></span><br><span class="line">U<span class="comment"># 撤销本行操作(其实是增加了全局操作，会被u撤销)</span></span><br></pre></td></tr></table></figure><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> nu<span class="comment"># 显示行号</span></span><br><span class="line">:<span class="built_in">set</span> nonu<span class="comment"># 取消显示行号</span></span><br><span class="line">:nu<span class="comment"># 取得该行行号</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Vim编辑异常退出后，会无法正常进行编辑，这时候就要删除一个同名的.swap文件，即可编辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;总结了Vi的使用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux总结</title>
    <link href="https://uncleaaron.github.io/Blog/Linux/Linux%E6%80%BB%E7%BB%93/"/>
    <id>https://uncleaaron.github.io/Blog/Linux/Linux总结/</id>
    <published>2018-06-06T16:05:10.000Z</published>
    <updated>2018-07-31T07:48:52.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>根据自己的记忆和理解方式，总结了最近学习和接触到的Linux理论和指令。</p><p>涉及Linux目录，文件管理，系统，设备管理，进程管理，网络管理，用户管理等。</p><p>（此外，Vi使用 以及 Shell脚本编写在别篇）</p></blockquote><a id="more"></a><h1 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h1><h2 id="linux内核版本号"><a href="#linux内核版本号" class="headerlink" title="linux内核版本号"></a>linux内核版本号</h2><p>x.y.zz（y次版本号，偶数稳定版，奇数发展版）</p><h2 id="Linux目录"><a href="#Linux目录" class="headerlink" title="Linux目录"></a>Linux目录</h2><table><thead><tr><th>目录</th><th>功能</th><th>助记</th></tr></thead><tbody><tr><td>/bin</td><td>常用系统程序目录</td><td>binary</td></tr><tr><td>/boot</td><td>开技设定目录</td><td>boot</td></tr><tr><td>/dev</td><td>系统设备装置文件目录</td><td>device  /dev/null 垃圾箱</td></tr><tr><td>/etc</td><td>系统配置文件，尤其是passwd，shadow文件</td><td>Edit Text Configuration</td></tr><tr><td>/home</td><td>系统使用者的目录</td><td></td></tr><tr><td>/lib</td><td>Linux执行或编译程序函数库的目录</td><td>Libary</td></tr><tr><td>/mnt</td><td>软驱和光驱接入挂载的地方</td><td></td></tr><tr><td>/proc</td><td>系统核心与程序的一些信息</td><td></td></tr><tr><td>/tmp</td><td>临时文件目录</td><td>Temporary 临时的</td></tr><tr><td>/sbin</td><td>系统管理员常用指令集和程序</td><td></td></tr><tr><td>/usr</td><td>/usr/sbin 系统管理员的管理程序和指令<br>/usr/bin 一般执行文件摆放的地方</td><td></td></tr><tr><td>/var</td><td>摆放系统日志文件</td></tr></tbody></table><h1 id="系统启动或关闭"><a href="#系统启动或关闭" class="headerlink" title="系统启动或关闭"></a>系统启动或关闭</h1><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>暂时更改系统运行级别</p><p><strong>权限：</strong>root</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init [0123456]</span><br></pre></td></tr></table></figure><p><strong>重要参数</strong></p><p>0：关机级别</p><p>1：单用户运行级别</p><p>2：多用户</p><p>3：多用户，字符模式</p><p>4：用户自定义</p><p>5：图形界面</p><p>6：重启</p><hr><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>关闭或重启系统</p><p><strong>权限：</strong>root</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown [选项] [时间] [警告信息]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-r: shutdown之后重启</span><br><span class="line">-h: 关机后不重启</span><br></pre></td></tr></table></figure><p><strong>时间：</strong>now 或者 +时间值</p><hr><h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><p>关闭系统和关闭电源</p><p><strong>权限：</strong>所有用户</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p: 关闭计算机后再关闭电源</span><br></pre></td></tr></table></figure><hr><h1 id="用户和组管理"><a href="#用户和组管理" class="headerlink" title="用户和组管理"></a>用户和组管理</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>超级用户：UID 0    （默认为root）</p><p>系统用户：UID 100以下</p><p>普通用户：UID 500+</p><p>/etc/passwd：账号文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaron:x:1002:1002:aaron:/home/aaron:/bin/bash</span><br><span class="line">用户名:加密密码:用户ID:组ID:用户信息:用户主目录:登陆Shell</span><br><span class="line">（默认创建用户下，GID会和UID相同）</span><br></pre></td></tr></table></figure><p>/etc/shadow：口令文件</p><p>/etc/group：用户组信息文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaron:x:500:a1,a2</span><br><span class="line">组名:密码:GID:用户列表（逗号分隔）</span><br></pre></td></tr></table></figure><hr><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>添加用户</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [选项] [参数] &lt;newUsername&gt;</span><br></pre></td></tr></table></figure><p><strong>选项/参数：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d: 指定主目录(directory)</span><br><span class="line">-u: 指定UID(UID)</span><br><span class="line">-g: 指定用户组(group)</span><br><span class="line">-G: 指定用户组列表(Groups)</span><br><span class="line">-s: 指定Shell(Shell)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># useradd aaron</span></span><br></pre></td></tr></table></figure><p>默认条件下：系统自动分配一个500以上的UID和GID，默认创建一个与UID同名的GID组，默认在home目录下创建同名文件夹为主目录。</p><hr><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>修改密码（root可以修改所有的密码，普通用户只能修改自己的密码）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [选项] &lt;Username&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><p>修改用户属性</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod [选项] [参数] &lt;Username&gt;</span><br></pre></td></tr></table></figure><p><strong>选项/参数：</strong>（同useradd）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d: 指定主目录(directory)</span><br><span class="line">-u: 指定UID(UID)</span><br><span class="line">-g: 指定用户组(group)</span><br><span class="line">-G: 指定用户组列表(Groups)</span><br><span class="line">-s: 指定Shell(Shell)</span><br></pre></td></tr></table></figure><hr><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><p>删除用户</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel [选项] &lt;Username&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-r: 删除用户的同时删除主目录</span><br></pre></td></tr></table></figure><hr><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><hr><h3 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h3><p>添加用户组</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd [选项] &lt;GroupName&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g: 设定组ID</span><br><span class="line">-r: 添加系统组(GID小于500)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 501 worker</span><br></pre></td></tr></table></figure><hr><h3 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h3><p>修改组属性</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod [选项] &lt;GroupName&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g GID：设定组ID</span><br><span class="line">-n &lt;GroupName&gt;: 设定新组名</span><br></pre></td></tr></table></figure><hr><h2 id="账号查看"><a href="#账号查看" class="headerlink" title="账号查看"></a>账号查看</h2><hr><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>显示系统中有哪些用户正在使用</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-u: 显示详细的用户状态</span><br><span class="line">-H: 显示表头</span><br><span class="line">-a: 显示所有用户</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ who -uH</span><br><span class="line">NAME     LINE         TIME             IDLE          PID COMMENT</span><br><span class="line">aaron    pts/0        2018-06-07 11:35   .         21837 (125.88.24.125)</span><br></pre></td></tr></table></figure><hr><h3 id="w"><a href="#w" class="headerlink" title="w"></a>w</h3><p>显示系统中用户使用情况，是who的增强版</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w [选项] [user]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s: 简短模式</span><br><span class="line">user: 指定用户</span><br></pre></td></tr></table></figure><hr><h3 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h3><p>显示当前用户名</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><hr><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>显示用户信息</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g: 只显示GID</span><br><span class="line">-u: 只显示UID</span><br></pre></td></tr></table></figure><hr><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>切换用户身份</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [选项] [username]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-l: 同时切换用户主目录</span><br><span class="line">-: 同时切换环境变量</span><br><span class="line">-m: 保留环境变量</span><br></pre></td></tr></table></figure><hr><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>以root身份执行指令</p><p><strong>权限：</strong>在 /etc/sudoers 中有出现的使用者</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">command</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>/etc/shells: 查看系统支持的shell</p><p>一般shell都在/bin/xxx目录下（xx为shell名，例如/bin/bash ）</p><p>root 提示符# 其他用户提示符$</p><h1 id="输入-输出重定向"><a href="#输入-输出重定向" class="headerlink" title="输入/输出重定向"></a>输入/输出重定向</h1><h2 id="文件描述符（0-1-2）"><a href="#文件描述符（0-1-2）" class="headerlink" title="文件描述符（0, 1, 2）"></a>文件描述符（0, 1, 2）</h2><p><strong>0：标准输入</strong></p><p><strong>1：标准输出</strong></p><p><strong>2：标准错误输出</strong></p><h2 id="重定向控制符"><a href="#重定向控制符" class="headerlink" title="重定向控制符"></a>重定向控制符</h2><p><strong>&lt; 文件</strong> ：输入重定向控制符，输入内容从文件获取</p><p><strong>> 文件</strong>：输出重定向控制符（覆盖）</p><p><strong>>> 文件</strong>：输出重定向控制符（追加）</p><h2 id="重定向高级用法"><a href="#重定向高级用法" class="headerlink" title="重定向高级用法"></a>重定向高级用法</h2><ul><li>文件描述符[0,1,2] 重定向控制符[&gt;,&lt;,&lt;&lt;] 文件</li></ul><p>例：重定向标准输出到文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> xxx 1&gt;文件</span><br></pre></td></tr></table></figure><hr><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><strong>符号：</strong><code>&quot;|&quot;</code></p><p>用于连接进程，通过管道连接的进程可以同时运行，并且随着数据流在她们之间传递可以自动地进行协调。</p><hr><h1 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h1><h2 id="文件权限属性"><a href="#文件权限属性" class="headerlink" title="文件权限属性"></a>文件权限属性</h2><p><img src="/Blog/Linux/Linux总结/文件权限属性.png" alt="文件权限属性"></p><p>文件类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-：普通文件</span><br><span class="line">d：目录</span><br><span class="line">l：链接文件</span><br><span class="line">p：管道文件</span><br></pre></td></tr></table></figure><p>权限码（rwx）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r = 4<span class="comment"># 读</span></span><br><span class="line">w = 2<span class="comment"># 写</span></span><br><span class="line">x = 1<span class="comment"># 执行</span></span><br><span class="line">- = 0<span class="comment"># 无权限</span></span><br></pre></td></tr></table></figure><hr><h2 id="文件-目录-属性操作"><a href="#文件-目录-属性操作" class="headerlink" title="文件/目录/属性操作"></a>文件/目录/属性操作</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>显示指定目录下的目录和文件</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [选项] 目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a：显示隐藏文件（<span class="string">"."</span>开头）</span><br><span class="line">-l：列出文件详细信息</span><br><span class="line">-S：以文件大小排序</span><br><span class="line">-t：以时间排序</span><br><span class="line">-i：显示索引节点</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">-drwxr-xr-x1rootroot969May2917:02dir1</span><br><span class="line">文件权限:链接数:拥有者:所属组:文件大小(B):修改日期:文件名</span><br></pre></td></tr></table></figure><hr><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>切换工作目录</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 目录名</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ : 用户主目录</span><br><span class="line">. : 当前目录</span><br><span class="line">.. : 父目录</span><br><span class="line">- : 返回上一次目录</span><br></pre></td></tr></table></figure><hr><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>查看当前工作目录</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><hr><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建目录</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项] 目录</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-p：确保目录名称存在，不存在则创建一个</span><br><span class="line">-m：在创建目录的同时设置目录的权限</span><br></pre></td></tr></table></figure><hr><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>删除<strong>空目录</strong></p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p：当子目录被删除后也成为空目录时，也一并删除</span><br></pre></td></tr></table></figure><hr><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>用于修改文件的时间属性，包括存取时间和更改时间。<strong>若文件不存在，系统会建立一个新的文件</strong> </p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [选项] 文件1 [文件2...]</span><br></pre></td></tr></table></figure><p>不加选项的话修改时间记录为当前系统时间</p><hr><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p><strong>删除</strong>文件或目录（删除目录要 -r）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] 文件名或目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r：递归删除目录一下文件</span><br><span class="line">-i：交互模式，删除前逐一询问（interactive）</span><br><span class="line">-f：强制模式，即使属性为只读，也直接删除，无需逐一确认（force）</span><br></pre></td></tr></table></figure><hr><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p><strong>复制</strong>文件或目录（目录用 -a）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [选项] 源文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a：复制目录时使用，保留链接、文件属性，且递归复制目录下所有内容，相当于-pdr</span><br><span class="line">-p：复制属性</span><br><span class="line">-d：复制链接的话，只复制链接而非期文件</span><br><span class="line">-r：递归复制目录</span><br><span class="line">-i：覆盖之前询问</span><br><span class="line">-f：覆盖且不询问</span><br></pre></td></tr></table></figure><hr><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p><strong>移动</strong>或<strong>更名</strong>指定的文件或目录</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [选项] 源文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure><p><strong>mv参数设置与运行结果：</strong></p><table><thead><tr><th>命令格式</th><th>运行结果</th></tr></thead><tbody><tr><td>mv  文件名  文件名</td><td>将源文件名改为目标文件名</td></tr><tr><td>mv  文件名  目录名</td><td>移动文件到目录</td></tr><tr><td>mv  目录名  目录名</td><td>目标目录存在，将源目录移动到目标目录<br>目标目录不存在，则改名</td></tr><tr><td>mv  目录名  文件名</td><td>错误</td></tr></tbody></table><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-i：交互模式，覆盖询问</span><br><span class="line">-f：强制模式，覆盖不提示</span><br></pre></td></tr></table></figure><hr><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>从指定目录开始递归查找文件，并可以对其进行操作</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 起始目录 &lt;选项查找条件&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-name &lt;name&gt;：正则匹配字符串（-iname 忽略大小写）</span><br><span class="line">-<span class="built_in">type</span> &lt;d/c/b/p/f/l/s&gt;：文件类型</span><br><span class="line">-ls：详细列出所找到的文件</span><br><span class="line">-<span class="built_in">exec</span>：执行期间不询问；用&#123;&#125;表示找到的文件，对其进行命令操作，命令末尾必须以 <span class="string">"\;"</span> 结束</span><br><span class="line">-ok：同<span class="built_in">exec</span>，但会询问。</span><br><span class="line">-size &lt;n&gt;：文件大小是n，可用b，c（char），k(kB)表示</span><br><span class="line">对查询条件做逻辑运算：</span><br><span class="line">-a：与</span><br><span class="line">-o：或</span><br><span class="line">！：非</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># find ~ -name &quot;test*&quot; -ls -exec rm &#123;&#125; \;</span><br><span class="line">393291    0 -rw-rw-r--   1 aaron    aaron           0 Jun  8 13:40 /home/aaron/test3</span><br><span class="line">393290    0 -rw-rw-r--   1 aaron    aaron           0 Jun  8 13:40 /home/aaron/test2</span><br><span class="line">393236    0 -rw-rw-r--   1 aaron    aaron           0 Jun  8 13:40 /home/aaron/test1</span><br></pre></td></tr></table></figure><hr><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>为源文件创建一个链接，但不复制源文件</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [选项] 源对象 目的对象</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s：进行软链接</span><br><span class="line">不用-s：进行硬链接</span><br></pre></td></tr></table></figure><p><strong>硬链接</strong>：文件的副本（别名），同时两者存在连接关系，<strong>修改其中一个另一个也会一同被修改，删除一个，另一个不受影响</strong>。两者在<strong>硬盘上只有一份数据</strong>，只存在于同一个文件系统中。</p><p><strong>软链接</strong>：<strong>一个快捷方式</strong>，是一个内容指向另一个文件位置的特殊文件。删了源文件就没用了。可以跨越文件系统。</p><p>个人理解：</p><p><img src="/Blog/Linux/Linux总结/硬链接和软链接图示.png" alt="硬链接和软链接图示"></p><hr><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>改变目录或文件的权限</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [选项] &lt;mode&gt; &lt;文件名或目录&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R：递归对目录下的所有子文件与子目录进行相同的权限变更</span><br></pre></td></tr></table></figure><p><strong>权限修改：</strong></p><ol><li>用数字修改</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4:r</span><br><span class="line">2:w</span><br><span class="line">1:x</span><br><span class="line">例如775就是rwxrwxr-x</span><br><span class="line">示例：chmod 775 file.txt</span><br></pre></td></tr></table></figure><ol start="2"><li>用指令修改权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u：所有者user</span><br><span class="line">g：组group</span><br><span class="line">o：其他other</span><br><span class="line">+：增加权限</span><br><span class="line">-：取消权限</span><br><span class="line">示例：chmod g+w,o+w,o-r file.txt</span><br></pre></td></tr></table></figure><hr><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>改变指定目录或文件(用-R)的所属用户、所属组</p><p><strong>权限：</strong>root</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [选项] 用户名[：组名] 文件或目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R：递归对子文件或目录操作</span><br></pre></td></tr></table></figure><hr><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>改变文件/目录的所属组</p><p><strong>权限：</strong>所有使用者</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [选项] 组名 文件或目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R：递归对子文件或目录操作</span><br></pre></td></tr></table></figure><hr><h2 id="文字显示-文件操作"><a href="#文字显示-文件操作" class="headerlink" title="文字显示/文件操作"></a>文字显示/文件操作</h2><hr><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>显示文件内容</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-n：显示行号</span><br></pre></td></tr></table></figure><hr><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>分页显示文件内容</p><p>b上一页，空格下一页，回车下一行，</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [选项参数] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项参数：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&lt;数字&gt;：指定每屏显示的行数</span><br><span class="line">+&lt;数字&gt;：从指定数字的行开始显示</span><br><span class="line">-c：不进行滚屏操作。每次刷新这个屏幕</span><br><span class="line">-s：将多个空行压缩成一行</span><br></pre></td></tr></table></figure><hr><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>分页显示文件内容，与more十分相似，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。more读的时候会全部加载，而less部分加载，所以less有时候会更快。</p><p>PageUp键上翻页，PageDown向下翻。Q键退出。 </p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [选项] 文件</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n：显示行号</span><br><span class="line">-s：多个空行压缩成一行</span><br></pre></td></tr></table></figure><hr><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>显示文件前N行内容或前N个字节，默认为前10行</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [选项] 文件</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-n&lt;数字&gt; ：显示前N行</span><br><span class="line">-c&lt;数字&gt; ：显示前N个字节</span><br><span class="line">-v：同时显示文件名</span><br></pre></td></tr></table></figure><hr><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>显示文件后N行内容或前N个字节，默认为前10行</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [选项] 文件</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-n&lt;数字&gt; ：显示后N行</span><br><span class="line">-c&lt;数字&gt; ：显示后N个字节</span><br><span class="line">-v：同时显示文件名</span><br></pre></td></tr></table></figure><hr><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>从文件中过滤或提取特定内容并显示</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-d&lt;分隔符&gt;：指定分隔符号（可用引号包起来）</span><br><span class="line">-f&lt;list&gt;：指定提取的列（可以是-f1，也可以是 -f2-5，-f2,4 这样的范围）</span><br><span class="line">-c&lt;list&gt;：仅显示行中指定范围的字符</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost text]<span class="comment"># cut -f2,4 -d";" test.txt </span></span><br><span class="line">Name Mark</span><br><span class="line">tom 69</span><br><span class="line">jack 71</span><br><span class="line">alex 68</span><br></pre></td></tr></table></figure><hr><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>（wordcount）统计一个文件多少字/字节/行</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c：只显示字节Bytes数；（char（字节)）</span><br><span class="line">-l：只显示列数；（line）</span><br><span class="line">-w：只显示字数。（word）</span><br><span class="line">无参数默认统计行、字、字节数</span><br></pre></td></tr></table></figure><hr><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>对输出的内容进行排序（不改变文件）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r：反向排序(reverse)</span><br><span class="line">-n：数字排序（number）</span><br><span class="line">-f：不区分大小写</span><br></pre></td></tr></table></figure><hr><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>显示文字</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> [选项] 字符串</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n：最后不换行</span><br><span class="line">-e：输出一个空行</span><br></pre></td></tr></table></figure><hr><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p>日历显示</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal [选项] [[月] 年]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无参数则本月日历</span><br><span class="line">-y：显示今年日历</span><br><span class="line">-m：周一为第一天</span><br></pre></td></tr></table></figure><hr><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>显示系统时间 或 设定系统时间</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date [选项] [+format]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-d &lt;dateStr&gt;：显示 字符串所指的日期与时间。字符串须加双引号；</span><br><span class="line">-s &lt;dateStr&gt;：设置 字符串表示的日期与时间。字符串须加双引号；</span><br></pre></td></tr></table></figure><p><strong>日期格式字符串列表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">%H 小时，24小时制（00~23）</span><br><span class="line">%I 小时，12小时制（01~12）</span><br><span class="line">%k 小时，24小时制（0~23）</span><br><span class="line">%l 小时，12小时制（1~12）</span><br><span class="line">%M 分钟（00~59）</span><br><span class="line">%p 显示出AM或PM</span><br><span class="line">%r 显示时间，12小时制（hh:mm:ss %p）</span><br><span class="line">%s 从1970年1月1日00:00:00到目前经历的秒数</span><br><span class="line">%S 显示秒（00~59）</span><br><span class="line">%T 显示时间，24小时制（hh:mm:ss）</span><br><span class="line">%X 显示时间的格式（%H:%M:%S）</span><br><span class="line">%Z 显示时区，日期域（CST）</span><br><span class="line">%a 星期的简称（Sun~Sat）</span><br><span class="line">%A 星期的全称（Sunday~Saturday）</span><br><span class="line">%b 月的简称（Jan~Dec）</span><br><span class="line">%B 月的全称（January~December）</span><br><span class="line">%c 日期和时间（Tue Nov 20 14:12:58 2012）</span><br><span class="line">%d 一个月的第几天（01~31）</span><br><span class="line">%x,%D 日期（mm/dd/yy）</span><br><span class="line">%j 一年的第几天（001~366）</span><br><span class="line">%m 月份（01~12）</span><br><span class="line">%w 一个星期的第几天（0代表星期天）</span><br><span class="line">%W 一年的第几个星期（00~53，星期一为第一天）</span><br><span class="line">%y 年的最后两个数字（00-99）</span><br><span class="line">%Y 完整年份(0000-9999)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>格式化输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date +<span class="string">"%Y-%m-%d"</span></span><br><span class="line">2009-12-07</span><br></pre></td></tr></table></figure><p>设置时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date -s 20120523               //设置成20120523，这样会把具体时间设置成空00:00:00</span><br><span class="line">date -s 01:01:01               //设置具体时间，不会对日期做更改</span><br><span class="line">date -s <span class="string">"01:01:01 2012-05-23"</span>  //这样可以设置全部时间</span><br></pre></td></tr></table></figure><hr><p>###grep</p><p>行搜索工具</p><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v<span class="comment"># 不包含</span></span><br></pre></td></tr></table></figure><hr><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>对标准输入的字符进行替换、压缩和删除 </p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr [选项] 字符串1 字符串2</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-d<span class="comment"># 删除字符1中出现的输入字符</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tr <span class="string">'a-z'</span> <span class="string">'A-Z'</span> &lt; works.txt</span><br><span class="line">LINUX</span><br><span class="line">UNIX</span><br><span class="line">MAC OS</span><br><span class="line"></span><br><span class="line">$ cat works.txt | tr <span class="string">"abc"</span> <span class="string">"xyz"</span></span><br><span class="line">Linux</span><br><span class="line">Unix</span><br><span class="line">Mxz OS</span><br></pre></td></tr></table></figure><hr><h2 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] 目录或文件</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-zcvf<span class="comment"># 压缩</span></span><br><span class="line">-zxvf<span class="comment"># 解压</span></span><br><span class="line">-z<span class="comment"># 用gzip压缩/解压(.gz)</span></span><br><span class="line">-c<span class="comment"># 打包（create）</span></span><br><span class="line">-x<span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><hr><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>压缩：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip File</span><br></pre></td></tr></table></figure><p><strong>解压：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d file.gz</span><br></pre></td></tr></table></figure><hr><h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><p>解压zip文件</p><p><strong>解压：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -x File.zip</span><br></pre></td></tr></table></figure><hr><h2 id="联机、帮助指令"><a href="#联机、帮助指令" class="headerlink" title="联机、帮助指令"></a>联机、帮助指令</h2><p>获取命令的帮助</p><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man [选项] 命令或配置文件</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ls</span><br></pre></td></tr></table></figure><hr><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info &lt;命令名&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> [命令名]</span><br></pre></td></tr></table></figure><hr><h3 id="–help参数"><a href="#–help参数" class="headerlink" title="–help参数"></a>–help参数</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;命令&gt; --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><hr><h2 id="文本格式转换"><a href="#文本格式转换" class="headerlink" title="文本格式转换"></a>文本格式转换</h2><h3 id="unix2dos-dos2unix"><a href="#unix2dos-dos2unix" class="headerlink" title="unix2dos, dos2unix"></a>unix2dos, dos2unix</h3><table><thead><tr><th>系统</th><th>换行符</th></tr></thead><tbody><tr><td>windows</td><td>^M^J<br>(回车换行)</td></tr><tr><td>Linux</td><td>^J<br>(换行)</td></tr></tbody></table><h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="磁盘设备描述"><a href="#磁盘设备描述" class="headerlink" title="磁盘设备描述"></a>磁盘设备描述</h2><p>前两个字母：设备类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hd<span class="comment"># IDE硬盘</span></span><br><span class="line">sd<span class="comment"># SCSI硬盘(U盘)</span></span><br></pre></td></tr></table></figure><p>第三个字母：设备编号</p><p>数字：分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sda2：第1块SCSI硬盘的第1个分区</span><br><span class="line">sdb1：第2块SCSI硬盘的第1个分区</span><br></pre></td></tr></table></figure><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ol><li><p><strong>FAT</strong></p><p>早期<strong>Windows</strong>的文件系统</p></li><li><p><strong>NTFS</strong></p><p>目前<strong>Windows</strong>普遍的文件系统</p></li><li><p><strong>Ext</strong></p><p><strong>Linux</strong>引入的可扩展文件系统</p></li><li><p><strong>VFS</strong></p><p><strong>Linux的虚拟文件系统</strong>，（接口层），屏蔽不同的文件系统，实现对各种文件系统的支持。</p></li></ol><h2 id="fdisk-l"><a href="#fdisk-l" class="headerlink" title="fdisk -l"></a>fdisk -l</h2><p>查看本机硬盘及分区情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x0008de3e</span><br><span class="line"></span><br><span class="line">Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048    83884031    41940992   83  Linux</span><br></pre></td></tr></table></figure><h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p>挂载设备</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [选项] 设备名 挂载点</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-t &lt;文件系统类型&gt;</span><br><span class="line">-o &lt;选项&gt; 如ro, rw, auto, iocharset等</span><br></pre></td></tr></table></figure><h2 id="挂载过程"><a href="#挂载过程" class="headerlink" title="挂载过程"></a>挂载过程</h2><ol><li><strong>获取设备名</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">查看设备名</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>建立挂载点目录</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/目录名</span><br><span class="line">建立mnt目录下的挂载点</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>mount 命令挂载</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount 设备名 挂载点</span><br></pre></td></tr></table></figure><h2 id="umount-卸载设备命令"><a href="#umount-卸载设备命令" class="headerlink" title="umount 卸载设备命令"></a>umount 卸载设备命令</h2><p>卸载挂载的设备</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount 挂载点/设备名</span><br></pre></td></tr></table></figure><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="mkfs"><a href="#mkfs" class="headerlink" title="mkfs"></a>mkfs</h3><p>格式化硬盘分区（创建文件系统）(mkFileSystem)</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t 文件系统 设备名</span><br></pre></td></tr></table></figure><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>查看磁盘使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [选项]</span><br></pre></td></tr></table></figure><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>统计目录或文件所占磁盘空间大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [选项] 目录名</span><br></pre></td></tr></table></figure><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><p><strong>交互进程：</strong>由Shell启动的进程</p><p><strong>守护进程：</strong>在后台运行的进程</p><p><strong>批处理进程：</strong>管理进程的序列</p><p>进程的属性：PID, PPID(父进程ID), UID, GID, 状态, 优先级, 资源占用</p><p>杀终止父进程会连带终止子进程</p><p>系统的第一个进程init(PID=1)（所有进程的父进程）</p><h2 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h2><h3 id="手工启动线程"><a href="#手工启动线程" class="headerlink" title="手工启动线程"></a>手工启动线程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxx &amp;<span class="comment"># 后台运行程序加"&amp;"</span></span><br></pre></td></tr></table></figure><h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><p>指定时间执行命令序列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at [选项] TIME</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-l<span class="comment"># 列出所有作业（可以使用atq）</span></span><br><span class="line">-d<span class="comment"># 删除作业（可以使用atrm）</span></span><br></pre></td></tr></table></figure><hr><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>显示瞬间进程动态（另外，top指令可以动态监控进程）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e<span class="comment"># 显示所有进程</span></span><br><span class="line">-a<span class="comment"># 显示所有进程，包括其他用户的进程</span></span><br><span class="line">-x<span class="comment"># 显示所有控制终端的进程</span></span><br></pre></td></tr></table></figure><hr><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><p>以树状结构显示系统中的所有进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree [选项] [PID|User]</span><br></pre></td></tr></table></figure><p>可以指定显示指定PID的信息 或 指定User的进程信息</p><hr><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>结束进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-s signal] PID</span><br><span class="line"><span class="built_in">kill</span> -l<span class="comment"># 列出所有可用的信号</span></span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-s signal<span class="comment"># 指定信号。重启(1)，强制杀死(9)，结束(10)</span></span><br></pre></td></tr></table></figure><hr><h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><p>查看后台进程</p><h3 id="ctrl-Z"><a href="#ctrl-Z" class="headerlink" title="ctrl+Z"></a>ctrl+Z</h3><p>挂起当前线程</p><h3 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h3><p>前台执行进程</p><p><code>fg PID</code></p><h3 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h3><p>后台执行进程</p><hr><h2 id="crontab-周期性执行程序"><a href="#crontab-周期性执行程序" class="headerlink" title="crontab 周期性执行程序"></a>crontab 周期性执行程序</h2><p>周期性执行程序</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] &#123;-l | -r | -e&#125;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e<span class="comment"># 编辑时程表</span></span><br><span class="line">-r<span class="comment"># 删除目前时程表</span></span><br><span class="line">-l<span class="comment"># 列出目前时程表</span></span><br></pre></td></tr></table></figure><h3 id="crontab文件编写"><a href="#crontab文件编写" class="headerlink" title="crontab文件编写"></a>crontab文件编写</h3><p><strong>格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1 f2 f3 f4 f5 program</span><br><span class="line">m, h, d-M, M-y, d-W program</span><br><span class="line">分钟 小时 月中的天 月 周中的天 program</span><br></pre></td></tr></table></figure><p><strong>特殊格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="comment"># 每个时间点都要执行</span></span><br><span class="line">a-b<span class="comment"># a-b时间点内都要执行</span></span><br><span class="line">*/n<span class="comment"># 每n个时间点都要执行1次</span></span><br><span class="line">a,b,c<span class="comment"># 第a,b,c,个时间点要执行</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每个月每天的12点都要执行wall hello</span><br><span class="line">0 12 * * * wall hello</span><br><span class="line">在12月内，每天早上6点到12点中的每3个小时，每个20分钟执行一次command</span><br><span class="line">*/20 6-12/3 * 12 * command</span><br></pre></td></tr></table></figure><hr><h1 id="系统监视"><a href="#系统监视" class="headerlink" title="系统监视"></a>系统监视</h1><h2 id="系统监视指令"><a href="#系统监视指令" class="headerlink" title="系统监视指令"></a>系统监视指令</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>动态监视进程和信息指令（进化版的ps）</p><p><strong>操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">space<span class="comment"># 刷新</span></span><br><span class="line">h<span class="comment"># 帮助</span></span><br><span class="line">k<span class="comment"># 杀死某进程</span></span><br><span class="line">u<span class="comment"># 显示指定用户</span></span><br><span class="line">P<span class="comment"># 按CPU使用情况排序</span></span><br><span class="line">q<span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>内存查看命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-b<span class="comment"># B字节单位显示</span></span><br><span class="line">-k<span class="comment"># KB单位</span></span><br><span class="line">-m<span class="comment"># MB单位</span></span><br></pre></td></tr></table></figure><h2 id="日志监视"><a href="#日志监视" class="headerlink" title="日志监视"></a>日志监视</h2><p>日志存放于/var/log目录下</p><h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p><strong>1. BIOS初始化</strong></p><p>加载和引导设备，启动操作系统</p><p><strong>2. 内核初始化</strong></p><ol><li>硬件设备检测</li><li>设备驱动初始化</li><li>只读挂载文件系统</li><li>启动第一个进程init（PID=1，所有进程的父进程，失去父进程的子进程都以init作为父进程）</li></ol><p><strong>3. 确定系统运行级别</strong></p><p>init读取配置文件<strong>/etc/inittab</strong></p><p>修改系统默认运行级别：修改其中数字</p><p><code>id:5:initdefault</code></p><p><strong>4. 运行初始化脚本</strong></p><p><strong>5. 运行用户自定义脚本</strong></p><p>修改/etc/rc.d/rc.local</p><p><strong>6. 激活控制台</strong></p><p><strong>7. 启动界面</strong></p><h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><h2 id="网络设置文件"><a href="#网络设置文件" class="headerlink" title="网络设置文件"></a>网络设置文件</h2><table><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td>/etc/hosts</td><td>域名或主机名与IP的映射文件。本机查询DNS</td></tr><tr><td>/etc/sysconfig/network-scripts/ifcfg-ethN</td><td>ethN网卡的配置信息</td></tr><tr><td>/etc/sysconfig/network</td><td>最基本的网络配置信息，系统启动时读取</td></tr><tr><td>/etc/resolv.conf</td><td>域名服务器配置文件</td></tr><tr><td>/etc/host.conf</td><td>域名解析的配置文件，指定如何解析</td></tr><tr><td>/etc/services</td><td>网络服务和端口的映射文件，设定主机不同端口号的网络服务</td></tr><tr><td>/etc/protocols</td><td>描述网络协议及其对应协议号</td></tr></tbody></table><h2 id="网络管理命令"><a href="#网络管理命令" class="headerlink" title="网络管理命令"></a>网络管理命令</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>查看或配置网卡状态</p><p><strong>查看状态：</strong><code>ifconfig</code></p><p><strong>查看单独显卡状态：</strong><code>ifconfig eth0</code></p><p><strong>停止</strong>显卡：<code>down</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure><p><strong>激活</strong>显卡： <code>up</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 dp</span><br></pre></td></tr></table></figure><p><strong>设置</strong>设备<strong>IP地址和子网掩码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig &lt;设备名&gt; &lt;IP&gt; netmask &lt;掩码&gt;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong><code>ifconfig eth0 192.168.0.17 netmask 255.255.255.0</code></p><p>以上修改都是临时性的（永久的修改需要修改<code>/etc/sysconfig/network-scripts/ifcfg-ethN</code>文件修改）</p><hr><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>测试网络是否联通。</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [选项] 地址</span><br></pre></td></tr></table></figure><hr><h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>显示数据包到主机之间的路径</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute [选项] 地址</span><br></pre></td></tr></table></figure><hr><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p>显示路由表 / 添加删除路由记录</p><p>显示路由表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route</span><br></pre></td></tr></table></figure><p>添加|删除网关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route &lt;add|del&gt; default gw 网关IP</span><br></pre></td></tr></table></figure><p>添加 | 删除路由记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route &lt;add|del-net&gt; 网络号 netmask 掩码 dev 设备名</span><br></pre></td></tr></table></figure><hr><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>显示网络状态（端口开放情况）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i<span class="comment"># 列出每个显卡</span></span><br></pre></td></tr></table></figure><hr><h2 id="网络服务管理"><a href="#网络服务管理" class="headerlink" title="网络服务管理"></a>网络服务管理</h2><h3 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h3><p>检查和设置系统的各种服务</p><p>添加/删除指定的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add|del 服务名</span><br></pre></td></tr></table></figure><p>显示所有或指定的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list [服务名]</span><br></pre></td></tr></table></figure><p>检查指定服务的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig 服务名</span><br></pre></td></tr></table></figure><p>改变服务运行级别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig [--level 运行级别(3/4/5)] 服务名 状态(on/off/reset)</span><br></pre></td></tr></table></figure><hr><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>对系统服务管理（启动、停止、重启、查看状态）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service 服务名 [start|stop|restart|status]</span><br></pre></td></tr></table></figure><hr><p>chkconfig和service的区别：前者重启后仍然生效，后者不然</p><hr><h2 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h2><ol><li><strong>独立守护进程工作模式：</strong>一个守护进程响应一个特定的端口的服务或连接（每个服务都对应一个守护进程，会导致资源浪费。）(也叫stand-alone模式)</li><li><strong>基于xinetd的工作模式：</strong>xinetd进程同时监听多个端口，在接收请求时根据端口号来启动不同的服务进程处理请求。（流量小开销小，流量大时由于频繁启动服务进程导致性能下降）</li></ol><h3 id="Telnet服务"><a href="#Telnet服务" class="headerlink" title="Telnet服务"></a>Telnet服务</h3><p>远程登陆应用。基于xinetd的服务。</p><p><strong>使用：</strong></p><ol><li>安装krb5-telnet</li><li>编辑/etc/xinetd.d/krb5-telnet配置文件（在此之前可能要改xinetd配置文件/etc/xinetd.conf文件），编辑/etc/securetty文件</li><li>重启服务 <code>service xinetd restart</code></li></ol><p>需要用非root普通用户登陆</p><p><strong>停止：</strong></p><p>关闭xinetd服务（telnet受xinetd管理，所以关闭xinetd即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service xinetd stop</span><br></pre></td></tr></table></figure><hr><h3 id="FTP服务"><a href="#FTP服务" class="headerlink" title="FTP服务"></a>FTP服务</h3><p>FTP文件传输协议，支持standalone模式和xinetd模式。</p><p><strong>配置文件：</strong></p><ol><li>/etc/vsftpd/vsftpd.conf：主配置文件</li><li>/etc/vsftpd.ftpusers：禁用用户列表</li><li>/etc/vsftpd.user_list：</li></ol><p><strong>启动vsFTPd</strong></p><p><code>service vsftpd [start | stop | restart]</code></p><p><strong>需要关闭防火墙</strong></p><p><strong>使用操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lcd<span class="comment"># 切换本机目录</span></span><br><span class="line">get &lt;filename&gt;<span class="comment"># 从FTP下载到本地</span></span><br><span class="line">put &lt;filename&gt;<span class="comment"># 从本地上传到FTP</span></span><br><span class="line">close<span class="comment"># 关闭ftp会话</span></span><br><span class="line">open<span class="comment"># 连接ftp站点</span></span><br><span class="line">quit<span class="comment"># 断开连接并退出</span></span><br></pre></td></tr></table></figure><hr><h3 id="SElinux-访问控制"><a href="#SElinux-访问控制" class="headerlink" title="SElinux 访问控制"></a>SElinux 访问控制</h3><p>在SELinux的访问控制限制下，进程只能访问那些在其任务中所需要的文件。</p><h3 id="www"><a href="#www" class="headerlink" title="www"></a>www</h3><p>web服务，用的是httpd服务</p><p>启动httpd</p><p><code>service httpd [start | stop | restart]</code></p><p><strong>httpd的配置文件：</strong></p><p><strong>/etc/httpd/conf/http.conf</strong></p><hr><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;根据自己的记忆和理解方式，总结了最近学习和接触到的Linux理论和指令。&lt;/p&gt;
&lt;p&gt;涉及Linux目录，文件管理，系统，设备管理，进程管理，网络管理，用户管理等。&lt;/p&gt;
&lt;p&gt;（此外，Vi使用 以及 Shell脚本编写在别篇）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>第5章 Java中的锁</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC5%E7%AB%A0-Java%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java并发编程艺术/第5章-Java中的锁/</id>
    <published>2018-06-06T07:03:00.000Z</published>
    <updated>2018-07-25T11:54:29.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本章总结了Lock接口，队列同步器(<code>AbstractQueuedSynchronizer</code>)，可重用锁<code>ReentrantLock</code></p></blockquote><a id="more"></a><h1 id="第5章-Java中的锁"><a href="#第5章-Java中的锁" class="headerlink" title="第5章 Java中的锁"></a>第5章 Java中的锁</h1><h2 id="一、Lock接口"><a href="#一、Lock接口" class="headerlink" title="一、Lock接口"></a>一、Lock接口</h2><p><strong>显式获取/释放锁</strong>，具有可操作性、<strong>可中断的获取</strong>锁，以及<strong>超时获取锁</strong>等功能。（相比<code>synchronized</code>关键字隐式锁，缺失了点隐式锁的便捷性，但功能可操作性更强。synchronized虽然可以隐式、简化锁管理，但是固化了操作，缺乏可扩展性）</p><p><strong>基本使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">// 声明可重用锁</span></span><br><span class="line">lock.lock();<span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;<span class="comment">// 不要将获取锁卸载try块中，避免异常抛出时被无故释放锁</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();<span class="comment">// 🔺 在finally中释放锁，保证锁获取之后能被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要特性：</strong>（除了普通自旋的获取锁外，其他的特性）</p><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>尝试非阻塞地获取锁</strong></td><td style="text-align:left">当前线程尝试获取锁，如果这一时刻锁没被其他线程占有，则成功获取并持有锁（此方式将只获取依次，在获取时刻内立即返回，不进行自旋）</td></tr><tr><td style="text-align:left"><strong>可被中断地获取锁</strong></td><td style="text-align:left">当获取到锁的线程被中断时，抛出中断异常，并释放锁（与synchronized不同）</td></tr><tr><td style="text-align:left"><strong>超时获取锁</strong></td><td style="text-align:left">在指定时间前获取锁，否则无法获取锁，自动返回</td></tr></tbody></table><p><strong>Lock接口的API：</strong></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><strong>void lock()</strong></td><td><strong>自旋地获取锁</strong>，直到获取后才返回</td></tr><tr><td><strong>void lockInterruptibly() <code>throws InterruptException</code></strong></td><td><strong>可响应中断的获取锁</strong>，在锁获取的过程中可以中断当前线程。</td></tr><tr><td><strong>boolean tryLock()</strong></td><td><strong>尝试非阻塞的获取锁</strong>，<strong>调用后立即返回</strong>，成功获取则返回true，否则返回false</td></tr><tr><td><strong>boolean tryLock(long time, TimeUni unit) <code>throws InterruptException</code></strong></td><td><strong>超时获取锁</strong>，在以下情况返回<br>① 当前线程在超时时间内获取锁<br>② 当前线程在超时时间内被中断<br>③ 超时结束，失败返回false</td></tr><tr><td><strong>void unlock()</strong></td><td><strong>释放锁</strong></td></tr><tr><td><strong>Condition newCondition()</strong></td><td><strong>获取等待通知的组件</strong>，该组件和当前的锁绑定。当前线程只有获得了锁，才能调用该组件的wait() 方法，<strong>调用后，当前线程释放锁。</strong></td></tr></tbody></table><p>Lock接口的实现一般都是通过聚合使用一个同步器<code>AbstracQueuedSynchronizer</code>的子类实现访问控制的。</p><p><img src="/Blog/Java/Java并发编程艺术/第5章-Java中的锁/Lock实现.png" alt="Lock实现"></p><h2 id="二、队列同步器AbstractQueuedSynchronizer"><a href="#二、队列同步器AbstractQueuedSynchronizer" class="headerlink" title="二、队列同步器AbstractQueuedSynchronizer"></a>二、队列同步器AbstractQueuedSynchronizer</h2><p>队列同步器（简称同步器）AbstractQueuedSynchronizer</p><p>是用来<strong>构建锁和同步组件的基本框架</strong>，使用一个<strong>int表示同步状态</strong>，使用一个FIFO<strong>队列完成获取资源的线程的排队</strong>工作。</p><blockquote></blockquote><p>同步器主要使用方式：<strong>继承</strong></p><p><strong>子类继承同步器</strong>定义为自定义同步组件的<strong>静态内部类</strong>，通过调用已提供的方法来<strong>实现其抽象方法</strong>来管理同步状态。</p><p>同步器已经提供了3个方法来访问和修改同步状态供子类使用：</p><ul><li><strong><code>getState()</code>：</strong>获取当前同步状态</li><li><strong><code>setState(int newState)</code>：</strong>设置当前同步状态</li><li><strong><code>compareAndSetState( int expect, int update )</code>：</strong>使用CAS设置当前状态，该方法保证状态设置的原子性</li></ul><p>同步器可重写的方法：（包括独占式获取/释放同步状态）</p><table><thead><tr><th>方法名</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>protected boolean tryAcquire(int arg)</td><td><strong>独占式获取同步状态</strong>。</td><td>实现该方法需要<strong>使用CAS</strong>操作查询是否符合预期后再设置同步状态</td></tr><tr><td>protected boolean tryRelease(int arg)</td><td><strong>独占式释放同步状态。</strong></td><td>等待获取同步状态的线程将有机会获取同步状态</td></tr><tr><td>protected int tryAcquireShared(int arg)</td><td>共享式获取同步状态</td><td>获取成功则返回&gt;=0的值。否则失败</td></tr><tr><td>protected boolean tryReleaseShared(int arg)</td><td>共享式释放同步状态</td><td></td></tr><tr><td>protected boolean isHeldExclusively()</td><td>当前同步器是否线程被独占</td></tr></tbody></table><p>同步器提供的模板方法：</p><p>大致分为3类：</p><ul><li><strong>独占式获取与释放</strong>同步状态：<code>acquire</code>/<code>release</code>（另含<code>aquireInterruptibly</code>响应中断操作和<code>tryAcquireNanos</code>超时等待操作）</li><li><strong>共享式获取与释放</strong>同步状态：<code>acquireShared</code>/<code>releaseShared</code>（另含<code>aquireSharedInterruptibly</code>响应中断操作和<code>tryAcquireSharedNanos</code>超时等待操作）</li><li><strong>查询同步队列中的等待情况</strong>：<code>Collection&lt;Thread&gt; getQueuedThreads()</code></li></ul><h3 id="利用同步器实现的独占锁示例："><a href="#利用同步器实现的独占锁示例：" class="headerlink" title="利用同步器实现的独占锁示例："></a>利用同步器实现的独占锁示例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用静态内部类 实现 自定义同步器</span></span><br><span class="line">    <span class="comment">// 这样就屏蔽了同步器的操作，用户只需要使用Mutex包装同步器的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"><span class="comment">// 是否处于占用状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getState() == <span class="number">1</span>;<span class="comment">// getState()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当状态为0的时候获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">// CAS操作</span></span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());<span class="comment">// 设置拥有者线程</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放锁，将状态设置为0</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span><span class="comment">// 若没有被占用（同步状态为0）则抛出异常</span></span><br><span class="line">IllegalMonitorStateException();</span><br><span class="line">setExclusiveOwnerThread(<span class="keyword">null</span>);<span class="comment">// 否则被占用了，就设置拥有者线程为空</span></span><br><span class="line">setState(<span class="number">0</span>);<span class="comment">// 然后置0同步状态，表示不被占用</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">// 同步器内部类结束</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 仅需要将同步器提供的操作代理到Sync上即可</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();<span class="comment">// 创建一个自定义同步器，用此实现后面的自定义方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;sync.acquire(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;sync.release(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> sync.newCondition();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> sync.isHeldExclusively();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> sync.hasQueuedThreads();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-队列同步器的内部实现"><a href="#2-2-队列同步器的内部实现" class="headerlink" title="2.2. 队列同步器的内部实现"></a>2.2. 队列同步器的内部实现</h3><p>实现机制主要包括：同步队列、独占式同步状态获取和释放、共享式同步状态获取和释放。</p><h4 id="2-2-1-同步队列"><a href="#2-2-1-同步队列" class="headerlink" title="2.2.1. 同步队列"></a>2.2.1. 同步队列</h4><ul><li><p>同步队列是一个<strong>FIFO双向队列</strong>，每个节点保存前驱和后继节点以及对应线程。</p></li><li><p>同步队列存放<strong>获取同步状态失败的线程</strong>。</p></li><li>当同步状态<strong>释放时，唤醒首节点</strong>，后面的节点的唤醒通过前驱节点出队或被中断实现。</li><li><strong>插入队列使用CAS</strong>确保原子性（因为可能会有并发插入场景），而队列头节点<strong>出队不需要CAS</strong>（因为出队只有一个线程能够获取同步状态）。</li><li>节点在同步状态中会自旋检查同步状态，但只有前驱节点是头节点时才能尝试获取同步状态。</li><li>移出队列（停止自旋）的条件是：前驱节点是头节点且成功获取了同步状态。</li></ul><p><img src="/Blog/Java/Java并发编程艺术/第5章-Java中的锁/节点自旋获取同步状态.png" alt="节点自旋获取同步状态"></p><h4 id="2-2-2-独占式获取同步状态"><a href="#2-2-2-独占式获取同步状态" class="headerlink" title="2.2.2. 独占式获取同步状态"></a>2.2.2. 独占式获取同步状态</h4><p>流程：（同一时刻只能有一个线程访问同步状态）</p><p><img src="/Blog/Java/Java并发编程艺术/第5章-Java中的锁/独占式获取同步状态流程.png" alt="独占式获取同步状态流程"></p><h4 id="2-2-3-共享式同步状态："><a href="#2-2-3-共享式同步状态：" class="headerlink" title="2.2.3. 共享式同步状态："></a>2.2.3. 共享式同步状态：</h4><p>同一个时刻能有多个线程同时获取到同步状态（如读写文件时，可多进程同时读1个文件，此时写被阻塞；当文件在写入时，所有读和其他写被阻塞）写为独占，读为共享。</p><ul><li>使用<strong>共享式同步状态</strong>的并发组件<strong>必须使用CAS确保释放资源的原子性</strong></li></ul><h3 id="锁和同步器的关系"><a href="#锁和同步器的关系" class="headerlink" title="锁和同步器的关系"></a>锁和同步器的关系</h3><p>同步器是实现锁的关键。</p><blockquote><p>锁是面向使用者的，定义了使用者和锁之间的接口，隐藏了实现细节。同步器面向锁的实现者，简化锁的实现方式，隐藏了同步状态管理、线程排队、等待唤醒的操作。</p></blockquote><h2 id="三、-重入锁ReentrantLock"><a href="#三、-重入锁ReentrantLock" class="headerlink" title="三、 重入锁ReentrantLock"></a>三、 重入锁ReentrantLock</h2><p><strong>ReentrantLock重入锁</strong>：支持重进入的锁，表示该锁<strong>支持一个线程对资源重复加锁</strong>。有公平性和非公平性选择。</p><p><strong>重进入：**</strong>已经获取到锁的线程能够再次调用lock()而不被锁阻塞。**</p><ul><li>其实synchronized关键字隐式支持了重进入（如synchronized修饰的递归方法）</li></ul><p><strong>公平性：</strong>等待时间最长的线程优先获取锁（请求先到先得<strong>FIFO</strong>，符合请求的绝对时间顺序）</p><p><strong>非公平性：</strong>就是不公平性</p><ul><li>公平虽然能减少“饥饿”，但效率其实没有非公平高，因为会造成大量的线程切换开销代价。</li><li>非公平锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了更大的吞吐量</li></ul><h3 id="实现重进入"><a href="#实现重进入" class="headerlink" title="实现重进入"></a>实现重进入</h3><p>线程再次获取锁：识别当前线程是否为当前占据锁的线程，是则成功获取。</p><p>锁的最终释放：重复n次获取锁后，再释放n次时，其他线程能获取到该锁。</p><h3 id="非公平锁和公平锁的实现细节"><a href="#非公平锁和公平锁的实现细节" class="headerlink" title="非公平锁和公平锁的实现细节"></a>非公平锁和公平锁的实现细节</h3><h4 id="非公平锁的实现细节："><a href="#非公平锁的实现细节：" class="headerlink" title="非公平锁的实现细节："></a>非公平锁的实现细节：</h4><p><strong>获取锁需要CAS</strong>原子操作（非公平情况下会产生并发问题）</p><p><strong>释放锁时不存在并发，不需要CAS</strong></p><p>没有队列上的严格限制</p><h4 id="公平锁的实现细节："><a href="#公平锁的实现细节：" class="headerlink" title="公平锁的实现细节："></a>公平锁的实现细节：</h4><p>多一个判断当前线程是否是头节点，是头节点才能获得锁（严格的FIFO）</p><p><img src="/Blog/Java/Java并发编程艺术/第5章-Java中的锁/重入锁的公平与非公平对比.png" alt=""></p><p>可以看到：公平锁每次都会从队列中的第一个节点获取到锁，大量的线程切换；而非公平锁出现了一个线程连续获取锁的情况。</p><blockquote><p>这是因为当一个线程请求锁时，只要获取了同步状态即成功获取锁，在此前提下，刚释放锁的线程再次获取同步状态的几率很大。</p></blockquote><h2 id="三、读写锁ReentrantReadWriteLock"><a href="#三、读写锁ReentrantReadWriteLock" class="headerlink" title="三、读写锁ReentrantReadWriteLock"></a>三、读写锁ReentrantReadWriteLock</h2><p>读写锁在同一时刻允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。</p><p>读写锁<strong>维护了一对锁，一个读锁和一个写锁</strong>，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。    </p><p>（读写锁能够简化线程交互场景的编程方式，如生产者-消费者）</p><p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。    </p><p>Java提供的ReetrankReadWriteLock有三个特性（其实大概比重入锁多了锁降级）：</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>公平性选择</strong></td><td>支持非公平和公平的锁获取方式</td></tr><tr><td><strong>重进入</strong></td><td>读锁或写锁都支持重进入</td></tr><tr><td><strong>锁降级</strong></td><td><strong>获取写锁–&gt;获取读锁–&gt;释放写锁</strong>，<br>以此完成写锁降级为读锁</td></tr></tbody></table><h3 id="读写锁的接口示例"><a href="#读写锁的接口示例" class="headerlink" title="读写锁的接口示例"></a>读写锁的接口示例</h3><p>ReadWriteLock接口仅定义了读锁和写锁两个方法：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>readLock()</td><td>获取读锁</td></tr><tr><td>writeLock()</td><td>获取写锁</td></tr></tbody></table><p>其实现ReetrantReadWriteLock还提供了外界监控锁状态的方法：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>int getReadLockCount()</td><td>返回当前读锁被获取的次数（不等于获取读锁的线程数）</td></tr><tr><td>int getReadHoldCount()</td><td>返回当前线程获取读锁的次数（参数保存在ThreadLocal中）</td></tr><tr><td>boolean isWriteLocked()</td><td>判断写锁是否被获取</td></tr><tr><td>int getWriteHoldCount()</td><td>返回当前写锁被获取的次数</td></tr></tbody></table><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"><span class="keyword">static</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();<span class="comment">//声明读写锁</span></span><br><span class="line"><span class="keyword">static</span> Lock r = rwl.readLock();<span class="comment">// 获取读锁r</span></span><br><span class="line"><span class="keyword">static</span> Lock w = rwl.writeLock();<span class="comment">// 获取写锁w</span></span><br><span class="line"><span class="comment">// 读方法：获取一个key对应的value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">r.lock();<span class="comment">// 获取读锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">r.unlock();<span class="comment">// 释放读锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写方法：设置key对应的value，并返回旧的value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">w.lock();<span class="comment">// 获取写锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">w.unlock();<span class="comment">// 释放写锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写状态设计"><a href="#读写状态设计" class="headerlink" title="读写状态设计"></a>读写状态设计</h3><p>读写锁使用一个int变量（32位），维护多个读线程和写线程的状态</p><blockquote><p><strong>写状态：</strong>被一个线程重复获取写锁的次数；</p><p><strong>读状态：</strong>是所有线程获取读锁次数的总和</p></blockquote><p>按位切割方法：高16位表示读，低16为表示写（按2进制16位数计算锁获取次数）</p><p>推论：同步状态S不为0时，写状态为0时时，则读状态(S &gt;&gt;&gt; 16) 定大于 0，即读锁被获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读锁被获取判断：((S != <span class="number">0</span>) &amp;&amp; (S &amp; <span class="number">0x0000FFFF</span> == <span class="number">0</span>)) =&gt; ((S &gt;&gt;&gt; <span class="number">16</span>) &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/Blog/Java/Java并发编程艺术/第5章-Java中的锁/读写锁锁状态的划分方式.png" alt="读写锁锁状态的划分方式"></p><h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p><strong>获取写锁–&gt;获取读锁–&gt;释放写锁</strong></p><p><strong>好处：</strong>锁降级是为了保证数据的可见性，如果不是锁降级而是释放写锁再获取读锁，中途可能会被别的线程写打断下一步读。锁降级同时也可以保证其他读线程能获取读锁，达到并发读的目的。</p><h2 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h2><p><code>LockSupport</code>也是构建同步组件的基础工具之一，提供了一组另线程阻塞和唤醒功能的公共静态方法</p><p><strong><code>park(Object blocker)</code> </strong>用于在某对象上阻塞当前线程（此外还有超时等待方法xxNanos和xxxUntil）</p><p><strong><code>unpark(Thread th)</code> </strong>方法唤醒一个被阻塞的线程</p><h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>Condition接口实现的功能与Object监视器的等待/通知机制类似(<strong><code>await/signal - wait/notify</code></strong>)</p><p>Condition是同步器AbstractQueuedSynchronizer的内部类</p><p>调用Condition需要先获取其关联的Lock锁<strong>（一个Condition必须由Lock的newCondition()方法创建出来）</strong> <strong>使用前需获取lock锁</strong></p><p>Condition部分方法：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><strong>void await()</strong> throws InterruptedException</td><td>可被中断地等待，直到被signal通知</td></tr><tr><td>void await<strong>Uninterruptibly()</strong></td><td>不响应中断的等待，直到被signal通知</td></tr><tr><td>long awaitNanos(long nanosTimeOut) throws InterruptedException</td><td>超时等待</td></tr><tr><td>boolean awaitUntil(Date deadline) throws InterruptedException</td><td>等待到某个时间，中途被通知返回true，否则返回false。响应中断</td></tr><tr><td><strong>void signal()</strong></td><td>唤醒一个等待在Condition上的线程，该线程返回前必须获得Condition相关联的锁</td></tr><tr><td><strong>void signalAll()</strong></td><td>唤醒所有等待在Condition上的线程</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReetrantLock();<span class="comment">// 创建锁实例</span></span><br><span class="line">Condition condition = lock.newCondition();<span class="comment">// 获取一个Condition对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();<span class="comment">// 1. 获取锁lock()</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.await();<span class="comment">// 2. 当前线程等待（condition可在获得锁状态下操作）</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">// 3. 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();<span class="comment">// 1. 获得锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.signal();<span class="comment">// 2. 唤醒1个等待在condition上的线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">// 3. 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对比Object监视器和Condition"><a href="#对比Object监视器和Condition" class="headerlink" title="对比Object监视器和Condition"></a>对比Object监视器和Condition</h4><table><thead><tr><th>对比项</th><th>Object Monitor Methods</th><th>Condition</th></tr></thead><tbody><tr><td>前置条件</td><td>获取对象锁(<code>synchronized</code>)</td><td>调用<code>Lock.lock()</code>获取锁<br>调用<code>Lock.newCondition()</code>获取Condition对象</td></tr><tr><td>调用方式</td><td>直接在object对象上调用<br>如<code>object.wait()</code></td><td>直接使用condition调用<br>如：<code>condition.await()</code></td></tr><tr><td>等待队列个数</td><td>一个</td><td>多个（一个Condition本身维护一个等待队列，一个同步器上有多个Condition和一个同步队列）</td></tr><tr><td>当前线程释放锁并进入等待</td><td>支持(wait)</td><td>支持(await)</td></tr><tr><td>线程释放锁后，在等待中不响应中断</td><td>不支持</td><td>支持</td></tr><tr><td>线程释放锁进入超时等待</td><td>支持</td><td>不支持</td></tr><tr><td>线程释放锁等待到将来一时间</td><td>不支持</td><td>支持</td></tr><tr><td>唤醒等待队列中一个或全部线程</td><td>支持 (notify)</td><td>支持 (signal)</td></tr></tbody></table><h4 id="Condition等待队列和同步器的联系"><a href="#Condition等待队列和同步器的联系" class="headerlink" title="Condition等待队列和同步器的联系"></a>Condition等待队列和同步器的联系</h4><p>Condition是同步器AbstractQueuedSynchronizer的内部类，同步器维护的多个等待队列和一个同步队列，而每个等待队列都是由每个Condition维护的，也是存放着获得锁失败的线程。</p><p>signalAll相当于该Condition上的每一个节点均执行以此signal()方法，所有节点移到同步队列中，并唤醒它们。</p><p><img src="/Blog/Java/Java并发编程艺术/第5章-Java中的锁/Condition等待队列在同步器中的体现.png" alt="1532519358919"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本章总结了Lock接口，队列同步器(&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;)，可重用锁&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java并发编程艺术" scheme="https://uncleaaron.github.io/Blog/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="并发编程" scheme="https://uncleaaron.github.io/Blog/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>第4章 Java并发编程基础</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC4%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java并发编程艺术/第4章-Java并发编程基础/</id>
    <published>2018-06-01T12:46:25.000Z</published>
    <updated>2018-07-19T12:14:32.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本章主要讲解Java的线程Thread，线程的6个状态，Daemon守护线程，线程的生存周期操作（构造、启动、中断、终止），以及线程的几种通信方式：volatile和synchronized提供的内存可见性保障，等待/通知机制wait/notify，管道流，Thread.join() 以及 ThreadLocal变量。</p><p>最后还示例了线程池、数据库连接池的简单实现，篇幅较大，暂时未补充，需要自己阅读书本。</p></blockquote><a id="more"></a><h1 id="第4章-Java并发编程基础"><a href="#第4章-Java并发编程基础" class="headerlink" title="第4章 Java并发编程基础"></a>第4章 Java并发编程基础</h1><h2 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h2><p>线程是现代操作系统调度的最小单位，拥有各自的计数器、堆栈和局部变量等属性，能够访问共享的内存变量。</p><p>实际上Java程序天生就是多线程程序，执行main()会启用一个主线程，同时还会启用其他的一些辅助线程。</p><h3 id="1-1-线程优先级-priority"><a href="#1-1-线程优先级-priority" class="headerlink" title="1.1. 线程优先级(priority)"></a>1.1. 线程优先级(priority)</h3><p>现代操作系统基本采用时分调度线程，会分出多个时间片，一个线程会分配到若干时间片，时间片用完了就会发生线程调度，等待下次分配。</p><p><strong>线程优先级决定分配到的时间片和处理器资源多少的线程属性。优先级高的线程分配的时间片数量更多。</strong></p><p>Java线程中使用一个整型的变量priority来控制优先级，范围是1~10，线程构建的时候使用setPriority(int)修改优先级，优先级默认是5。</p><p>设置线程优先级的原则：</p><ul><li>针对频繁阻塞（休眠或I/O操作）的线程需要设置较高优先级。</li><li>偏重计算（需要较多CPU时间）的线程设置较低优先级，从而避免处理器被独占。</li></ul><p>但实际上有些JVM或者操作系统会无视Priority的设定，所以<strong>线程优先级不能作为程序正确性的依赖</strong>。</p><h3 id="1-2-线程的状态"><a href="#1-2-线程的状态" class="headerlink" title="1.2. 线程的状态"></a>1.2. 线程的状态</h3><p><strong>表4-1 Java线程的状态（6种）</strong></p><table><thead><tr><th style="text-align:center">状态名称</th><th style="text-align:center">状态</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>NEW</strong></td><td style="text-align:center"><strong>初始态</strong></td><td style="text-align:left">线程被构建，但是还没调用start()方法</td></tr><tr><td style="text-align:center"><strong>RUNNABLE</strong></td><td style="text-align:center"><strong>运行态</strong></td><td style="text-align:left">Java线程将操作系统中的就绪态和运行态统称为“运行中”</td></tr><tr><td style="text-align:center"><strong>BLOCKED</strong></td><td style="text-align:center"><strong>阻塞态</strong></td><td style="text-align:left">线程阻塞于锁（调用同步方法时没获取到锁）（注意：阻塞在current包的Lock接口中的线程是等待态而不是阻塞态）</td></tr><tr><td style="text-align:center"><strong>WAITING</strong></td><td style="text-align:center"><strong>等待态</strong></td><td style="text-align:left">线程wait()后，当前线程需要等待其他线程做出一些特定动作（通知或中断）才能返回到运行态</td></tr><tr><td style="text-align:center"><strong>TIME_WAITING</strong></td><td style="text-align:center"><strong>超时等待态</strong></td><td style="text-align:left">可以在指定时间内自行返回的特殊WAITING<br>（其他线程在规定时间内未回复的话则自行返回进行下一步操作）</td></tr><tr><td style="text-align:center"><strong>TERMINGATED</strong></td><td style="text-align:center"><strong>终止态</strong></td><td style="text-align:left">表示当前线程已经执行完毕</td></tr></tbody></table><p><img src="/Blog/Java/Java并发编程艺术/第4章-Java并发编程基础/图4-1 Java线程状态变迁.jpg" alt="图4-1 Java线程状态变迁"></p><h3 id="1-3-Daemon线程-守护线程"><a href="#1-3-Daemon线程-守护线程" class="headerlink" title="1.3. Daemon线程(守护线程)"></a>1.3. Daemon线程(守护线程)</h3><p>Daemon线程是一种支持型线程，主要被用作程序的后台调度和支持性工作。</p><p>使用threadA.setDaemon(true)将线程设置为Daemon线程（Daemon需要在启动线程前设置）</p><ul><li><strong>当JVM中不存在非Daemon线程的时候，JVM会退出。</strong>此时不一定会执行Daemon线程中的finally块，因此不能依靠Daemon线程中的finally来确保逻辑正确。</li></ul><h2 id="二、启动和终止线程"><a href="#二、启动和终止线程" class="headerlink" title="二、启动和终止线程"></a>二、启动和终止线程</h2><h3 id="2-1-构造线程"><a href="#2-1-构造线程" class="headerlink" title="2.1. 构造线程"></a>2.1. 构造线程</h3><p><strong>运行线程之前首先要构造一个线程对象，并且初始化线程属性</strong>。如线程所属的线程组、线程优先级、是否Daemon线程等信息。</p><p>在Thread.init()的源代码中，新构造的线程对象是由其parent线程来进行空间分配的，而<strong>child线程继承了parent的属性</strong>是否为Daemon、优先级和加载资源的contextClassLoader以及科技城ThreadLocal，同时分配一个唯一的线程ID。</p><h3 id="2-2-启动线程"><a href="#2-2-启动线程" class="headerlink" title="2.2. 启动线程"></a>2.2. 启动线程</h3><ul><li>调用<strong>start()</strong>方法即可启动。</li></ul><p>含义：当前线程（parent线程）同步告知JVM，只要线程规划器空闲，应立即启动调用start()方法的线程。</p><h3 id="2-3-中断（interrupt）"><a href="#2-3-中断（interrupt）" class="headerlink" title="2.3. 中断（interrupt）"></a>2.3. 中断（interrupt）</h3><p><strong>中断可以理解为线程的一个标志位属性</strong>。它表示一个运行中的线程是否被其他的线程<strong><u>通知</u></strong>进行了中断操作（不不会终止线程）。</p><p><strong>interrupt()</strong>：其他线程通过调用该线程的interrupt()方法对其进行中断操作。</p><p><strong>isInterrupted()</strong>：线程通过检查自身是否被中断来响应，通过调用isInterrupted() 来判断是否被中断。</p><p><strong>Thread.interrupted()</strong>：复位当前线程的中断标志位（重置为false）。</p><p>如果线程已经处于结束态，则即使该线程被中断过，其中断标志位依旧是false。</p><p><strong>InterruptedException</strong>：当线程处于阻塞状态（因被调用了wait()，join()，sleep()而进入阻塞）时，调用interrupt() ，因为没有占用CPU运行的线程是不可能给自己中断状态置位的，JVM会先清楚中断标志位，然后产生InterruptedException异常（不会终止线程）。（可以利用接收这个异常终止阻塞的线程）</p><h3 id="2-4-安全地终止线程"><a href="#2-4-安全地终止线程" class="headerlink" title="2.4. 安全地终止线程"></a>2.4. 安全地终止线程</h3><h4 id="2-4-1-终止处于运行状态的线程"><a href="#2-4-1-终止处于运行状态的线程" class="headerlink" title="2.4.1. 终止处于运行状态的线程"></a>2.4.1. 终止处于运行状态的线程</h4><ul><li><p>利用中断状态标志位，做中断操作来取消或停止任务。</p></li><li><p>使用boolean变量控制是否需要停止任务并终止该线程</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="title">implments</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">    privatge <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;<span class="comment">//volatile的boolean控制标志</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// boolean变量为真时继续执行</span></span><br><span class="line">        <span class="comment">// 线程没被中断(Isterrupted()返回false)之前继续执行</span></span><br><span class="line">        <span class="comment">// 当外部执行cancel()或interrupt()时终止线程</span></span><br><span class="line">        <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted() ) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// boolean取消操作，供外部终止线程使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        on = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-终止处于“阻塞状态”的线程"><a href="#2-4-2-终止处于“阻塞状态”的线程" class="headerlink" title="2.4.2. 终止处于“阻塞状态”的线程"></a>2.4.2. 终止处于“阻塞状态”的线程</h4><ul><li><p>同样用interrupt()：</p><p>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。 </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行任务...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">        <span class="comment">// 由于产生InterruptedException异常，退出while(true)循环，线程终止！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-废弃的suspend-、resume-、和stop"><a href="#2-5-废弃的suspend-、resume-、和stop" class="headerlink" title="2.5. 废弃的suspend()、resume()、和stop()"></a>2.5. 废弃的suspend()、resume()、和stop()</h3><p>suspend：暂停</p><p>resume：恢复</p><p>stop：终止</p><p>由于强制操作导致的资源不完全释放的副作用（死锁等），所以废弃。建议用回以上的等待/通知的机制替代。</p><h2 id="三、线程间通信"><a href="#三、线程间通信" class="headerlink" title="三、线程间通信"></a>三、线程间通信</h2><p>让线程之间能后互相配合的完成工作。</p><h3 id="3-1-volatile和synchronized关键字"><a href="#3-1-volatile和synchronized关键字" class="headerlink" title="3.1. volatile和synchronized关键字"></a>3.1. volatile和synchronized关键字</h3><p>在程序执行过程中，每个线程可以拥有变量的拷贝，而且看到的不一定是最新的变量值，这时候就需要volatile和synchronized关键字。</p><p>volatile可以告知程序任何对该变量的访问必须要从共享内存中获取，并且其修改必须同步刷新到共享内存，以保证该变量在线程之间的可见性。（不保证原子性）</p><p>synchronized确保同一时刻只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。</p><p>每个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进去同步块或者同步方法，没有获取到监视器的线程将会被阻塞在入口，进入BLOCKED状态和同步队列（释放操作会唤醒同步队列中的线程，使其重新尝试获取监视器）。</p><h3 id="3-2-等待-通知机制（wait-notify）"><a href="#3-2-等待-通知机制（wait-notify）" class="headerlink" title="3.2.等待/通知机制（wait/notify）"></a>3.2.等待/通知机制（wait/notify）</h3><p>简单的<strong>生产者/消费者模式</strong>：一个线程修改了一个对象的值，而另一个线程感知到了变化，进而进行相应操作（开始于一个生产者线程，执行于另一个消费者线程）。隔离了做什么(What)和怎么做(How)，在功能上解耦。</p><p>相关监视器方法：（<code>等待/通知的相关方法都定义在java.lang.Object类上</code>，执行这些方法前，需要配合<code>synchronzied</code>对调用的对象加锁实现等待/通知机制，这些锁是针对同一个Object对象进行操作的，）</p><table><thead><tr><th>方法名</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><strong>notify()</strong></td><td>通知一个在对象上等待的线程，使其从wait()方法返回，前提是本线程已获得该对象的锁</td><td>notify不代表被通知线程获得锁，需要等notify的主动线程释放锁后，才有机会获得锁；<br>而从wait()返回的前提就是获取到了锁</td></tr><tr><td><strong>notifyAll()</strong></td><td>通知所有等待在该对象上的锁</td><td>通知后，<strong>所有在该对象上wait()的线程进入同步队列(BLOCKED状态)</strong>依次等待获取锁的机会</td></tr><tr><td><strong>wait()</strong></td><td>本线程进入WAITING状态，只有等待别的线程通知或被中断才可返回</td><td>调用wait后，<strong>该线程会释放锁</strong>，进入等待队列<br>需要try/catch检查InterruptException异常</td></tr><tr><td><strong>wait(long)</strong></td><td>超时等待。n毫秒后若没有通知的话就自主返回</td><td></td></tr><tr><td>wait(long, int)</td><td>纳秒级超时等待</td></tr></tbody></table><p>等待/通知机制的经典范式</p><p><strong>等待方（生产者）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object 对象) &#123;<span class="comment">// 1. 获得对象锁</span></span><br><span class="line">    <span class="keyword">while</span> (条件不满足) &#123;</span><br><span class="line">        对象.wait();<span class="comment">// 2. 如果条件不满足，则调用wait()，被通知后仍然要检查条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑<span class="comment">// 3. 直到条件满足后才执行相应逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通知方（消费者）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object 对象) &#123;<span class="comment">// 1. 获取对象锁</span></span><br><span class="line">    改变等待方的条件;<span class="comment">// 2. 改变等待方条件，使其能退出自旋检查</span></span><br><span class="line">    对象.notifyAll();<span class="comment">// 3. 通知等待方，使其退出Waiting态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-管道-输入-输出流（Piped）"><a href="#3-3-管道-输入-输出流（Piped）" class="headerlink" title="3.3. 管道.输入/输出流（Piped）"></a>3.3. 管道.输入/输出流（Piped）</h3><p>管道输入/输出流用于<strong>线程间数据传输</strong>，媒介为内存（区别于文件IO）</p><p>字节流：<code>PipedOutputStream</code>，<code>PipedInputStream</code></p><p>字符流：<code>PipedReader</code>，<code>PipedWriter</code></p><ul><li>在使用时一定要先将Output和Input绑定connect起来，否则会抛出IO异常：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">out.connect(in);<span class="comment">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</span></span><br><span class="line">out.connect(in);</span><br><span class="line">Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">"PrintThread"</span>);</span><br><span class="line">printThread.start();</span><br><span class="line"><span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">out.write(receive);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> PipedReader in;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;<span class="comment">// 从PipedReader里读取)</span></span><br><span class="line">System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-Thread-join"><a href="#3-4-Thread-join" class="headerlink" title="3.4. Thread.join()"></a>3.4. Thread.join()</h3><p>当属Thread类的方法<code>Thread.join()</code></p><p><strong>涵义：</strong>当线程A执行了threadB.join()，其意为：<strong>当前线程A等待threadB线程终止后才从thread.join()返回</strong>。<code>也就是确保当前线程必须在threadB后继续执行</code>。</p><p>此外也提供了<code>Thread.join(long millis)</code> 和 <code>Thread.join(long millis, int nanos)</code>的<strong>超时等待</strong>方法</p><p>使用时要try/catch检测InterruptException异常</p><p>Java源码的Thread.join()大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> throw InterruptException </span>&#123;</span><br><span class="line">    <span class="comment">// 条件不满足，继续等待</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件符合，返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以发现 <strong>join() 其实也是等待/通知机制的一种</strong>，<strong>线程终止时会调用自身的notifyAll()方法</strong>，唤醒等待在本线程对象的所有线程。</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread previous = Thread.currentThread();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Domino(previous), String.valueOf(i));</span><br><span class="line">thread.start();</span><br><span class="line">previous = thread;</span><br><span class="line">&#125;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" terminate."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Domino</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Thread thread;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Domino</span><span class="params">(Thread thread)</span> </span>&#123;<span class="comment">//在此处引入别的进程</span></span><br><span class="line"><span class="keyword">this</span>.thread = thread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">thread.join();<span class="comment">// 此处调用Thread.join()</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" terminate."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-ThreadLocal-线程变量"><a href="#3-5-ThreadLocal-线程变量" class="headerlink" title="3.5. ThreadLocal 线程变量"></a>3.5. ThreadLocal 线程变量</h3><p>ThreadLocal线程变量：是一个以 <strong>\&lt;ThreadLocal为键，任意Object为值></strong> 的key-value结构(Entry)，存放在线程自己的ThreadLocalMap中。（一个线程可以拥有多个ThreadLocal变量）</p><p>这个Map被附带绑定在线程上，也就是说一个线程可以通过一个ThreadLocal对象查询到绑定在该线程上的一个值。（每个线程的static ThreadLocal都不一样）</p><p>构造后，需先使用set(T)设置值，再使用get()方法获取值，若不调用set(T)，会抛出空指针异常。 如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法：这样如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回。</p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line"><span class="comment">//重写initialValue()方法，第一次get()方法调用时会进行初始化（前提是若set方法没有调用），每个线程会调用一次</span></span><br><span class="line"><span class="comment">// 可以不重写，那么声明ThreadLocal变量写作不用括号重写：XX = new ThreadLocal&lt;Long&gt;();</span></span><br><span class="line">        <span class="comment">// 并且不重写时，不调用set就get的话，会抛出NullPointerException</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">TIME_THREADLOCAL.set(System.currentTimeMillis());<span class="comment">// set(T)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get(); <span class="comment">//get()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Profiler.begin();<span class="comment">// set(T)</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);<span class="comment">//get()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><p>书P106-P117说明了：基本的数据库连接池实现、线程池的基本实现、基于线程池的Web项目实现。注意查看</p><h3 id="4-1-数据库连接池"><a href="#4-1-数据库连接池" class="headerlink" title="4.1. 数据库连接池"></a>4.1. 数据库连接池</h3><h3 id="4-2-线程池"><a href="#4-2-线程池" class="headerlink" title="4.2. 线程池"></a>4.2. 线程池</h3><h3 id="4-3-基于线程池技术的简单Web服务器"><a href="#4-3-基于线程池技术的简单Web服务器" class="headerlink" title="4.3. 基于线程池技术的简单Web服务器"></a>4.3. 基于线程池技术的简单Web服务器</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本章主要讲解Java的线程Thread，线程的6个状态，Daemon守护线程，线程的生存周期操作（构造、启动、中断、终止），以及线程的几种通信方式：volatile和synchronized提供的内存可见性保障，等待/通知机制wait/notify，管道流，Thread.join() 以及 ThreadLocal变量。&lt;/p&gt;
&lt;p&gt;最后还示例了线程池、数据库连接池的简单实现，篇幅较大，暂时未补充，需要自己阅读书本。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java并发编程艺术" scheme="https://uncleaaron.github.io/Blog/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="并发编程" scheme="https://uncleaaron.github.io/Blog/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
