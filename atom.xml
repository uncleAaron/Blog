<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StormAaron的技术站</title>
  
  
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="https://uncleaaron.github.io/Blog/"/>
  <updated>2018-07-21T16:52:25.750Z</updated>
  <id>https://uncleaaron.github.io/Blog/</id>
  
  <author>
    <name>Aaron.H</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java对象创建、内部数据、如何访问(HptSpot虚拟机下）</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%AF%B9%E8%B1%A1(HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B)/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java对象(HotSpot虚拟机下)/</id>
    <published>2018-07-21T11:54:55.000Z</published>
    <updated>2018-07-21T16:52:25.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>对象创建</strong>：查找类型，确认类加载，分配内存，初始化内存，设置对象，init🖊</p><p><strong>对象构造</strong>：对象头（Markword，类型指针），实例数据</p><p><strong>对象访问定位</strong>：从栈上的引用访问到对象，需要查找到堆中的对象，然后通过对象中的类型指针找到其类型 </p></blockquote><a id="more"></a><h1 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h1><p>这里讲的是普通的Java对象，不包括数组或Class对象</p><ol><li>虚拟机遇到new指令时，<strong>检查指令参数是否能在常量池中定位到这个类的符号引用</strong></li><li>检查这个符号引用代表的类<strong>是否已经被加载、解析和初始化</strong>过</li><li>若未加载，<strong>执行相应的类加载</strong>过程</li><li>为新生对象<strong>分配内存</strong>。需要内存大小在编译时就可完全确定。分配方式有几种，“空闲列表”、“指针碰撞”、“CAS+失败重试保证原子性”，“分配TLAB本地线程分配缓冲”</li><li>对<strong>内存空间初始化零值</strong>。这一步保证了对象的实例字段在不赋初始值就可以直接使用，能访问到队形数据类型所对应的零值</li><li>虚拟机对<strong>对象进行设置</strong>。例如是哪个类、对象哈希码、GC分代年龄、是否设置偏向锁等，对对象头Object Header设置。</li><li><strong>执行<code>init</code>方法</strong>，按照程序员意愿初始化对象。这样才算是真正被完全生产出来对象（在这之前对象内都还是零值）</li></ol><h1 id="对象内部"><a href="#对象内部" class="headerlink" title="对象内部"></a>对象内部</h1><ul><li>对象头：MarkWord+类型指针<ul><li>MarkWord：对象自身运行时的设置数据：哈希码HashCode，GC分代年龄，锁状态，持有锁，偏向线程ID等</li><li>类型指针：指向类元数据，虚拟机通过这个指针确定对象的类型</li></ul></li><li>实例数据：包括对象定义的数据，而且还包括从父类继承的、子类定义的数据</li><li>对齐填充：补位的无意义填充</li></ul><h1 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h1><p>Java程序是如何通过引用定位到对象实例数据和类型数据的？</p><p>虚拟机有两钟可实现的方式：</p><ul><li>句柄方式：Java堆中划分出一个句柄池，其中每个句柄存放对象实例数据和类型数据各自的地址信息。特点是稳定，对象被移动只改变句柄不改变reference。</li><li>直接指针：Java堆的对象还存放一个类型的指针。速度更快，节省了1次指针定位的时间开销。（这正是HotSpot虚拟机的实现方式）</li></ul><p><img src="/Blog/Java/Java对象(HotSpot虚拟机下)/Java对象(HotSpot虚拟机下" alt="通过句柄访问对象">/通过句柄访问对象.png)<img src="/Blog/Java/Java对象(HotSpot虚拟机下)/Java对象(HotSpot虚拟机下" alt="通过类型指针访问对象">/通过类型指针访问对象.png)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;对象创建&lt;/strong&gt;：查找类型，确认类加载，分配内存，初始化内存，设置对象，init🖊&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象构造&lt;/strong&gt;：对象头（Markword，类型指针），实例数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象访问定位&lt;/strong&gt;：从栈上的引用访问到对象，需要查找到堆中的对象，然后通过对象中的类型指针找到其类型 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域划分以及内存溢出异常</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java内存区域划分以及内存溢出异常/</id>
    <published>2018-07-21T11:54:55.000Z</published>
    <updated>2018-07-21T17:06:06.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Java虚拟机的内存区域主要分为：程序计数器，虚拟机栈，本地方法栈，Java堆，方法区🖊 </p><p>其中，栈描述方法执行，及方法的局部变量和引用；堆描述对象；方法区描述类和常量</p></blockquote><a id="more"></a><h1 id="Java虚拟机运行时数据区域"><a href="#Java虚拟机运行时数据区域" class="headerlink" title="Java虚拟机运行时数据区域"></a>Java虚拟机运行时数据区域</h1><p><img src="/Blog/Java/Java内存区域划分以及内存溢出异常/Java虚拟机运行时数据区.png" alt="Java虚拟机运行时数据区"></p><p>Java虚拟机在运行时会把它所管理的内存划分为若干个不同的数据区域。大致分为以下：</p><ol><li><p><strong>程序计数器</strong>：在Java中，每个线程都有一个独立的程序计数器，独立存储，该段内存是线程私有的</p></li><li><p><strong>Java虚拟机栈：</strong>描述<strong>方法执行</strong>的内存模型：</p><ul><li><p>每个方法在执行的同时会创建<strong>栈帧</strong>用于存储<strong>局部变量表</strong>、动态链接等信息。</p></li><li><p>其中，局部变量表存放基本类型、对象引用、returnAddress类型。其内存空间大小分配在编译期间就可以完全确定，之后也不会改变。</p></li><li>线程私有的，生命周期与线程相同。</li><li>当线程请求的栈深度大于虚拟机允许的深度，抛出StackOverFlowError异常</li><li>可动态扩展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li><li><p><strong>本地方法栈</strong>：描述Native方法的内存模型，其他与虚拟机栈一样。</p></li><li><p><strong>Java堆</strong>：存放对象实例，几乎所有的对象实例都在这里分配内存。</p><ul><li>被<strong>所有线程共享</strong>这一块内存区域，是Java虚拟机所管理的最大一块内存</li><li>堆是GC垃圾收集器管理的主要区域（在普遍使用的分代手机算法中，堆可分为：新生代和老年代）</li><li>对线程来说，还划分出多个线程私有的本地线程分配缓冲区（TLAB）</li><li>以上无论如何划分，堆存放的都是对象实例，划分只是为了更好地回收和分配内存</li><li>可动态扩展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li><li><p><strong>方法区</strong>：存储已被加载的<strong>类信息</strong>、<strong>常量</strong>、（类变量）静态变量、编译后的代码等（大概就是已加载的Class文件的基本内容吧）</p><ul><li>所有线程共享</li><li><strong>运行时常量池</strong>：Class文件的常量池的信息，在类加载后进入方法区的运行时常量池<ul><li>Java不要求常量一定要编译时产生，可以运行期间产生放入方法区常量池，例如String.intern()</li><li>（此外Class文件中还有类版本、字段、方法、接口等描述信息）</li></ul></li><li>这部分的GC较少，在此区域GC主要为了针对常量池回收和类型卸载。</li><li>其实它也是堆结构，但是要与Java堆区分，称为“Non-Heap”非堆</li><li>可动态拓展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li><li><p><strong>直接内存</strong>：</p><ul><li>可动态拓展，可能会产生OutOfMemoryError异常(OOM)</li></ul></li></ol><h1 id="OutOfMemoryError异常"><a href="#OutOfMemoryError异常" class="headerlink" title="OutOfMemoryError异常"></a>OutOfMemoryError异常</h1><h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>堆用于存储对象实例，只要不断创建对象，并且保证GC Roots到对象之间有可达路径以避免对象被垃圾回收，那么对象数量在到达堆最大容量限制是抛出内存溢出OOM异常</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java虚拟机的内存区域主要分为：程序计数器，虚拟机栈，本地方法栈，Java堆，方法区🖊 &lt;/p&gt;
&lt;p&gt;其中，栈描述方法执行，及方法的局部变量和引用；堆描述对象；方法区描述类和常量&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://uncleaaron.github.io/Blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库规范及解读</title>
    <link href="https://uncleaaron.github.io/Blog/DataBase/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8F%8A%E8%A7%A3%E8%AF%BB/"/>
    <id>https://uncleaaron.github.io/Blog/DataBase/MySQL数据库规范及解读/</id>
    <published>2018-07-19T07:16:08.000Z</published>
    <updated>2018-07-19T08:36:24.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>使用Mysql的准则 🖊 </p></blockquote><a id="more"></a><h2 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h2><blockquote><p>第一条：必须使用InnoDB存储引擎</p></blockquote><p>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</p><blockquote><p>第二条：必须使用utf8(utf8mb4)字符集</p></blockquote><p>解读：万国码，无需转码，无乱码风险，节省空间，utf8mb4是utf8的超集，由于近年移动设备的增多，emoji表情以及部分不常见汉字在utf8下会表现为乱码，故需要升级至utf8mb4</p><blockquote><p>第三条：数据表、数据字段必须加入中文注释</p></blockquote><p>解读：N年后谁会知道这个a1,a2,a3字段是干嘛的</p><blockquote><p>第四条：禁止使用存储过程、视图、触发器、Event</p></blockquote><p>解读：高并发<strong>大数据</strong>的互联网业务，<strong>架构</strong>设计思路是<em>“解放<strong>数据库</strong>CPU，将计算转移到服务层“</em>，并发量大的情况下，这些功能很可能将数据库拖死，<em>业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”</em>。数据库擅长存储与索引，CPU计算还是上移吧</p><blockquote><p>第五条：禁止存储大文件或者大照片</p></blockquote><p>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI多好</p><h2 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h2><blockquote><p>第一条：只允许<em>使用内网域名，而不是ip连接数据库</em></p></blockquote><p>解读：虽然IP访问更快，域名访问需要内网dns，但是对于大数据库的扩展和迁库考虑，域名更好</p><blockquote><p>第二条：线上环境、开发环境、<strong>测试</strong>环境数据库内网域名遵循命名规范</p></blockquote><p>业务名称：xxx<br>线上环境：dj.xxx.db<br>开发环境：dj.xxx.rdb<br>测试环境：dj.xxx.tdb<br>从库在名称后加-s标识，备库在名称后加-ss标识<br>线上从库：dj.xxx-s.db<br>线上备库：dj.xxx-sss.db</p><blockquote><p>第三条：库名、表名、字段名：小写，下划线风格，不超过32个字符，禁止拼音英文混用</p></blockquote><p>解读：见名知意，方便后续维护</p><blockquote><p>第四条：表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</p></blockquote><p>解读：见名知意，方便后续维护</p><h2 id="三、表和字段设计规范"><a href="#三、表和字段设计规范" class="headerlink" title="三、表和字段设计规范"></a>三、表和字段设计规范</h2><blockquote><p>第一条：禁止使用外键，如果有外键完整性约束，需要应用程序控制</p></blockquote><p>解读：<em>外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql的性能</em>，甚至会造成死锁。高并发情况下容易造成数据库性能，<em>大数据高并发业务场景数据库使用以性能优先</em></p><blockquote><p>第二条：必须把字段定义为NOT NULL并且提供默认值</p></blockquote><p>解读：<br>a) null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化<br>b) null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多<br>c) null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标识<br>d) 对null的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。<em>如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录</em></p><blockquote><p>第三条：禁止使用TEXT、BLOB类型</p></blockquote><p>解读：会浪费更多的磁盘和内存空间，<em>非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能</em></p><blockquote><p>第四条：禁止使用小数存储国币</p></blockquote><p>解读：曾经踩过这样的坑，100元分3天摊销，每天摊销(100/3)元，结果得到3个33.33。后来实施对账系统，始终有几分钱对不齐，郁闷了很久（不是几分钱的事，是业务方质疑的眼神让研发很不爽），最后发现是除法惹的祸<br>解决方案：使用“分”作为单位，这样数据库里就是整数了</p><blockquote><p>第五条：必须使用varchar(20)存储手机号</p></blockquote><p>解读：<br>a) 涉及到区号或者国家代号，可能出现+-()<br>b) 手机号会去做数学运算么？<br>c) varchar可以支持模糊查询，例如：like“138%”</p><blockquote><p>第六条：禁止使用ENUM，可使用TINYINT代替</p></blockquote><p>解读：<br>a) 增加新的ENUM值要做DDL操作<br>b) ENUM的内部实际存储就是整数，你以为自己定义的是字符串？</p><blockquote><p>第七条：表必须有主键，例如自增主键</p></blockquote><p>解读：<br>a) 主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用<br>b) 主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率<br>c) 无主键的表删除，在row模式的主从架构，会导致备库夯住</p><h2 id="四、索引设计规范"><a href="#四、索引设计规范" class="headerlink" title="四、索引设计规范"></a>四、索引设计规范</h2><blockquote><p>第一条：单表索引建议控制在5个以内</p></blockquote><p>解读：一个好的索引设计，可以让你的效率提高几十甚至几百倍，但过多反而适得其反</p><blockquote><p>第二条：单索引字段数不允许超过5个</p></blockquote><p>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了</p><blockquote><p>第三条：禁止在更新十分频繁、区分度不高的属性上建立索引</p></blockquote><p>解读：<br>a) 更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能<br>b) “性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似</p><blockquote><p>第四条:建立组合索引，必须把区分度高的字段放在前面</p></blockquote><p>解读：能够更加有效的过滤数据</p><h2 id="五、SQL使用规范"><a href="#五、SQL使用规范" class="headerlink" title="五、SQL使用规范"></a>五、SQL使用规范</h2><blockquote><p>第一条：禁止使用SELECT *，只获取必要的字段，需要显示说明列属性</p></blockquote><p>解读：<br>a) 读取不需要的列会增加CPU、IO、NET消耗<br>b) 不能有效的利用覆盖索引<br>c) 使用<code>SELECT *</code>容易在增加或者删除字段后出现程序BUG</p><blockquote><p>第二条：禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性</p></blockquote><p>解读：容易在增加或者删除字段后出现程序BUG</p><blockquote><p>第三条：禁止使用属性隐式转换</p></blockquote><p>解读：SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中phone索引，猜猜为什么？<br>int数据类型优先级高于varcher， 该查询会把phone转换为int，因此需要把表中所有数据改成int，所以必须全盘扫描<br>phone是varchar类型，SQL语句带入的是整形，故不会命中索引，加个引号就好了：<br>SELECT uid FROM t_user WHERE phone=’13812345678’</p><blockquote><p>第四条：禁止在WHERE条件的属性上使用函数或者表达式</p></blockquote><p>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描<br>正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</p><blockquote><p>第五条：禁止大表使用JOIN查询，禁止大表使用子查询</p></blockquote><p>解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能，大表指的是数据量在1000万以上的表</p><blockquote><p>第六条：禁止使用OR条件，必须改为IN查询</p></blockquote><p>解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？</p><blockquote><p>第七条：禁止使用负向查询，以及%开头的模糊查询</p></blockquote><p>解读：<br>a) 负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描<br>b) %开头的模糊查询，会导致全表扫描<br>一般来说，WHERE过滤条件不会只带这么一个“负向查询条件”，还会有其他过滤条件，举个例子：查询沈剑已完成订单之外的订单（好拗口）：<br>SELECT oid FROM t_order WHERE uid=123 AND status != 1;<br>订单表5000w数据，但uid=123就会迅速的将数据量过滤到很少的级别（uid建立了索引），此时再接上一个负向的查询条件就无所谓了，扫描的行数本身就会很少<br>但如果要查询所有已完成订单之外的订单：<br>SELECT oid FROM t_order WHERE status != 1;<br>这就挂了，立马CPU100%，status索引会失效，负向查询导致全表扫描</p><blockquote><p>第八条：应用程序必须捕获SQL异常，并有相应处理</p></blockquote><p>解读：方便维护，及时“查漏补缺”</p><p><strong>总结：大数据量高并发的互联网业务，极大影响数据库性能的都不让用，不让用哟。</strong></p><p>转自：<a href="https://zhuanlan.zhihu.com/p/32586602" target="_blank" rel="noopener">知乎：SangSir</a>的文章</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用Mysql的准则 🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>领域模型中的实体类的4种类型VO,DTO,DO,PO</title>
    <link href="https://uncleaaron.github.io/Blog/Java/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%9A%844%E7%A7%8D%E7%B1%BB%E5%9E%8BVO-DTO-DO-PO/"/>
    <id>https://uncleaaron.github.io/Blog/Java/领域模型中的实体类的4种类型VO-DTO-DO-PO/</id>
    <published>2018-07-19T07:14:08.000Z</published>
    <updated>2018-07-21T16:58:40.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>经常会接触到VO，DO，DTO的概念，本文从领域建模中的实体划分和项目中的实际应用情况两个角度，对这几个概念进行简析 🖊 </p></blockquote><a id="more"></a><p>在项目应用中，VO对应于页面上需要显示的数据（表单），DO对应于数据库中存储的数据（数据表），DTO对应于除二者之外需要进行传递的数据。 </p><p>领域模型中的实体类分为四种类型：VO、DTO、DO、PO，各种实体类用于不同业务层次间的交互，并会在层次内实现实体类之间的转化。</p><p>业务分层为：视图层（VIEW+ACTION），服务层（SERVICE），持久层（DAO） </p><p>相应各层间实体的传递如下图：  </p><p> <img src="/Blog/Java/领域模型中的实体类的4种类型VO-DTO-DO-PO/领域模型.jpg" alt="领域模型"></p><p>项目中我们并没有严格遵循这种传递关系，但这种和业务层次的关联对我们理解各实体类的作用是有帮助的。（我们没有接触到PO的原因，我理解为ORM对PO进行了封装） </p><p>概念：</p><ul><li><strong>VO（View Object）</strong>：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</li><li><strong>DTO（Data Transfer Object）</strong>：数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。</li><li><strong>DO（Domain Object）</strong>：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</li><li><strong>PO（PersistentObject）</strong>：持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。 </li></ul><p>模型：</p><p> 下面以一个时序图建立简单模型来描述上述对象在三层架构应用中的位置 </p><ul><li><p>用户发出请求（可能是填写表单），表单的数据在展示层被匹配为VO。</p></li><li><p>展示层把VO转换为服务层对应方法所要求的DTO，传送给服务层。 l 服务层首先根据DTO的数据构造（或重建）一个DO，调用DO的业务方法完成具体业务。 </p></li><li>服务层把DO转换为持久层对应的PO（可以使用ORM工具，也可以不用），调用持久层的持久化方法，把PO传递给它，完成持久化操作。</li><li><p>对于一个逆向操作，如读取数据，也是用类似的方式转换和传递，略。</p><p>三、项目中的实体类</p></li></ul><p>项目中常见的实体类有VO，DO和DTO，命名规则也常是以相应字符串结尾，如VO.Java。</p><p>但是DTO不总是遵循这个规则，而通常与他的用途有关，如写成Query.java，表示存储了一个查询条件。</p><p>项目中实体类出现的业务层次也没有这么严格，例如我们可以在视图层就组装一个DO，也可以将一个VO从持久层传出来，所以与业务分层相关联的划分方法显得有些冗余。</p><p>从项目代码中抽象出的理解是：VO对应于页面上需要显示的数据，DO对应于数据库中存储的数据，DTO对应于除二者之外需要进行传递的数据。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;经常会接触到VO，DO，DTO的概念，本文从领域建模中的实体划分和项目中的实际应用情况两个角度，对这几个概念进行简析 🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>使SpringMVC支持跨域访问的几种解决方法</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Web/%E4%BD%BFSpringMVC%E6%94%AF%E6%8C%81%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Web/使SpringMVC支持跨域访问的几种解决方法/</id>
    <published>2018-07-17T12:41:09.000Z</published>
    <updated>2018-07-21T14:48:33.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>由于最近又开始写博客，刚好碰到的开发问题都重新总结一下。</p><p>今天在写Controller的时候又想起<strong>跨域访问</strong>支持的问题，在这里总结一下我以前用过的方法🖊 </p></blockquote><a id="more"></a><h1 id="1-在Controller类或方法上加入-CrossOrigin注解"><a href="#1-在Controller类或方法上加入-CrossOrigin注解" class="headerlink" title="1. 在Controller类或方法上加入@CrossOrigin注解"></a>1. 在Controller类或方法上加入@CrossOrigin注解</h1><p><strong>@CrossOrigin</strong>有两个参数</p><p>origins：允许访问的域列表</p><p>maxAge：飞行前响应的缓存持续时间的最大年龄（以秒为单位） </p><h2 id="1-1-使方法支持跨域访问"><a href="#1-1-使方法支持跨域访问" class="headerlink" title="1.1. 使方法支持跨域访问"></a>1.1. 使方法支持跨域访问</h2><p>在方法上加<strong><code>@CrossOrigin</code></strong>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/crossDomain2"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">crossDomain2</span><span class="params">(HttpServletRequest req, HttpServletResponse res, String name)</span></span>&#123;</span><br><span class="line">    ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-使Controller类支持跨域访问"><a href="#1-2-使Controller类支持跨域访问" class="headerlink" title="1.2. 使Controller类支持跨域访问"></a>1.2. 使Controller类支持跨域访问</h2><p>在类上添加<strong><code>@CrossOrigin</code></strong>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="meta">@CrossOrigin</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;  </span><br><span class="line">    ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-重写WebMvcConfigurerAdapter-addCorsMapping方法"><a href="#2-重写WebMvcConfigurerAdapter-addCorsMapping方法" class="headerlink" title="2. 重写WebMvcConfigurerAdapter.addCorsMapping方法"></a>2. 重写WebMvcConfigurerAdapter.addCorsMapping方法</h1><ol><li>写一个Conroller的基类Cors，继承<strong><code>WebMvcConfigurerAdapter</code></strong>类，并重写<strong><code>addCorsMappings(CorsRegistry)</code></strong>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cors</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">        .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">        .allowedMethods(<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"OPTIONS"</span>, <span class="string">"DELETE"</span>, <span class="string">"PATCH"</span>)</span><br><span class="line">          .allowCredentials(<span class="keyword">true</span>).maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实现的Controller继承这个基类Cors</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStarter</span> <span class="keyword">extends</span> <span class="title">Cors</span> </span>&#123;<span class="comment">//继承了刚才实现的WebMvcConfigurerAdapter的子类Cors，从而实现支持跨域访问</span></span><br><span class="line">    <span class="comment">// 省略具体方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-直接拦截在header上加入响应头"><a href="#3-直接拦截在header上加入响应头" class="headerlink" title="3. 直接拦截在header上加入响应头"></a>3. 直接拦截在header上加入响应头</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>); <span class="comment">//自定义中间件，设置跨域需要的响应头。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;由于最近又开始写博客，刚好碰到的开发问题都重新总结一下。&lt;/p&gt;
&lt;p&gt;今天在写Controller的时候又想起&lt;strong&gt;跨域访问&lt;/strong&gt;支持的问题，在这里总结一下我以前用过的方法🖊 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java 开发问题总结" scheme="https://uncleaaron.github.io/Blog/tags/Java-%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="JavaWeb" scheme="https://uncleaaron.github.io/Blog/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Linux程序设计</title>
    <link href="https://uncleaaron.github.io/Blog/Linux/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://uncleaaron.github.io/Blog/Linux/Linux程序设计/</id>
    <published>2018-06-16T16:05:10.000Z</published>
    <updated>2018-07-17T02:20:53.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>简单总结了Shell脚本设计，C in Linux 的编程和编译，以及GTK+的简单原理</p></blockquote><a id="more"></a><h1 id="Shell程序设计"><a href="#Shell程序设计" class="headerlink" title="Shell程序设计"></a>Shell程序设计</h1><h2 id="bash程序执行步骤"><a href="#bash程序执行步骤" class="headerlink" title="bash程序执行步骤"></a>bash程序执行步骤</h2><ol><li>编辑保存<code>vi</code></li><li>赋可执行权限<code>chmod</code></li><li><code>./filename.sh</code>执行</li></ol><h2 id="bash程序结构"><a href="#bash程序结构" class="headerlink" title="bash程序结构"></a>bash程序结构</h2><p># file.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash****Shell类型****</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释</span></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">funn</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....<span class="comment"># 主过程</span></span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量=值<span class="comment"># "="两边不能留空格</span></span><br></pre></td></tr></table></figure><p>变量都会被默认成字符串</p><h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><p>用户自定义变量要加<code>$</code>，加<code>{}</code>可以同其他字符分开（建议添加）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;xxx&#125;</span></span><br></pre></td></tr></table></figure><h4 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h4><p><strong>会替换</strong><code>$</code><strong>变量</strong>成值。参数中包含空格也要用双引号。</p><h4 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h4><p><strong>字符串</strong>值，不会替换<code>$</code>变量</p><h4 id="倒引号"><a href="#倒引号" class="headerlink" title="倒引号 "></a>倒引号 <code></code></h4><p><strong>替换命令</strong>为其执行结果</p><h3 id="特定变量"><a href="#特定变量" class="headerlink" title="特定变量"></a>特定变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$@</span><span class="comment"># 参数列表（数组）</span></span><br><span class="line">$*<span class="comment"># 参数列表（字符串）</span></span><br><span class="line"><span class="variable">$#</span><span class="comment"># 参数个数</span></span><br><span class="line"><span class="variable">$n</span><span class="comment"># 位置参数$1，$2，$3...$n</span></span><br><span class="line"><span class="variable">$0</span><span class="comment"># 本脚本文件名</span></span><br><span class="line">$$<span class="comment"># 本程序进程号</span></span><br><span class="line">$?<span class="comment"># 上一条命令或函数的返回值</span></span><br><span class="line"><span class="variable">$HOME</span><span class="comment"># 用户主目录</span></span><br></pre></td></tr></table></figure><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><h3 id="expr-命令"><a href="#expr-命令" class="headerlink" title="expr 命令"></a>expr 命令</h3><p>计算算术表达式，支持 <code>+</code>、<code>-</code>、<code>\*</code>、<code>/</code>、<code>%</code>（<em>要<code></code>\</em><code></code>进行转移，否则会错误）</p><p>支持<code>|</code>，<code>&amp;</code>，<code>&gt;</code>，<code>&gt;=</code>，<code>!=</code>，<code>=</code>等逻辑运算，<code>|</code>,<code>&gt;</code>,<code>&lt;</code>要用<code>\</code>转义才能使用</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr arg</span><br></pre></td></tr></table></figure><p>数字符 和 符号 间要<strong>空格</strong></p><p>要改变运算次序的话需要使用<code></code>倒引号</p><figure class="highlight plain"><figcaption><span>`expr 5 \* 7` + 5```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### let 命令</span><br><span class="line"></span><br><span class="line">**语法**：给a赋值（语法中**不用空格**！）</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">let a=(5+7)/3</span><br></pre></td></tr></table></figure><h3 id="…-运算"><a href="#…-运算" class="headerlink" title="$((…))运算"></a>$((…))运算</h3><p>直接运算得出结果</p><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $((5+7))</span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p><strong>0真，1假</strong>（与熟知C语言判断相反）</p><p><strong>语法：</strong>注意！<strong>中括号</strong>两边<strong>要空格</strong>！！！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 条件判断语句 ]</span><br></pre></td></tr></table></figure><p><strong>多重条件判断组合</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-a<span class="comment"># 与</span></span><br><span class="line">-o<span class="comment"># 或</span></span><br><span class="line">!<span class="comment"># 非</span></span><br></pre></td></tr></table></figure><p><strong>算术比较：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a -eq b<span class="comment"># 相等（equal）</span></span><br><span class="line">a -ne b<span class="comment"># 不相等（not equal）</span></span><br><span class="line">a -gt b<span class="comment"># a大于b（greater then）</span></span><br><span class="line">a -ge b<span class="comment"># a大于等于b（greater equal）</span></span><br><span class="line">a -lt b<span class="comment"># a小于b（less then）</span></span><br><span class="line">a -le b<span class="comment"># a小于或等于b（less equal）</span></span><br><span class="line">!expr<span class="comment"># 假则真，真则假</span></span><br></pre></td></tr></table></figure><p><strong>字符比较：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = s2<span class="comment"># 字符串相同</span></span><br><span class="line">s1 != s2<span class="comment"># 字符串不同</span></span><br><span class="line">-n str1<span class="comment"># 字符串不为空</span></span><br><span class="line">-z str1<span class="comment"># 字符串为空</span></span><br></pre></td></tr></table></figure><p><strong>文件判断</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-d file<span class="comment"># 是目录</span></span><br><span class="line">-e file<span class="comment"># 存在</span></span><br><span class="line">-f file<span class="comment"># 是文件</span></span><br></pre></td></tr></table></figure><h3 id="if-分支语句"><a href="#if-分支语句" class="headerlink" title="if 分支语句"></a>if 分支语句</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">elif</span> [ 条件2 ]; <span class="keyword">then</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="case-模式匹配-分支语句"><a href="#case-模式匹配-分支语句" class="headerlink" title="case 模式匹配 分支语句"></a>case 模式匹配 分支语句</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 条件1 <span class="keyword">in</span></span><br><span class="line">模式n)</span><br><span class="line">命令n</span><br><span class="line">;;</span><br><span class="line">*)<span class="comment">#default</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p><strong>模式匹配配对符：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?<span class="comment"># 任意一个字符</span></span><br><span class="line">*<span class="comment"># 任意字符串</span></span><br><span class="line">[]<span class="comment"># 括号中的任意字符</span></span><br><span class="line">[!]<span class="comment"># 不在括号中的任意字符</span></span><br><span class="line">&#123;c1,c2&#125;<span class="comment"># 和c1或者c2匹配都可</span></span><br></pre></td></tr></table></figure><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 [<span class="keyword">in</span> 列表]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>可用 <code>in 1,2,3,4...</code>或者默认使用<code>in $@</code>。其中<code>$@</code>是参数数组</p><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>/until [ 条件 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">命令</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>结构：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">function</span>] 函数名()&#123;</span><br><span class="line">    命令</span><br><span class="line">    [<span class="built_in">return</span> xx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果最后不使用return返回，函数返回的就是最后一条命令的返回值</li></ul><h1 id="C-in-Linux"><a href="#C-in-Linux" class="headerlink" title="C in Linux"></a>C in Linux</h1><h2 id="gcc编译过程"><a href="#gcc编译过程" class="headerlink" title="gcc编译过程"></a>gcc编译过程</h2><p><img src="/Blog/Linux/Linux程序设计/gcc编译过程.png" alt="gcc编译过程"></p><h2 id="gcc命令"><a href="#gcc命令" class="headerlink" title="gcc命令"></a>gcc命令</h2><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc [选项] [filename]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c<span class="comment"># 编译.c文件生成.o文件，不生成可执行文件</span></span><br><span class="line">-o filename<span class="comment"># 指定生成文件名称为filename。不设这个选项则默认为filename.xx（根据编译阶段生成后缀文件）</span></span><br><span class="line">-Idir<span class="comment"># 在编译时增加搜索头文件的目录</span></span><br><span class="line">-Ldir<span class="comment"># 在编译时增加搜索库的目录</span></span><br><span class="line">-lname<span class="comment"># 在编译时装在名为libname.a的函数库，需要存在于系统预设目录或-L设置的目录。</span></span><br><span class="line">-g<span class="comment"># 加入调试信息</span></span><br><span class="line">-E<span class="comment"># 生成.i预处理文件</span></span><br><span class="line">-S<span class="comment"># 生成.s汇编文件</span></span><br></pre></td></tr></table></figure><p>总结：在编译过程中。除非使用了”-c”，“-S”,或”-E”选项(或者编译错误阻止了完整的过程)，否则统一完整链接步骤。 </p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><strong>分步编译</strong></p><p>先用<code>-c</code>,<code>-S</code>,<code>-E</code>中断编译过程，生成中间文件，再用<code>gcc 中间文件</code>完成编译</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br><span class="line">gcc -c say_hello.c -o say_hello.o</span><br><span class="line">gcc hello.o say_hello.o -o hello</span><br></pre></td></tr></table></figure><p><strong>一步编译</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c say_hello.c -o hello</span><br></pre></td></tr></table></figure><p><strong>使用<code>-Idirname</code>增加搜索头文件目录</strong></p><p>示例：</p><p>当前目录为./hello.c    ./functions/say_hello.h    ./functions/say_hello.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c <span class="built_in">functions</span>/say_hello.c -o hello -Ifunctions</span><br></pre></td></tr></table></figure><h2 id="make-软件维护工具"><a href="#make-软件维护工具" class="headerlink" title="make 软件维护工具"></a>make 软件维护工具</h2><h3 id="makefile文件"><a href="#makefile文件" class="headerlink" title="makefile文件"></a>makefile文件</h3><p><strong>格式：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">目标文件: 依赖项列表</span></span><br><span class="line">命令</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>依赖项可以不写.h文件，但一定要写清.c文件的路径</p><p>示例：</p><p>当前目录为./hello.c    ./functions/say_hello.h    ./functions/say_hello.c</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:hello.o say_hello.o</span></span><br><span class="line">gcc hello.o say_hello.o -o hello</span><br><span class="line"><span class="section">hello.o:hello.c say_hello.h</span></span><br><span class="line">gcc -c hello.c -o hello.o -Ifunctions</span><br><span class="line"><span class="section">say_hello.o:functions/say_hello.c</span></span><br><span class="line">gcc -c functions/say_hello.c -o say_hello.o -Ifunctions</span><br></pre></td></tr></table></figure><p>makefile可以使用变量宏命令<code>${}</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CC=-Wall-c</span><br><span class="line"><span class="section">hello:$&#123;CC&#125;</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><h3 id="使用makefile"><a href="#使用makefile" class="headerlink" title="使用makefile"></a>使用makefile</h3><p>在存放makefile文件的目录下使用：<code>make</code></p><h2 id="调试工具-gdb"><a href="#调试工具-gdb" class="headerlink" title="调试工具 gdb"></a>调试工具 gdb</h2><ol><li>设置断点</li><li>监视变量</li><li>单步执行</li><li>修改变量值</li></ol><p><strong>进入gdb：</strong><code>gdb</code></p><h3 id="使用gdb"><a href="#使用gdb" class="headerlink" title="使用gdb"></a>使用gdb</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file<span class="comment"># 装入可执行文件</span></span><br><span class="line">list<span class="comment"># 查看源代码</span></span><br><span class="line">quit<span class="comment"># 退出gdb</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行程序</span></span><br><span class="line"><span class="built_in">break</span> &lt;line&gt;<span class="comment"># 设置断点</span></span><br><span class="line">next<span class="comment"># 单步执行</span></span><br><span class="line">step<span class="comment"># 单步执行到函数内部</span></span><br><span class="line">run<span class="comment"># 执行程序</span></span><br><span class="line"><span class="built_in">kill</span><span class="comment"># 终止正在调试的程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视变量</span></span><br><span class="line">watch<span class="comment"># 监视变量</span></span><br><span class="line"><span class="built_in">print</span><span class="comment"># 打印变量</span></span><br></pre></td></tr></table></figure><h2 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h2><h3 id="静态函数库"><a href="#静态函数库" class="headerlink" title="静态函数库"></a>静态函数库</h3><p><strong>库文件名</strong>：<code>libxxxxx.a</code></p><p>静态函数库文件比较大，因为整个函数库的所有代码都会被整合编译到目标代码中，所以使用静态库编译后的程序不需要外部函数库支持，因为都已经编译进去了。但是如果今天函数库改变了就需要重新编译。</p><p><strong>创建</strong></p><p>编译生成.o文件：<code>gcc -c pr1.c pr2.c</code></p><p>链接静态库：<code>ar -rsv libpr.a pr1.o pr2.o</code></p><p><strong>使用</strong></p><p>加载库文件编译：<code>gcc -o main main.c -L./ -lpr</code></p><h3 id="动态函数库"><a href="#动态函数库" class="headerlink" title="动态函数库"></a>动态函数库</h3><p><strong>库文件名：</strong><code>libxxxx.so</code></p><p>动态函数库在编译时没有被编译进目标代码中，当程序执行到时才会调用函数里的相应函数。所以使用动态函数库产生的可执行文件较小。</p><p><strong>创建</strong></p><p>生成动态库：<code>gcc -fpic -shared -o libpr.so pr1.c pr2.c</code></p><p><strong>使用</strong></p><p>调用动态库：<code>gcc -o main_so main.c ./libpr.so</code></p><h1 id="GTK"><a href="#GTK" class="headerlink" title="GTK+"></a>GTK+</h1><h2 id="GTK-控件"><a href="#GTK-控件" class="headerlink" title="GTK+控件"></a>GTK+控件</h2><p><strong>GtkWidget</strong>：GTK控件的父类，所有控件按照此类型返回</p><p>创建控件：<code>GtkWidget * gtk_xxxx_new(GtkNodeType type 或者 void)</code></p><p>设置xxx：<code>void gtk_xxx_set_xxx(GtkNode *xxx, XX message)</code></p><p>读取xxx：<code>xx gtk_xxx_get_xxx(GtkNode *xxx)</code></p><p>存放进窗体：<code>gtk_container_add(GTK_CONTAINER(windowxx), xxxx)</code></p><p>显示窗体：<code>gtk_widget_show_all(window)</code></p><p>界面布局采用横向<code>hbox</code>和纵向<code>vbox</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    GtkWidget *window, *button;<span class="comment">//声明window和button为GtkWidget，后面使用需要类型转换</span></span><br><span class="line">    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);<span class="comment">// 初始化window变量为GTK....类型</span></span><br><span class="line">    gtk_window_set_title(GTK_WINDOW(window), <span class="string">"HELLO WORLD"</span>);<span class="comment">//这里用的大写是类型转换</span></span><br><span class="line">    button = gtk_button_new_with_label(<span class="string">"Hello World"</span>);<span class="comment">// 初始化button变量为button类型</span></span><br><span class="line">    gtk_container_add(GTK_CONTAINER(window)， button)<span class="comment">//类型转换成Container，button放入window</span></span><br><span class="line">    gtk_widget_show_all(window);</span><br><span class="line">    gtk_main();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调函数、信号"><a href="#回调函数、信号" class="headerlink" title="回调函数、信号"></a>回调函数、信号</h2><p>GTK+用信号（signal）和回调函数（callback）处理外部事件。</p><h3 id="信号与回调函数绑定"><a href="#信号与回调函数绑定" class="headerlink" title="信号与回调函数绑定"></a>信号与回调函数绑定</h3><p>采用<code>g_signal_connect</code>函数来完成信号和回调函数绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g_signal_connect(gpointer *object,<span class="comment">// 连接信号的对象</span></span><br><span class="line">                <span class="keyword">const</span> gchar *name,<span class="comment">// 信号名</span></span><br><span class="line">                Gcallback func,<span class="comment">// 回调函数名</span></span><br><span class="line">                gpointer user_data)<span class="comment">// 回调函数参数的指针</span></span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数的<strong>函数原型</strong>（用户自己定义）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback_func</span><span class="params">(GtkWidget *widget,<span class="comment">// 发出信号的控件的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">              gpointer callback_data)</span><span class="comment">// 传递进函数的数据</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;简单总结了Shell脚本设计，C in Linux 的编程和编译，以及GTK+的简单原理&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Vi</title>
    <link href="https://uncleaaron.github.io/Blog/Linux/Vim%E7%AE%80%E6%98%93%E7%AC%94%E8%AE%B0/"/>
    <id>https://uncleaaron.github.io/Blog/Linux/Vim简易笔记/</id>
    <published>2018-06-11T06:37:58.000Z</published>
    <updated>2018-07-16T11:46:30.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>总结了Vi的使用</p></blockquote><a id="more"></a><p><img src="/Blog/Linux/Vim简易笔记/Vi.png" alt="Vi"></p><h2 id="末行模式（进出、搜索、替换）"><a href="#末行模式（进出、搜索、替换）" class="headerlink" title="末行模式（进出、搜索、替换）"></a>末行模式（进出、搜索、替换）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:w<span class="comment"># 保存</span></span><br><span class="line">:w filename<span class="comment"># 另存为</span></span><br><span class="line">:q<span class="comment"># 退出</span></span><br><span class="line">:q!<span class="comment"># 退出不保存</span></span><br><span class="line">:wq<span class="comment"># 退出保存</span></span><br><span class="line">:x<span class="comment"># 加密保存</span></span><br></pre></td></tr></table></figure><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/&lt;pattern&gt;<span class="comment"># 从光标向下搜索</span></span><br><span class="line">?&lt;pattern&gt;<span class="comment"># 从光标向上搜索</span></span><br></pre></td></tr></table></figure><p>n：向下遍历光标</p><p>N：向上遍历光标</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>(:s/x/y普通替换本行第一个。最后加/g替换本行全部 , :%s/x/y 替换全部行第一个，这基础上加/g替换全文)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:s/old/new<span class="comment"># 替换本行首次出现的old</span></span><br><span class="line">:s/old/new/g<span class="comment"># 替换本行全部</span></span><br><span class="line">:%s/old/new/g<span class="comment"># 替换全文（全部行全部）</span></span><br><span class="line">:n,m s/old/new/g<span class="comment">#替换n-m行的全部old</span></span><br></pre></td></tr></table></figure><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><table><thead><tr><th style="text-align:center">h</th><th style="text-align:center">j</th><th style="text-align:center">k</th><th style="text-align:center">l</th></tr></thead><tbody><tr><td style="text-align:center">左</td><td style="text-align:center">下</td><td style="text-align:center">上</td><td style="text-align:center">右</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">k j h l<span class="comment"># 上下左右</span></span><br><span class="line">0<span class="comment"># 行首</span></span><br><span class="line">^<span class="comment"># 行首</span></span><br><span class="line">$<span class="comment"># 行尾</span></span><br><span class="line">w<span class="comment"># 下一个字首</span></span><br><span class="line">b<span class="comment"># 当前字首，已经在字首则到上个字首</span></span><br><span class="line">e<span class="comment"># 当前字尾，已经在字尾则到下个字尾</span></span><br><span class="line">nw<span class="comment"># 右移n字</span></span><br><span class="line">nb<span class="comment"># 左移n字</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">H<span class="comment"># 当前屏幕最顶端（Highest）</span></span><br><span class="line">nH<span class="comment"># 当前屏第n行</span></span><br><span class="line">gg<span class="comment"># 文首</span></span><br><span class="line">G<span class="comment"># 文末</span></span><br><span class="line">n+<span class="comment"># 后跳n行</span></span><br><span class="line">n-<span class="comment"># 前跳n行</span></span><br><span class="line">nG<span class="comment"># 跳到第n行</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="comment"># 本句首</span></span><br><span class="line">)<span class="comment"># 下一句首</span></span><br><span class="line">&#123;<span class="comment"># 本段首</span></span><br><span class="line">&#125;<span class="comment"># 本段末</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+b<span class="comment"># 向上翻一页(back)</span></span><br><span class="line">Ctrl+f<span class="comment"># 向下翻一页（front）</span></span><br><span class="line">Ctrl+u<span class="comment"># 向前翻半页（up）</span></span><br><span class="line">Ctrl+d<span class="comment"># 向下翻半页（down）</span></span><br></pre></td></tr></table></figure><h2 id="编辑指令"><a href="#编辑指令" class="headerlink" title="编辑指令"></a>编辑指令</h2><h3 id="删除（x-d）"><a href="#删除（x-d）" class="headerlink" title="删除（x, d）"></a>删除（x, d）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x<span class="comment"># 删除字符</span></span><br><span class="line">nx<span class="comment"># 删除从光标开始的n个字符</span></span><br><span class="line">dd<span class="comment"># 删除行</span></span><br><span class="line">ndd<span class="comment">#删除包括当前行的n行</span></span><br></pre></td></tr></table></figure><h3 id="复制（y）"><a href="#复制（y）" class="headerlink" title="复制（y）"></a>复制（y）</h3><p>可配合光标移动使用（w, n, ^, $）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yy<span class="comment">#当前行复制</span></span><br><span class="line">nyy<span class="comment">#n行复制</span></span><br><span class="line">yw<span class="comment">#复制到到字胃</span></span><br><span class="line">nyw<span class="comment">#复制光标及其后的n个单词</span></span><br><span class="line">y^<span class="comment">#复制光标到行首</span></span><br><span class="line">y$<span class="comment">#复制光标到行尾</span></span><br></pre></td></tr></table></figure><h3 id="粘贴（p）"><a href="#粘贴（p）" class="headerlink" title="粘贴（p）"></a>粘贴（p）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p<span class="comment"># 光标后粘贴</span></span><br><span class="line">P<span class="comment"># 光标前粘贴</span></span><br></pre></td></tr></table></figure><h3 id="撤销（u）"><a href="#撤销（u）" class="headerlink" title="撤销（u）"></a>撤销（u）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u<span class="comment"># 撤销一步</span></span><br><span class="line">U<span class="comment"># 撤销本行操作(其实是增加了全局操作，会被u撤销)</span></span><br></pre></td></tr></table></figure><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> nu<span class="comment"># 显示行号</span></span><br><span class="line">:<span class="built_in">set</span> nonu<span class="comment"># 取消显示行号</span></span><br><span class="line">:nu<span class="comment"># 取得该行行号</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Vim编辑异常退出后，会无法正常进行编辑，这时候就要删除一个同名的.swap文件，即可编辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;总结了Vi的使用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux总结</title>
    <link href="https://uncleaaron.github.io/Blog/Linux/Linux%E6%80%BB%E7%BB%93/"/>
    <id>https://uncleaaron.github.io/Blog/Linux/Linux总结/</id>
    <published>2018-06-06T16:05:10.000Z</published>
    <updated>2018-07-16T11:50:53.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>根据自己的记忆和理解方式，总结了最近学习和接触到的Linux理论和指令。</p><p>涉及Linux目录，文件管理，系统，设备管理，进程管理，网络管理，用户管理等。</p><p>（此外，Vi使用 以及 Shell脚本编写在别篇）</p></blockquote><a id="more"></a><h1 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h1><h2 id="linux内核版本号"><a href="#linux内核版本号" class="headerlink" title="linux内核版本号"></a>linux内核版本号</h2><p>x.y.zz（y次版本号，偶数稳定版，奇数发展版）</p><h2 id="Linux特点"><a href="#Linux特点" class="headerlink" title="Linux特点"></a>Linux特点</h2><p><strong>开放性</strong></p><p><strong>多用户</strong></p><p><strong>多任务</strong></p><p>良好的<strong>用户界面</strong></p><p><strong>设备独立性</strong></p><p>丰富的<strong>网络功能</strong></p><p>可靠的<strong>系统安全</strong></p><p>良好的<strong>可移植性</strong></p><h2 id="Linux目录"><a href="#Linux目录" class="headerlink" title="Linux目录"></a>Linux目录</h2><table><thead><tr><th>目录</th><th>功能</th><th>助记</th></tr></thead><tbody><tr><td>/bin</td><td>常用系统程序目录</td><td>binary</td></tr><tr><td>/boot</td><td>开技设定目录</td><td>boot</td></tr><tr><td>/dev</td><td>系统设备装置文件目录</td><td>device  /dev/null 垃圾箱</td></tr><tr><td>/etc</td><td>系统配置文件，尤其是passwd，shadow文件</td><td>Edit Text Configuration</td></tr><tr><td>/home</td><td>系统使用者的目录</td><td></td></tr><tr><td>/lib</td><td>Linux执行或编译程序函数库的目录</td><td>Libary</td></tr><tr><td>/mnt</td><td>软驱和光驱接入挂载的地方</td><td></td></tr><tr><td>/proc</td><td>系统核心与程序的一些信息</td><td></td></tr><tr><td>/tmp</td><td>临时文件目录</td><td>Temporary 临时的</td></tr><tr><td>/sbin</td><td>系统管理员常用指令集和程序</td><td></td></tr><tr><td>/usr</td><td>/usr/sbin 系统管理员的管理程序和指令<br>/usr/bin 一般执行文件摆放的地方</td><td></td></tr><tr><td>/var</td><td>摆放系统日志文件</td></tr></tbody></table><h1 id="系统启动或关闭"><a href="#系统启动或关闭" class="headerlink" title="系统启动或关闭"></a>系统启动或关闭</h1><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>暂时更改系统运行级别</p><p><strong>权限：</strong>root</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init [0123456]</span><br></pre></td></tr></table></figure><p><strong>重要参数</strong></p><p>0：关机级别</p><p>1：单用户运行级别</p><p>2：多用户</p><p>3：多用户，字符模式</p><p>4：用户自定义</p><p>5：图形界面</p><p>6：重启</p><hr><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>关闭或重启系统</p><p><strong>权限：</strong>root</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown [选项] [时间] [警告信息]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-r: shutdown之后重启</span><br><span class="line">-h: 关机后不重启</span><br></pre></td></tr></table></figure><p><strong>时间：</strong>now 或者 +时间值</p><hr><h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><p>关闭系统和关闭电源</p><p><strong>权限：</strong>所有用户</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p: 关闭计算机后再关闭电源</span><br></pre></td></tr></table></figure><hr><h1 id="用户和组管理"><a href="#用户和组管理" class="headerlink" title="用户和组管理"></a>用户和组管理</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>超级用户：UID 0    （默认为root）</p><p>系统用户：UID 100以下</p><p>普通用户：UID 500+</p><p>/etc/passwd：账号文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaron:x:1002:1002:aaron:/home/aaron:/bin/bash</span><br><span class="line">用户名:加密密码:用户ID:组ID:用户信息:用户主目录:登陆Shell</span><br><span class="line">（默认创建用户下，GID会和UID相同）</span><br></pre></td></tr></table></figure><p>/etc/shadow：口令文件</p><p>/etc/group：用户组信息文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaron:x:500:a1,a2</span><br><span class="line">组名:密码:GID:用户列表（逗号分隔）</span><br></pre></td></tr></table></figure><hr><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>添加用户</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [选项] [参数] &lt;newUsername&gt;</span><br></pre></td></tr></table></figure><p><strong>选项/参数：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d: 指定主目录(directory)</span><br><span class="line">-u: 指定UID(UID)</span><br><span class="line">-g: 指定用户组(group)</span><br><span class="line">-G: 指定用户组列表(Groups)</span><br><span class="line">-s: 指定Shell(Shell)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># useradd aaron</span></span><br></pre></td></tr></table></figure><p>默认条件下：系统自动分配一个500以上的UID和GID，默认创建一个与UID同名的GID组，默认在home目录下创建同名文件夹为主目录。</p><hr><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>修改密码（root可以修改所有的密码，普通用户只能修改自己的密码）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [选项] &lt;Username&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><p>修改用户属性</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod [选项] [参数] &lt;Username&gt;</span><br></pre></td></tr></table></figure><p><strong>选项/参数：</strong>（同useradd）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d: 指定主目录(directory)</span><br><span class="line">-u: 指定UID(UID)</span><br><span class="line">-g: 指定用户组(group)</span><br><span class="line">-G: 指定用户组列表(Groups)</span><br><span class="line">-s: 指定Shell(Shell)</span><br></pre></td></tr></table></figure><hr><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><p>删除用户</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel [选项] &lt;Username&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-r: 删除用户的同时删除主目录</span><br></pre></td></tr></table></figure><hr><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><hr><h3 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h3><p>添加用户组</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd [选项] &lt;GroupName&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g: 设定组ID</span><br><span class="line">-r: 添加系统组(GID小于500)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 501 worker</span><br></pre></td></tr></table></figure><hr><h3 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h3><p>修改组属性</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod [选项] &lt;GroupName&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g GID：设定组ID</span><br><span class="line">-n &lt;GroupName&gt;: 设定新组名</span><br></pre></td></tr></table></figure><hr><h2 id="账号查看"><a href="#账号查看" class="headerlink" title="账号查看"></a>账号查看</h2><hr><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>显示系统中有哪些用户正在使用</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-u: 显示详细的用户状态</span><br><span class="line">-H: 显示表头</span><br><span class="line">-a: 显示所有用户</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ who -uH</span><br><span class="line">NAME     LINE         TIME             IDLE          PID COMMENT</span><br><span class="line">aaron    pts/0        2018-06-07 11:35   .         21837 (125.88.24.125)</span><br></pre></td></tr></table></figure><hr><h3 id="w"><a href="#w" class="headerlink" title="w"></a>w</h3><p>显示系统中用户使用情况，是who的增强版</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w [选项] [user]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s: 简短模式</span><br><span class="line">user: 指定用户</span><br></pre></td></tr></table></figure><hr><h3 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h3><p>显示当前用户名</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><hr><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>显示用户信息</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g: 只显示GID</span><br><span class="line">-u: 只显示UID</span><br></pre></td></tr></table></figure><hr><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>切换用户身份</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [选项] [username]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-l: 同时切换用户主目录</span><br><span class="line">-: 同时切换环境变量</span><br><span class="line">-m: 保留环境变量</span><br></pre></td></tr></table></figure><hr><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>以root身份执行指令</p><p><strong>权限：</strong>在 /etc/sudoers 中有出现的使用者</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">command</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>/etc/shells: 查看系统支持的shell</p><p>一般shell都在/bin/xxx目录下（xx为shell名，例如/bin/bash ）</p><p>root 提示符# 其他用户提示符$</p><h1 id="输入-输出重定向"><a href="#输入-输出重定向" class="headerlink" title="输入/输出重定向"></a>输入/输出重定向</h1><h2 id="文件描述符（0-1-2）"><a href="#文件描述符（0-1-2）" class="headerlink" title="文件描述符（0, 1, 2）"></a>文件描述符（0, 1, 2）</h2><p><strong>0：标准输入</strong></p><p><strong>1：标准输出</strong></p><p><strong>2：标准错误输出</strong></p><h2 id="重定向控制符"><a href="#重定向控制符" class="headerlink" title="重定向控制符"></a>重定向控制符</h2><p><strong>&lt; 文件</strong> ：输入重定向控制符，输入内容从文件获取</p><p><strong>> 文件</strong>：输出重定向控制符（覆盖）</p><p><strong>>> 文件</strong>：输出重定向控制符（追加）</p><h2 id="重定向高级用法"><a href="#重定向高级用法" class="headerlink" title="重定向高级用法"></a>重定向高级用法</h2><ul><li>文件描述符[0,1,2] 重定向控制符[&gt;,&lt;,&lt;&lt;] 文件</li></ul><p>例：重定向标准输出到文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> xxx 1&gt;文件</span><br></pre></td></tr></table></figure><hr><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><strong>符号：</strong><code>&quot;|&quot;</code></p><p>用于连接进程，通过管道连接的进程可以同时运行，并且随着数据流在她们之间传递可以自动地进行协调。</p><hr><h1 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h1><h2 id="文件权限属性"><a href="#文件权限属性" class="headerlink" title="文件权限属性"></a>文件权限属性</h2><p><img src="/Blog/Linux/Linux总结/文件权限属性.png" alt="文件权限属性"></p><p>文件类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-：普通文件</span><br><span class="line">d：目录</span><br><span class="line">l：链接文件</span><br><span class="line">p：管道文件</span><br></pre></td></tr></table></figure><p>权限码（rwx）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r = 4<span class="comment"># 读</span></span><br><span class="line">w = 2<span class="comment"># 写</span></span><br><span class="line">x = 1<span class="comment"># 执行</span></span><br><span class="line">- = 0<span class="comment"># 无权限</span></span><br></pre></td></tr></table></figure><hr><h2 id="文件-目录-属性操作"><a href="#文件-目录-属性操作" class="headerlink" title="文件/目录/属性操作"></a>文件/目录/属性操作</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>显示指定目录下的目录和文件</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [选项] 目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a：显示隐藏文件（<span class="string">"."</span>开头）</span><br><span class="line">-l：列出文件详细信息</span><br><span class="line">-S：以文件大小排序</span><br><span class="line">-t：以时间排序</span><br><span class="line">-i：显示索引节点</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">-drwxr-xr-x1rootroot969May2917:02dir1</span><br><span class="line">文件权限:链接数:拥有者:所属组:文件大小(B):修改日期:文件名</span><br></pre></td></tr></table></figure><hr><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>切换工作目录</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 目录名</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ : 用户主目录</span><br><span class="line">. : 当前目录</span><br><span class="line">.. : 父目录</span><br><span class="line">- : 返回上一次目录</span><br></pre></td></tr></table></figure><hr><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>查看当前工作目录</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><hr><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建目录</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项] 目录</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-p：确保目录名称存在，不存在则创建一个</span><br><span class="line">-m：在创建目录的同时设置目录的权限</span><br></pre></td></tr></table></figure><hr><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>删除<strong>空目录</strong></p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p：当子目录被删除后也成为空目录时，也一并删除</span><br></pre></td></tr></table></figure><hr><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>用于修改文件的时间属性，包括存取时间和更改时间。<strong>若文件不存在，系统会建立一个新的文件</strong> </p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [选项] 文件1 [文件2...]</span><br></pre></td></tr></table></figure><p>不加选项的话修改时间记录为当前系统时间</p><hr><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p><strong>删除</strong>文件或目录（删除目录要 -r）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] 文件名或目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r：递归删除目录一下文件</span><br><span class="line">-i：交互模式，删除前逐一询问（interactive）</span><br><span class="line">-f：强制模式，即使属性为只读，也直接删除，无需逐一确认（force）</span><br></pre></td></tr></table></figure><hr><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p><strong>复制</strong>文件或目录（目录用 -a）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [选项] 源文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a：复制目录时使用，保留链接、文件属性，且递归复制目录下所有内容，相当于-pdr</span><br><span class="line">-p：复制属性</span><br><span class="line">-d：复制链接的话，只复制链接而非期文件</span><br><span class="line">-r：递归复制目录</span><br><span class="line">-i：覆盖之前询问</span><br><span class="line">-f：覆盖且不询问</span><br></pre></td></tr></table></figure><hr><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p><strong>移动</strong>或<strong>更名</strong>指定的文件或目录</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [选项] 源文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure><p><strong>mv参数设置与运行结果：</strong></p><table><thead><tr><th>命令格式</th><th>运行结果</th></tr></thead><tbody><tr><td>mv  文件名  文件名</td><td>将源文件名改为目标文件名</td></tr><tr><td>mv  文件名  目录名</td><td>移动文件到目录</td></tr><tr><td>mv  目录名  目录名</td><td>目标目录存在，将源目录移动到目标目录<br>目标目录不存在，则改名</td></tr><tr><td>mv  目录名  文件名</td><td>错误</td></tr></tbody></table><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-i：交互模式，覆盖询问</span><br><span class="line">-f：强制模式，覆盖不提示</span><br></pre></td></tr></table></figure><hr><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>从指定目录开始递归查找文件，并可以对其进行操作</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 起始目录 &lt;选项查找条件&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-name &lt;name&gt;：正则匹配字符串（-iname 忽略大小写）</span><br><span class="line">-<span class="built_in">type</span> &lt;d/c/b/p/f/l/s&gt;：文件类型</span><br><span class="line">-ls：详细列出所找到的文件</span><br><span class="line">-<span class="built_in">exec</span>：执行期间不询问；用&#123;&#125;表示找到的文件，对其进行命令操作，命令末尾必须以 <span class="string">"\;"</span> 结束</span><br><span class="line">-ok：同<span class="built_in">exec</span>，但会询问。</span><br><span class="line">-size &lt;n&gt;：文件大小是n，可用b，c（char），k(kB)表示</span><br><span class="line">对查询条件做逻辑运算：</span><br><span class="line">-a：与</span><br><span class="line">-o：或</span><br><span class="line">！：非</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># find ~ -name &quot;test*&quot; -ls -exec rm &#123;&#125; \;</span><br><span class="line">393291    0 -rw-rw-r--   1 aaron    aaron           0 Jun  8 13:40 /home/aaron/test3</span><br><span class="line">393290    0 -rw-rw-r--   1 aaron    aaron           0 Jun  8 13:40 /home/aaron/test2</span><br><span class="line">393236    0 -rw-rw-r--   1 aaron    aaron           0 Jun  8 13:40 /home/aaron/test1</span><br></pre></td></tr></table></figure><hr><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>为源文件创建一个链接，但不复制源文件</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [选项] 源对象 目的对象</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s：进行软链接</span><br><span class="line">不用-s：进行硬链接</span><br></pre></td></tr></table></figure><p><strong>硬链接</strong>：文件的副本（别名），同时两者存在连接关系，<strong>修改其中一个另一个也会一同被修改，删除一个，另一个不受影响</strong>。两者在<strong>硬盘上只有一份数据</strong>，只存在于同一个文件系统中。</p><p><strong>软链接</strong>：<strong>一个快捷方式</strong>，是一个内容指向另一个文件位置的特殊文件。删了源文件就没用了。可以跨越文件系统。</p><p>个人理解：</p><p><img src="/Blog/Linux/Linux总结/硬链接和软链接图示.png" alt="硬链接和软链接图示"></p><hr><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>改变目录或文件的权限</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [选项] &lt;mode&gt; &lt;文件名或目录&gt;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R：递归对目录下的所有子文件与子目录进行相同的权限变更</span><br></pre></td></tr></table></figure><p><strong>权限修改：</strong></p><ol><li>用数字修改</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4:r</span><br><span class="line">2:w</span><br><span class="line">1:x</span><br><span class="line">例如775就是rwxrwxr-x</span><br><span class="line">示例：chmod 775 file.txt</span><br></pre></td></tr></table></figure><ol start="2"><li>用指令修改权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u：所有者user</span><br><span class="line">g：组group</span><br><span class="line">o：其他other</span><br><span class="line">+：增加权限</span><br><span class="line">-：取消权限</span><br><span class="line">示例：chmod g+w,o+w,o-r file.txt</span><br></pre></td></tr></table></figure><hr><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>改变指定目录或文件(用-R)的所属用户、所属组</p><p><strong>权限：</strong>root</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [选项] 用户名[：组名] 文件或目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R：递归对子文件或目录操作</span><br></pre></td></tr></table></figure><hr><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>改变文件/目录的所属组</p><p><strong>权限：</strong>所有使用者</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [选项] 组名 文件或目录名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R：递归对子文件或目录操作</span><br></pre></td></tr></table></figure><hr><h2 id="文字显示-文件操作"><a href="#文字显示-文件操作" class="headerlink" title="文字显示/文件操作"></a>文字显示/文件操作</h2><hr><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>显示文件内容</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-n：显示行号</span><br></pre></td></tr></table></figure><hr><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>分页显示文件内容</p><p>b上一页，空格下一页，回车下一行，</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [选项参数] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项参数：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&lt;数字&gt;：指定每屏显示的行数</span><br><span class="line">+&lt;数字&gt;：从指定数字的行开始显示</span><br><span class="line">-c：不进行滚屏操作。每次刷新这个屏幕</span><br><span class="line">-s：将多个空行压缩成一行</span><br></pre></td></tr></table></figure><hr><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>分页显示文件内容，与more十分相似，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。more读的时候会全部加载，而less部分加载，所以less有时候会更快。</p><p>PageUp键上翻页，PageDown向下翻。Q键退出。 </p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [选项] 文件</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n：显示行号</span><br><span class="line">-s：多个空行压缩成一行</span><br></pre></td></tr></table></figure><hr><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>显示文件前N行内容或前N个字节，默认为前10行</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [选项] 文件</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-n&lt;数字&gt; ：显示前N行</span><br><span class="line">-c&lt;数字&gt; ：显示前N个字节</span><br><span class="line">-v：同时显示文件名</span><br></pre></td></tr></table></figure><hr><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>显示文件后N行内容或前N个字节，默认为前10行</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [选项] 文件</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-n&lt;数字&gt; ：显示后N行</span><br><span class="line">-c&lt;数字&gt; ：显示后N个字节</span><br><span class="line">-v：同时显示文件名</span><br></pre></td></tr></table></figure><hr><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>从文件中过滤或提取特定内容并显示</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-d&lt;分隔符&gt;：指定分隔符号（可用引号包起来）</span><br><span class="line">-f&lt;list&gt;：指定提取的列（可以是-f1，也可以是 -f2-5，-f2,4 这样的范围）</span><br><span class="line">-c&lt;list&gt;：仅显示行中指定范围的字符</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost text]<span class="comment"># cut -f2,4 -d";" test.txt </span></span><br><span class="line">Name Mark</span><br><span class="line">tom 69</span><br><span class="line">jack 71</span><br><span class="line">alex 68</span><br></pre></td></tr></table></figure><hr><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>（wordcount）统计一个文件多少字/字节/行</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c：只显示字节Bytes数；（char（字节)）</span><br><span class="line">-l：只显示列数；（line）</span><br><span class="line">-w：只显示字数。（word）</span><br><span class="line">无参数默认统计行、字、字节数</span><br></pre></td></tr></table></figure><hr><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>对输出的内容进行排序（不改变文件）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r：反向排序(reverse)</span><br><span class="line">-n：数字排序（number）</span><br><span class="line">-f：不区分大小写</span><br></pre></td></tr></table></figure><hr><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>显示文字</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> [选项] 字符串</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n：最后不换行</span><br><span class="line">-e：输出一个空行</span><br></pre></td></tr></table></figure><hr><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p>日历显示</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal [选项] [[月] 年]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无参数则本月日历</span><br><span class="line">-y：显示今年日历</span><br><span class="line">-m：周一为第一天</span><br></pre></td></tr></table></figure><hr><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>显示系统时间 或 设定系统时间</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date [选项] [+format]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-d &lt;dateStr&gt;：显示 字符串所指的日期与时间。字符串须加双引号；</span><br><span class="line">-s &lt;dateStr&gt;：设置 字符串表示的日期与时间。字符串须加双引号；</span><br></pre></td></tr></table></figure><p><strong>日期格式字符串列表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">%H 小时，24小时制（00~23）</span><br><span class="line">%I 小时，12小时制（01~12）</span><br><span class="line">%k 小时，24小时制（0~23）</span><br><span class="line">%l 小时，12小时制（1~12）</span><br><span class="line">%M 分钟（00~59）</span><br><span class="line">%p 显示出AM或PM</span><br><span class="line">%r 显示时间，12小时制（hh:mm:ss %p）</span><br><span class="line">%s 从1970年1月1日00:00:00到目前经历的秒数</span><br><span class="line">%S 显示秒（00~59）</span><br><span class="line">%T 显示时间，24小时制（hh:mm:ss）</span><br><span class="line">%X 显示时间的格式（%H:%M:%S）</span><br><span class="line">%Z 显示时区，日期域（CST）</span><br><span class="line">%a 星期的简称（Sun~Sat）</span><br><span class="line">%A 星期的全称（Sunday~Saturday）</span><br><span class="line">%b 月的简称（Jan~Dec）</span><br><span class="line">%B 月的全称（January~December）</span><br><span class="line">%c 日期和时间（Tue Nov 20 14:12:58 2012）</span><br><span class="line">%d 一个月的第几天（01~31）</span><br><span class="line">%x,%D 日期（mm/dd/yy）</span><br><span class="line">%j 一年的第几天（001~366）</span><br><span class="line">%m 月份（01~12）</span><br><span class="line">%w 一个星期的第几天（0代表星期天）</span><br><span class="line">%W 一年的第几个星期（00~53，星期一为第一天）</span><br><span class="line">%y 年的最后两个数字（00-99）</span><br><span class="line">%Y 完整年份(0000-9999)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>格式化输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date +<span class="string">"%Y-%m-%d"</span></span><br><span class="line">2009-12-07</span><br></pre></td></tr></table></figure><p>设置时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date -s 20120523               //设置成20120523，这样会把具体时间设置成空00:00:00</span><br><span class="line">date -s 01:01:01               //设置具体时间，不会对日期做更改</span><br><span class="line">date -s <span class="string">"01:01:01 2012-05-23"</span>  //这样可以设置全部时间</span><br></pre></td></tr></table></figure><hr><p>###grep</p><p>行搜索工具</p><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v<span class="comment"># 不包含</span></span><br></pre></td></tr></table></figure><hr><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>对标准输入的字符进行替换、压缩和删除 </p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr [选项] 字符串1 字符串2</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-d<span class="comment"># 删除字符1中出现的输入字符</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tr <span class="string">'a-z'</span> <span class="string">'A-Z'</span> &lt; works.txt</span><br><span class="line">LINUX</span><br><span class="line">UNIX</span><br><span class="line">MAC OS</span><br><span class="line"></span><br><span class="line">$ cat works.txt | tr <span class="string">"abc"</span> <span class="string">"xyz"</span></span><br><span class="line">Linux</span><br><span class="line">Unix</span><br><span class="line">Mxz OS</span><br></pre></td></tr></table></figure><hr><h2 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] 目录或文件</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-zcvf<span class="comment"># 压缩</span></span><br><span class="line">-zxvf<span class="comment"># 解压</span></span><br><span class="line">-z<span class="comment"># 用gzip压缩/解压(.gz)</span></span><br><span class="line">-c<span class="comment"># 打包（create）</span></span><br><span class="line">-x<span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><hr><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>压缩：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip File</span><br></pre></td></tr></table></figure><p><strong>解压：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d file.gz</span><br></pre></td></tr></table></figure><hr><h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><p>解压zip文件</p><p><strong>解压：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -x File.zip</span><br></pre></td></tr></table></figure><hr><h2 id="联机、帮助指令"><a href="#联机、帮助指令" class="headerlink" title="联机、帮助指令"></a>联机、帮助指令</h2><p>获取命令的帮助</p><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man [选项] 命令或配置文件</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ls</span><br></pre></td></tr></table></figure><hr><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info &lt;命令名&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> [命令名]</span><br></pre></td></tr></table></figure><hr><h3 id="–help参数"><a href="#–help参数" class="headerlink" title="–help参数"></a>–help参数</h3><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;命令&gt; --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><hr><h2 id="文本格式转换"><a href="#文本格式转换" class="headerlink" title="文本格式转换"></a>文本格式转换</h2><h3 id="unix2dos-dos2unix"><a href="#unix2dos-dos2unix" class="headerlink" title="unix2dos, dos2unix"></a>unix2dos, dos2unix</h3><table><thead><tr><th>系统</th><th>换行符</th></tr></thead><tbody><tr><td>windows</td><td>^M^J<br>(回车换行)</td></tr><tr><td>Linux</td><td>^J<br>(换行)</td></tr></tbody></table><h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="磁盘设备描述"><a href="#磁盘设备描述" class="headerlink" title="磁盘设备描述"></a>磁盘设备描述</h2><p>前两个字母：设备类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hd<span class="comment"># IDE硬盘</span></span><br><span class="line">sd<span class="comment"># SCSI硬盘(U盘)</span></span><br></pre></td></tr></table></figure><p>第三个字母：设备编号</p><p>数字：分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sda2：第1块SCSI硬盘的第1个分区</span><br><span class="line">sdb1：第2块SCSI硬盘的第1个分区</span><br></pre></td></tr></table></figure><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ol><li><p><strong>FAT</strong></p><p>早期<strong>Windows</strong>的文件系统</p></li><li><p><strong>NTFS</strong></p><p>目前<strong>Windows</strong>普遍的文件系统</p></li><li><p><strong>Ext</strong></p><p><strong>Linux</strong>引入的可扩展文件系统</p></li><li><p><strong>VFS</strong></p><p><strong>Linux的虚拟文件系统</strong>，（接口层），屏蔽不同的文件系统，实现对各种文件系统的支持。</p></li></ol><h2 id="fdisk-l"><a href="#fdisk-l" class="headerlink" title="fdisk -l"></a>fdisk -l</h2><p>查看本机硬盘及分区情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x0008de3e</span><br><span class="line"></span><br><span class="line">Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048    83884031    41940992   83  Linux</span><br></pre></td></tr></table></figure><h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p>挂载设备</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [选项] 设备名 挂载点</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-t &lt;文件系统类型&gt;</span><br><span class="line">-o &lt;选项&gt; 如ro, rw, auto, iocharset等</span><br></pre></td></tr></table></figure><h2 id="挂载过程"><a href="#挂载过程" class="headerlink" title="挂载过程"></a>挂载过程</h2><ol><li><strong>获取设备名</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">查看设备名</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>建立挂载点目录</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/目录名</span><br><span class="line">建立mnt目录下的挂载点</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>mount 命令挂载</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount 设备名 挂载点</span><br></pre></td></tr></table></figure><h2 id="umount-卸载设备命令"><a href="#umount-卸载设备命令" class="headerlink" title="umount 卸载设备命令"></a>umount 卸载设备命令</h2><p>卸载挂载的设备</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount 挂载点/设备名</span><br></pre></td></tr></table></figure><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="mkfs"><a href="#mkfs" class="headerlink" title="mkfs"></a>mkfs</h3><p>格式化硬盘分区（创建文件系统）(mkFileSystem)</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t 文件系统 设备名</span><br></pre></td></tr></table></figure><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>查看磁盘使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [选项]</span><br></pre></td></tr></table></figure><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>统计目录或文件所占磁盘空间大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [选项] 目录名</span><br></pre></td></tr></table></figure><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><p><strong>交互进程：</strong>由Shell启动的进程</p><p><strong>守护进程：</strong>在后台运行的进程</p><p><strong>批处理进程：</strong>管理进程的序列</p><p>进程的属性：PID, PPID(父进程ID), UID, GID, 状态, 优先级, 资源占用</p><p>杀终止父进程会连带终止子进程</p><p>系统的第一个进程init(PID=1)（所有进程的父进程）</p><h2 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h2><h3 id="手工启动线程"><a href="#手工启动线程" class="headerlink" title="手工启动线程"></a>手工启动线程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxx &amp;<span class="comment"># 后台运行程序加"&amp;"</span></span><br></pre></td></tr></table></figure><h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><p>指定时间执行命令序列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at [选项] TIME</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-l<span class="comment"># 列出所有作业（可以使用atq）</span></span><br><span class="line">-d<span class="comment"># 删除作业（可以使用atrm）</span></span><br></pre></td></tr></table></figure><hr><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>显示瞬间进程动态（另外，top指令可以动态监控进程）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e<span class="comment"># 显示所有进程</span></span><br><span class="line">-a<span class="comment"># 显示所有进程，包括其他用户的进程</span></span><br><span class="line">-x<span class="comment"># 显示所有控制终端的进程</span></span><br></pre></td></tr></table></figure><hr><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><p>以树状结构显示系统中的所有进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree [选项] [PID|User]</span><br></pre></td></tr></table></figure><p>可以指定显示指定PID的信息 或 指定User的进程信息</p><hr><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>结束进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-s signal] PID</span><br><span class="line"><span class="built_in">kill</span> -l<span class="comment"># 列出所有可用的信号</span></span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-s signal<span class="comment"># 指定信号。重启(1)，强制杀死(9)，结束(10)</span></span><br></pre></td></tr></table></figure><hr><h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><p>查看后台进程</p><h3 id="ctrl-Z"><a href="#ctrl-Z" class="headerlink" title="ctrl+Z"></a>ctrl+Z</h3><p>挂起当前线程</p><h3 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h3><p>前台执行进程</p><p><code>fg PID</code></p><h3 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h3><p>后台执行进程</p><hr><h2 id="crontab-周期性执行程序"><a href="#crontab-周期性执行程序" class="headerlink" title="crontab 周期性执行程序"></a>crontab 周期性执行程序</h2><p>周期性执行程序</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] &#123;-l | -r | -e&#125;</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e<span class="comment"># 编辑时程表</span></span><br><span class="line">-r<span class="comment"># 删除目前时程表</span></span><br><span class="line">-l<span class="comment"># 列出目前时程表</span></span><br></pre></td></tr></table></figure><h3 id="crontab文件编写"><a href="#crontab文件编写" class="headerlink" title="crontab文件编写"></a>crontab文件编写</h3><p><strong>格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1 f2 f3 f4 f5 program</span><br><span class="line">m, h, d-M, M-y, d-W program</span><br><span class="line">分钟 小时 月中的天 月 周中的天 program</span><br></pre></td></tr></table></figure><p><strong>特殊格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="comment"># 每个时间点都要执行</span></span><br><span class="line">a-b<span class="comment"># a-b时间点内都要执行</span></span><br><span class="line">*/n<span class="comment"># 每n个时间点都要执行1次</span></span><br><span class="line">a,b,c<span class="comment"># 第a,b,c,个时间点要执行</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每个月每天的12点都要执行wall hello</span><br><span class="line">0 12 * * * wall hello</span><br><span class="line">在12月内，每天早上6点到12点中的每3个小时，每个20分钟执行一次command</span><br><span class="line">*/20 6-12/3 * 12 * command</span><br></pre></td></tr></table></figure><hr><h1 id="系统监视"><a href="#系统监视" class="headerlink" title="系统监视"></a>系统监视</h1><h2 id="系统监视指令"><a href="#系统监视指令" class="headerlink" title="系统监视指令"></a>系统监视指令</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>动态监视进程和信息指令（进化版的ps）</p><p><strong>操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">space<span class="comment"># 刷新</span></span><br><span class="line">h<span class="comment"># 帮助</span></span><br><span class="line">k<span class="comment"># 杀死某进程</span></span><br><span class="line">u<span class="comment"># 显示指定用户</span></span><br><span class="line">P<span class="comment"># 按CPU使用情况排序</span></span><br><span class="line">q<span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>内存查看命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-b<span class="comment"># B字节单位显示</span></span><br><span class="line">-k<span class="comment"># KB单位</span></span><br><span class="line">-m<span class="comment"># MB单位</span></span><br></pre></td></tr></table></figure><h2 id="日志监视"><a href="#日志监视" class="headerlink" title="日志监视"></a>日志监视</h2><p>日志存放于/var/log目录下</p><h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p><strong>1. BIOS初始化</strong></p><p>加载和引导设备，启动操作系统</p><p><strong>2. 内核初始化</strong></p><ol><li>硬件设备检测</li><li>设备驱动初始化</li><li>只读挂载文件系统</li><li>启动第一个进程init（PID=1，所有进程的父进程，失去父进程的子进程都以init作为父进程）</li></ol><p><strong>3. 确定系统运行级别</strong></p><p>init读取配置文件<strong>/etc/inittab</strong></p><p>修改系统默认运行级别：修改其中数字</p><p><code>id:5:initdefault</code></p><p><strong>4. 运行初始化脚本</strong></p><p><strong>5. 运行用户自定义脚本</strong></p><p>修改/etc/rc.d/rc.local</p><p><strong>6. 激活控制台</strong></p><p><strong>7. 启动界面</strong></p><h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><h2 id="网络设置文件"><a href="#网络设置文件" class="headerlink" title="网络设置文件"></a>网络设置文件</h2><table><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td>/etc/hosts</td><td>域名或主机名与IP的映射文件。本机查询DNS</td></tr><tr><td>/etc/sysconfig/network-scripts/ifcfg-ethN</td><td>ethN网卡的配置信息</td></tr><tr><td>/etc/sysconfig/network</td><td>最基本的网络配置信息，系统启动时读取</td></tr><tr><td>/etc/resolv.conf</td><td>域名服务器配置文件</td></tr><tr><td>/etc/host.conf</td><td>域名解析的配置文件，指定如何解析</td></tr><tr><td>/etc/services</td><td>网络服务和端口的映射文件，设定主机不同端口号的网络服务</td></tr><tr><td>/etc/protocols</td><td>描述网络协议及其对应协议号</td></tr></tbody></table><h2 id="网络管理命令"><a href="#网络管理命令" class="headerlink" title="网络管理命令"></a>网络管理命令</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>查看或配置网卡状态</p><p><strong>查看状态：</strong><code>ifconfig</code></p><p><strong>查看单独显卡状态：</strong><code>ifconfig eth0</code></p><p><strong>停止</strong>显卡：<code>down</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure><p><strong>激活</strong>显卡： <code>up</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 dp</span><br></pre></td></tr></table></figure><p><strong>设置</strong>设备<strong>IP地址和子网掩码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig &lt;设备名&gt; &lt;IP&gt; netmask &lt;掩码&gt;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong><code>ifconfig eth0 192.168.0.17 netmask 255.255.255.0</code></p><p>以上修改都是临时性的（永久的修改需要修改<code>/etc/sysconfig/network-scripts/ifcfg-ethN</code>文件修改）</p><hr><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>测试网络是否联通。</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [选项] 地址</span><br></pre></td></tr></table></figure><hr><h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>显示数据包到主机之间的路径</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute [选项] 地址</span><br></pre></td></tr></table></figure><hr><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p>显示路由表 / 添加删除路由记录</p><p>显示路由表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route</span><br></pre></td></tr></table></figure><p>添加|删除网关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route &lt;add|del&gt; default gw 网关IP</span><br></pre></td></tr></table></figure><p>添加 | 删除路由记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route &lt;add|del-net&gt; 网络号 netmask 掩码 dev 设备名</span><br></pre></td></tr></table></figure><hr><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>显示网络状态（端口开放情况）</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [选项]</span><br></pre></td></tr></table></figure><p><strong>选项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i<span class="comment"># 列出每个显卡</span></span><br></pre></td></tr></table></figure><hr><h2 id="网络服务管理"><a href="#网络服务管理" class="headerlink" title="网络服务管理"></a>网络服务管理</h2><h3 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h3><p>检查和设置系统的各种服务</p><p>添加/删除指定的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add|del 服务名</span><br></pre></td></tr></table></figure><p>显示所有或指定的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list [服务名]</span><br></pre></td></tr></table></figure><p>检查指定服务的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig 服务名</span><br></pre></td></tr></table></figure><p>改变服务运行级别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig [--level 运行级别(3/4/5)] 服务名 状态(on/off/reset)</span><br></pre></td></tr></table></figure><hr><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>对系统服务管理（启动、停止、重启、查看状态）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service 服务名 [start|stop|restart|status]</span><br></pre></td></tr></table></figure><hr><p>chkconfig和service的区别：前者重启后仍然生效，后者不然</p><hr><h2 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h2><ol><li><strong>独立守护进程工作模式：</strong>一个守护进程响应一个特定的端口的服务或连接（每个服务都对应一个守护进程，会导致资源浪费。）(也叫stand-alone模式)</li><li><strong>基于xinetd的工作模式：</strong>xinetd进程同时监听多个端口，在接收请求时根据端口号来启动不同的服务进程处理请求。（流量小开销小，流量大时由于频繁启动服务进程导致性能下降）</li></ol><h3 id="Telnet服务"><a href="#Telnet服务" class="headerlink" title="Telnet服务"></a>Telnet服务</h3><p>远程登陆应用。基于xinetd的服务。</p><p><strong>使用：</strong></p><ol><li>安装krb5-telnet</li><li>编辑/etc/xinetd.d/krb5-telnet配置文件（在此之前可能要改xinetd配置文件/etc/xinetd.conf文件），编辑/etc/securetty文件</li><li>重启服务 <code>service xinetd restart</code></li></ol><p>需要用非root普通用户登陆</p><p><strong>停止：</strong></p><p>关闭xinetd服务（telnet受xinetd管理，所以关闭xinetd即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service xinetd stop</span><br></pre></td></tr></table></figure><hr><h3 id="FTP服务"><a href="#FTP服务" class="headerlink" title="FTP服务"></a>FTP服务</h3><p>FTP文件传输协议，支持standalone模式和xinetd模式。</p><p><strong>配置文件：</strong></p><ol><li>/etc/vsftpd/vsftpd.conf：主配置文件</li><li>/etc/vsftpd.ftpusers：禁用用户列表</li><li>/etc/vsftpd.user_list：</li></ol><p><strong>启动vsFTPd</strong></p><p><code>service vsftpd [start | stop | restart]</code></p><p><strong>需要关闭防火墙</strong></p><p><strong>使用操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lcd<span class="comment"># 切换本机目录</span></span><br><span class="line">get &lt;filename&gt;<span class="comment"># 从FTP下载到本地</span></span><br><span class="line">put &lt;filename&gt;<span class="comment"># 从本地上传到FTP</span></span><br><span class="line">close<span class="comment"># 关闭ftp会话</span></span><br><span class="line">open<span class="comment"># 连接ftp站点</span></span><br><span class="line">quit<span class="comment"># 断开连接并退出</span></span><br></pre></td></tr></table></figure><hr><h3 id="SElinux-访问控制"><a href="#SElinux-访问控制" class="headerlink" title="SElinux 访问控制"></a>SElinux 访问控制</h3><p>在SELinux的访问控制限制下，进程只能访问那些在其任务中所需要的文件。</p><h3 id="www"><a href="#www" class="headerlink" title="www"></a>www</h3><p>web服务，用的是httpd服务</p><p>启动httpd</p><p><code>service httpd [start | stop | restart]</code></p><p><strong>httpd的配置文件：</strong></p><p><strong>/etc/httpd/conf/http.conf</strong></p><hr><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;根据自己的记忆和理解方式，总结了最近学习和接触到的Linux理论和指令。&lt;/p&gt;
&lt;p&gt;涉及Linux目录，文件管理，系统，设备管理，进程管理，网络管理，用户管理等。&lt;/p&gt;
&lt;p&gt;（此外，Vi使用 以及 Shell脚本编写在别篇）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://uncleaaron.github.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>第5章 Java中的锁</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC5%E7%AB%A0-Java%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java并发编程艺术/第5章-Java中的锁/</id>
    <published>2018-06-06T07:03:00.000Z</published>
    <updated>2018-07-20T11:39:27.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本章总结了Lock接口，队列同步器(<code>AbstractQueuedSynchronizer</code>)，可重用锁<code>ReentrantLock</code></p></blockquote><a id="more"></a><h1 id="第5章-Java中的锁"><a href="#第5章-Java中的锁" class="headerlink" title="第5章 Java中的锁"></a>第5章 Java中的锁</h1><h2 id="一、Lock接口"><a href="#一、Lock接口" class="headerlink" title="一、Lock接口"></a>一、Lock接口</h2><p><strong>显式获取/释放锁</strong>，具有可操作性、<strong>可中断的获取</strong>锁，以及<strong>超时获取锁</strong>等功能。（相比<code>synchronized</code>关键字隐式锁，缺失了点隐式锁的便捷性，但功能可操作性更强。synchronized虽然可以隐式、简化锁管理，但是固化了操作，缺乏可扩展性）</p><p><strong>基本使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">// 声明可重用锁</span></span><br><span class="line">lock.lock();<span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;<span class="comment">// 不要将获取锁卸载try块中，避免异常抛出时被无故释放锁</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();<span class="comment">// 🔺 在finally中释放锁，保证锁获取之后能被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要特性：</strong>（除了普通自旋的获取锁外，其他的特性）</p><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>尝试非阻塞地获取锁</strong></td><td style="text-align:left">当前线程尝试获取锁，如果这一时刻锁没被其他线程占有，则成功获取并持有锁（此方式将只获取依次，在获取时刻内立即返回，不进行自旋）</td></tr><tr><td style="text-align:left"><strong>可被中断地获取锁</strong></td><td style="text-align:left">当获取到锁的线程被中断时，抛出中断异常，并释放锁（与synchronized不同）</td></tr><tr><td style="text-align:left"><strong>超时获取锁</strong></td><td style="text-align:left">在指定时间前获取锁，否则无法获取锁，自动返回</td></tr></tbody></table><p><strong>Lock接口的API：</strong></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><strong>void lock()</strong></td><td><strong>自旋地获取锁</strong>，直到获取后才返回</td></tr><tr><td><strong>void lockInterruptibly() <code>throws InterruptException</code></strong></td><td><strong>可响应中断的获取锁</strong>，在锁获取的过程中可以中断当前线程。</td></tr><tr><td><strong>boolean tryLock()</strong></td><td><strong>尝试非阻塞的获取锁</strong>，<strong>调用后立即返回</strong>，成功获取则返回true，否则返回false</td></tr><tr><td><strong>boolean tryLock(long time, TimeUni unit) <code>throws InterruptException</code></strong></td><td><strong>超时获取锁</strong>，在以下情况返回<br>① 当前线程在超时时间内获取锁<br>② 当前线程在超时时间内被中断<br>③ 超时结束，失败返回false</td></tr><tr><td><strong>void unlock()</strong></td><td><strong>释放锁</strong></td></tr><tr><td><strong>Condition newCondition()</strong></td><td><strong>获取等待通知的组件</strong>，该组件和当前的锁绑定。当前线程只有获得了锁，才能调用该组件的wait() 方法，<strong>调用后，当前线程释放锁。</strong></td></tr></tbody></table><p>Lock接口的实现一般都是通过聚合使用一个同步器<code>AbstracQueuedSynchronizer</code>的子类实现访问控制的。</p><p><img src="/Blog/Java/Java并发编程艺术/第5章-Java中的锁/Lock实现.png" alt="Lock实现"></p><h2 id="二、队列同步器AbstractQueuedSynchronizer"><a href="#二、队列同步器AbstractQueuedSynchronizer" class="headerlink" title="二、队列同步器AbstractQueuedSynchronizer"></a>二、队列同步器AbstractQueuedSynchronizer</h2><p>队列同步器（简称同步器）AbstractQueuedSynchronizer</p><p>是用来<strong>构建锁和同步组件的基本框架</strong>，使用一个<strong>int表示同步状态</strong>，使用一个FIFO<strong>队列完成获取资源的线程的排队</strong>工作。</p><blockquote></blockquote><p>同步器主要使用方式：<strong>继承</strong></p><p><strong>子类继承同步器</strong>定义为自定义同步组件的<strong>静态内部类</strong>，通过调用已提供的方法来<strong>实现其抽象方法</strong>来管理同步状态。</p><p>同步器已经提供了3个方法来访问和修改同步状态供子类使用：</p><ul><li><strong><code>getState()</code>：</strong>获取当前同步状态</li><li><strong><code>setState(int newState)</code>：</strong>设置当前同步状态</li><li><strong><code>compareAndSetState( int expect, int update )</code>：</strong>使用CAS设置当前状态，该方法保证状态设置的原子性</li></ul><p>同步器可重写的方法：（包括独占式获取/释放同步状态）</p><table><thead><tr><th>方法名</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>protected boolean tryAcquire(int arg)</td><td><strong>独占式获取同步状态</strong>。</td><td>实现该方法需要<strong>使用CAS</strong>操作查询是否符合预期后再设置同步状态</td></tr><tr><td>protected boolean tryRelease(int arg)</td><td><strong>独占式释放同步状态。</strong></td><td>等待获取同步状态的线程将有机会获取同步状态</td></tr><tr><td>protected int tryAcquireShared(int arg)</td><td>共享式获取同步状态</td><td>获取成功则返回&gt;=0的值。否则失败</td></tr><tr><td>protected boolean tryReleaseShared(int arg)</td><td>共享式释放同步状态</td><td></td></tr><tr><td>protected boolean isHeldExclusively()</td><td>当前同步器是否线程被独占</td></tr></tbody></table><p>同步器提供的模板方法：</p><p>大致分为3类：</p><ul><li><strong>独占式获取与释放</strong>同步状态：<code>acquire</code>/<code>release</code>（另含<code>aquireInterruptibly</code>响应中断操作和<code>tryAcquireNanos</code>超时等待操作）</li><li><strong>共享式获取与释放</strong>同步状态：<code>acquireShared</code>/<code>releaseShared</code>（另含<code>aquireSharedInterruptibly</code>响应中断操作和<code>tryAcquireSharedNanos</code>超时等待操作）</li><li><strong>查询同步队列中的等待情况</strong>：<code>Collection&lt;Thread&gt; getQueuedThreads()</code></li></ul><h3 id="利用同步器实现的独占锁示例："><a href="#利用同步器实现的独占锁示例：" class="headerlink" title="利用同步器实现的独占锁示例："></a>利用同步器实现的独占锁示例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用静态内部类 实现 自定义同步器</span></span><br><span class="line">    <span class="comment">// 这样就屏蔽了同步器的操作，用户只需要使用Mutex包装同步器的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"><span class="comment">// 是否处于占用状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getState() == <span class="number">1</span>;<span class="comment">// getState()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当状态为0的时候获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">// CAS操作</span></span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());<span class="comment">// 设置拥有者线程</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放锁，将状态设置为0</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span><span class="comment">// 若没有被占用（同步状态为0）则抛出异常</span></span><br><span class="line">IllegalMonitorStateException();</span><br><span class="line">setExclusiveOwnerThread(<span class="keyword">null</span>);<span class="comment">// 否则被占用了，就设置拥有者线程为空</span></span><br><span class="line">setState(<span class="number">0</span>);<span class="comment">// 然后置0同步状态，表示不被占用</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">// 同步器内部类结束</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 仅需要将同步器提供的操作代理到Sync上即可</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();<span class="comment">// 创建一个自定义同步器，用此实现后面的自定义方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;sync.acquire(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;sync.release(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> sync.newCondition();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> sync.isHeldExclusively();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> sync.hasQueuedThreads();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-队列同步器的内部实现"><a href="#2-2-队列同步器的内部实现" class="headerlink" title="2.2. 队列同步器的内部实现"></a>2.2. 队列同步器的内部实现</h3><p>实现机制主要包括：同步队列、独占式同步状态获取和释放、共享式同步状态获取和释放。</p><h4 id="2-2-1-同步队列"><a href="#2-2-1-同步队列" class="headerlink" title="2.2.1. 同步队列"></a>2.2.1. 同步队列</h4><ul><li><p>同步队列是一个<strong>FIFO双向队列</strong>，每个节点保存前驱和后继节点以及对应线程。</p></li><li><p>同步队列存放<strong>获取同步状态失败的线程</strong>。</p></li><li>当同步状态<strong>释放时，唤醒首节点</strong>，后面的节点的唤醒通过前驱节点出队或被中断实现。</li><li><strong>插入队列使用CAS</strong>确保原子性（因为可能会有并发插入场景），而队列头节点<strong>出队不需要CAS</strong>（因为出队只有一个线程能够获取同步状态）。</li><li>节点在同步状态中会自旋检查同步状态，但只有前驱节点是头节点时才能尝试获取同步状态。</li><li>移出队列（停止自旋）的条件是：前驱节点是头节点且成功获取了同步状态。</li></ul><p><img src="/Blog/Java/Java并发编程艺术/第5章-Java中的锁/节点自旋获取同步状态.png" alt="节点自旋获取同步状态"></p><h4 id="2-2-2-独占式获取同步状态"><a href="#2-2-2-独占式获取同步状态" class="headerlink" title="2.2.2. 独占式获取同步状态"></a>2.2.2. 独占式获取同步状态</h4><p>流程：（同一时刻只能有一个线程访问同步状态）</p><p><img src="/Blog/Java/Java并发编程艺术/第5章-Java中的锁/独占式获取同步状态流程.png" alt="独占式获取同步状态流程"></p><h4 id="2-2-3-共享式同步状态："><a href="#2-2-3-共享式同步状态：" class="headerlink" title="2.2.3. 共享式同步状态："></a>2.2.3. 共享式同步状态：</h4><p>同一个时刻能有多个线程同时获取到同步状态（如读写文件时，可多进程同时读1个文件，此时写被阻塞；当文件在写入时，所有读和其他写被阻塞）写为独占，读为共享。</p><ul><li>使用<strong>共享式同步状态</strong>的并发组件<strong>必须使用CAS确保释放资源的原子性</strong></li></ul><h3 id="锁和同步器的关系"><a href="#锁和同步器的关系" class="headerlink" title="锁和同步器的关系"></a>锁和同步器的关系</h3><p>同步器是实现锁的关键。</p><blockquote><p>锁是面向使用者的，定义了使用者和锁之间的接口，隐藏了实现细节。同步器面向锁的实现者，简化锁的实现方式，隐藏了同步状态管理、线程排队、等待唤醒的操作。</p></blockquote><h2 id="三、-重入锁ReentrantLock"><a href="#三、-重入锁ReentrantLock" class="headerlink" title="三、 重入锁ReentrantLock"></a>三、 重入锁ReentrantLock</h2><p><strong>ReentrantLock重入锁</strong>：支持重进入的锁，表示该锁<strong>支持一个线程对资源重复加锁</strong>。有公平性和非公平性选择。</p><p>重进入：已经获取到锁的线程能够再次调用lock()而不被锁阻塞。</p><ul><li>其实synchronized关键字隐式支持了重进入（如synchronized修饰的递归方法）</li></ul><p>公平性：等待时间最长的线程优先获取锁（请求先到先得FIFO，符合请求的绝对时间顺序）</p><p>非公平性：就是不公平性</p><ul><li>公平虽然能减少“饥饿”，但效率其实没有非公平高，因为会造成更多的线程交换。</li></ul><h3 id="实现重进入"><a href="#实现重进入" class="headerlink" title="实现重进入"></a>实现重进入</h3><p>线程再次获取锁：识别当前线程是否为当前占据锁的线程，是则成功获取。</p><p>锁的最终释放：重复n次获取锁后，再释放n次时，其他线程能获取到该锁。</p><p>非公平锁：</p><p>获取锁需要CAS原子操作（非公平情况下会产生并发问题）</p><p>释放锁时不存在并发，不需要CAS</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本章总结了Lock接口，队列同步器(&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;)，可重用锁&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java并发编程艺术" scheme="https://uncleaaron.github.io/Blog/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="并发编程" scheme="https://uncleaaron.github.io/Blog/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>第4章 Java并发编程基础</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC4%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java并发编程艺术/第4章-Java并发编程基础/</id>
    <published>2018-06-01T12:46:25.000Z</published>
    <updated>2018-07-19T12:14:32.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本章主要讲解Java的线程Thread，线程的6个状态，Daemon守护线程，线程的生存周期操作（构造、启动、中断、终止），以及线程的几种通信方式：volatile和synchronized提供的内存可见性保障，等待/通知机制wait/notify，管道流，Thread.join() 以及 ThreadLocal变量。</p><p>最后还示例了线程池、数据库连接池的简单实现，篇幅较大，暂时未补充，需要自己阅读书本。</p></blockquote><a id="more"></a><h1 id="第4章-Java并发编程基础"><a href="#第4章-Java并发编程基础" class="headerlink" title="第4章 Java并发编程基础"></a>第4章 Java并发编程基础</h1><h2 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h2><p>线程是现代操作系统调度的最小单位，拥有各自的计数器、堆栈和局部变量等属性，能够访问共享的内存变量。</p><p>实际上Java程序天生就是多线程程序，执行main()会启用一个主线程，同时还会启用其他的一些辅助线程。</p><h3 id="1-1-线程优先级-priority"><a href="#1-1-线程优先级-priority" class="headerlink" title="1.1. 线程优先级(priority)"></a>1.1. 线程优先级(priority)</h3><p>现代操作系统基本采用时分调度线程，会分出多个时间片，一个线程会分配到若干时间片，时间片用完了就会发生线程调度，等待下次分配。</p><p><strong>线程优先级决定分配到的时间片和处理器资源多少的线程属性。优先级高的线程分配的时间片数量更多。</strong></p><p>Java线程中使用一个整型的变量priority来控制优先级，范围是1~10，线程构建的时候使用setPriority(int)修改优先级，优先级默认是5。</p><p>设置线程优先级的原则：</p><ul><li>针对频繁阻塞（休眠或I/O操作）的线程需要设置较高优先级。</li><li>偏重计算（需要较多CPU时间）的线程设置较低优先级，从而避免处理器被独占。</li></ul><p>但实际上有些JVM或者操作系统会无视Priority的设定，所以<strong>线程优先级不能作为程序正确性的依赖</strong>。</p><h3 id="1-2-线程的状态"><a href="#1-2-线程的状态" class="headerlink" title="1.2. 线程的状态"></a>1.2. 线程的状态</h3><p><strong>表4-1 Java线程的状态（6种）</strong></p><table><thead><tr><th style="text-align:center">状态名称</th><th style="text-align:center">状态</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>NEW</strong></td><td style="text-align:center"><strong>初始态</strong></td><td style="text-align:left">线程被构建，但是还没调用start()方法</td></tr><tr><td style="text-align:center"><strong>RUNNABLE</strong></td><td style="text-align:center"><strong>运行态</strong></td><td style="text-align:left">Java线程将操作系统中的就绪态和运行态统称为“运行中”</td></tr><tr><td style="text-align:center"><strong>BLOCKED</strong></td><td style="text-align:center"><strong>阻塞态</strong></td><td style="text-align:left">线程阻塞于锁（调用同步方法时没获取到锁）（注意：阻塞在current包的Lock接口中的线程是等待态而不是阻塞态）</td></tr><tr><td style="text-align:center"><strong>WAITING</strong></td><td style="text-align:center"><strong>等待态</strong></td><td style="text-align:left">线程wait()后，当前线程需要等待其他线程做出一些特定动作（通知或中断）才能返回到运行态</td></tr><tr><td style="text-align:center"><strong>TIME_WAITING</strong></td><td style="text-align:center"><strong>超时等待态</strong></td><td style="text-align:left">可以在指定时间内自行返回的特殊WAITING<br>（其他线程在规定时间内未回复的话则自行返回进行下一步操作）</td></tr><tr><td style="text-align:center"><strong>TERMINGATED</strong></td><td style="text-align:center"><strong>终止态</strong></td><td style="text-align:left">表示当前线程已经执行完毕</td></tr></tbody></table><p><img src="/Blog/Java/Java并发编程艺术/第4章-Java并发编程基础/图4-1 Java线程状态变迁.jpg" alt="图4-1 Java线程状态变迁"></p><h3 id="1-3-Daemon线程-守护线程"><a href="#1-3-Daemon线程-守护线程" class="headerlink" title="1.3. Daemon线程(守护线程)"></a>1.3. Daemon线程(守护线程)</h3><p>Daemon线程是一种支持型线程，主要被用作程序的后台调度和支持性工作。</p><p>使用threadA.setDaemon(true)将线程设置为Daemon线程（Daemon需要在启动线程前设置）</p><ul><li><strong>当JVM中不存在非Daemon线程的时候，JVM会退出。</strong>此时不一定会执行Daemon线程中的finally块，因此不能依靠Daemon线程中的finally来确保逻辑正确。</li></ul><h2 id="二、启动和终止线程"><a href="#二、启动和终止线程" class="headerlink" title="二、启动和终止线程"></a>二、启动和终止线程</h2><h3 id="2-1-构造线程"><a href="#2-1-构造线程" class="headerlink" title="2.1. 构造线程"></a>2.1. 构造线程</h3><p><strong>运行线程之前首先要构造一个线程对象，并且初始化线程属性</strong>。如线程所属的线程组、线程优先级、是否Daemon线程等信息。</p><p>在Thread.init()的源代码中，新构造的线程对象是由其parent线程来进行空间分配的，而<strong>child线程继承了parent的属性</strong>是否为Daemon、优先级和加载资源的contextClassLoader以及科技城ThreadLocal，同时分配一个唯一的线程ID。</p><h3 id="2-2-启动线程"><a href="#2-2-启动线程" class="headerlink" title="2.2. 启动线程"></a>2.2. 启动线程</h3><ul><li>调用<strong>start()</strong>方法即可启动。</li></ul><p>含义：当前线程（parent线程）同步告知JVM，只要线程规划器空闲，应立即启动调用start()方法的线程。</p><h3 id="2-3-中断（interrupt）"><a href="#2-3-中断（interrupt）" class="headerlink" title="2.3. 中断（interrupt）"></a>2.3. 中断（interrupt）</h3><p><strong>中断可以理解为线程的一个标志位属性</strong>。它表示一个运行中的线程是否被其他的线程<strong><u>通知</u></strong>进行了中断操作（不不会终止线程）。</p><p><strong>interrupt()</strong>：其他线程通过调用该线程的interrupt()方法对其进行中断操作。</p><p><strong>isInterrupted()</strong>：线程通过检查自身是否被中断来响应，通过调用isInterrupted() 来判断是否被中断。</p><p><strong>Thread.interrupted()</strong>：复位当前线程的中断标志位（重置为false）。</p><p>如果线程已经处于结束态，则即使该线程被中断过，其中断标志位依旧是false。</p><p><strong>InterruptedException</strong>：当线程处于阻塞状态（因被调用了wait()，join()，sleep()而进入阻塞）时，调用interrupt() ，因为没有占用CPU运行的线程是不可能给自己中断状态置位的，JVM会先清楚中断标志位，然后产生InterruptedException异常（不会终止线程）。（可以利用接收这个异常终止阻塞的线程）</p><h3 id="2-4-安全地终止线程"><a href="#2-4-安全地终止线程" class="headerlink" title="2.4. 安全地终止线程"></a>2.4. 安全地终止线程</h3><h4 id="2-4-1-终止处于运行状态的线程"><a href="#2-4-1-终止处于运行状态的线程" class="headerlink" title="2.4.1. 终止处于运行状态的线程"></a>2.4.1. 终止处于运行状态的线程</h4><ul><li><p>利用中断状态标志位，做中断操作来取消或停止任务。</p></li><li><p>使用boolean变量控制是否需要停止任务并终止该线程</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="title">implments</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">    privatge <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;<span class="comment">//volatile的boolean控制标志</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// boolean变量为真时继续执行</span></span><br><span class="line">        <span class="comment">// 线程没被中断(Isterrupted()返回false)之前继续执行</span></span><br><span class="line">        <span class="comment">// 当外部执行cancel()或interrupt()时终止线程</span></span><br><span class="line">        <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted() ) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// boolean取消操作，供外部终止线程使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        on = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-终止处于“阻塞状态”的线程"><a href="#2-4-2-终止处于“阻塞状态”的线程" class="headerlink" title="2.4.2. 终止处于“阻塞状态”的线程"></a>2.4.2. 终止处于“阻塞状态”的线程</h4><ul><li><p>同样用interrupt()：</p><p>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。 </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行任务...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">        <span class="comment">// 由于产生InterruptedException异常，退出while(true)循环，线程终止！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-废弃的suspend-、resume-、和stop"><a href="#2-5-废弃的suspend-、resume-、和stop" class="headerlink" title="2.5. 废弃的suspend()、resume()、和stop()"></a>2.5. 废弃的suspend()、resume()、和stop()</h3><p>suspend：暂停</p><p>resume：恢复</p><p>stop：终止</p><p>由于强制操作导致的资源不完全释放的副作用（死锁等），所以废弃。建议用回以上的等待/通知的机制替代。</p><h2 id="三、线程间通信"><a href="#三、线程间通信" class="headerlink" title="三、线程间通信"></a>三、线程间通信</h2><p>让线程之间能后互相配合的完成工作。</p><h3 id="3-1-volatile和synchronized关键字"><a href="#3-1-volatile和synchronized关键字" class="headerlink" title="3.1. volatile和synchronized关键字"></a>3.1. volatile和synchronized关键字</h3><p>在程序执行过程中，每个线程可以拥有变量的拷贝，而且看到的不一定是最新的变量值，这时候就需要volatile和synchronized关键字。</p><p>volatile可以告知程序任何对该变量的访问必须要从共享内存中获取，并且其修改必须同步刷新到共享内存，以保证该变量在线程之间的可见性。（不保证原子性）</p><p>synchronized确保同一时刻只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。</p><p>每个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进去同步块或者同步方法，没有获取到监视器的线程将会被阻塞在入口，进入BLOCKED状态和同步队列（释放操作会唤醒同步队列中的线程，使其重新尝试获取监视器）。</p><h3 id="3-2-等待-通知机制（wait-notify）"><a href="#3-2-等待-通知机制（wait-notify）" class="headerlink" title="3.2.等待/通知机制（wait/notify）"></a>3.2.等待/通知机制（wait/notify）</h3><p>简单的<strong>生产者/消费者模式</strong>：一个线程修改了一个对象的值，而另一个线程感知到了变化，进而进行相应操作（开始于一个生产者线程，执行于另一个消费者线程）。隔离了做什么(What)和怎么做(How)，在功能上解耦。</p><p>相关监视器方法：（<code>等待/通知的相关方法都定义在java.lang.Object类上</code>，执行这些方法前，需要配合<code>synchronzied</code>对调用的对象加锁实现等待/通知机制，这些锁是针对同一个Object对象进行操作的，）</p><table><thead><tr><th>方法名</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><strong>notify()</strong></td><td>通知一个在对象上等待的线程，使其从wait()方法返回，前提是本线程已获得该对象的锁</td><td>notify不代表被通知线程获得锁，需要等notify的主动线程释放锁后，才有机会获得锁；<br>而从wait()返回的前提就是获取到了锁</td></tr><tr><td><strong>notifyAll()</strong></td><td>通知所有等待在该对象上的锁</td><td>通知后，<strong>所有在该对象上wait()的线程进入同步队列(BLOCKED状态)</strong>依次等待获取锁的机会</td></tr><tr><td><strong>wait()</strong></td><td>本线程进入WAITING状态，只有等待别的线程通知或被中断才可返回</td><td>调用wait后，<strong>该线程会释放锁</strong>，进入等待队列<br>需要try/catch检查InterruptException异常</td></tr><tr><td><strong>wait(long)</strong></td><td>超时等待。n毫秒后若没有通知的话就自主返回</td><td></td></tr><tr><td>wait(long, int)</td><td>纳秒级超时等待</td></tr></tbody></table><p>等待/通知机制的经典范式</p><p><strong>等待方（生产者）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object 对象) &#123;<span class="comment">// 1. 获得对象锁</span></span><br><span class="line">    <span class="keyword">while</span> (条件不满足) &#123;</span><br><span class="line">        对象.wait();<span class="comment">// 2. 如果条件不满足，则调用wait()，被通知后仍然要检查条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑<span class="comment">// 3. 直到条件满足后才执行相应逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通知方（消费者）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object 对象) &#123;<span class="comment">// 1. 获取对象锁</span></span><br><span class="line">    改变等待方的条件;<span class="comment">// 2. 改变等待方条件，使其能退出自旋检查</span></span><br><span class="line">    对象.notifyAll();<span class="comment">// 3. 通知等待方，使其退出Waiting态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-管道-输入-输出流（Piped）"><a href="#3-3-管道-输入-输出流（Piped）" class="headerlink" title="3.3. 管道.输入/输出流（Piped）"></a>3.3. 管道.输入/输出流（Piped）</h3><p>管道输入/输出流用于<strong>线程间数据传输</strong>，媒介为内存（区别于文件IO）</p><p>字节流：<code>PipedOutputStream</code>，<code>PipedInputStream</code></p><p>字符流：<code>PipedReader</code>，<code>PipedWriter</code></p><ul><li>在使用时一定要先将Output和Input绑定connect起来，否则会抛出IO异常：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">out.connect(in);<span class="comment">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</span></span><br><span class="line">out.connect(in);</span><br><span class="line">Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">"PrintThread"</span>);</span><br><span class="line">printThread.start();</span><br><span class="line"><span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">out.write(receive);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> PipedReader in;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;<span class="comment">// 从PipedReader里读取)</span></span><br><span class="line">System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-Thread-join"><a href="#3-4-Thread-join" class="headerlink" title="3.4. Thread.join()"></a>3.4. Thread.join()</h3><p>当属Thread类的方法<code>Thread.join()</code></p><p><strong>涵义：</strong>当线程A执行了threadB.join()，其意为：<strong>当前线程A等待threadB线程终止后才从thread.join()返回</strong>。<code>也就是确保当前线程必须在threadB后继续执行</code>。</p><p>此外也提供了<code>Thread.join(long millis)</code> 和 <code>Thread.join(long millis, int nanos)</code>的<strong>超时等待</strong>方法</p><p>使用时要try/catch检测InterruptException异常</p><p>Java源码的Thread.join()大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> throw InterruptException </span>&#123;</span><br><span class="line">    <span class="comment">// 条件不满足，继续等待</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件符合，返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以发现 <strong>join() 其实也是等待/通知机制的一种</strong>，<strong>线程终止时会调用自身的notifyAll()方法</strong>，唤醒等待在本线程对象的所有线程。</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread previous = Thread.currentThread();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Domino(previous), String.valueOf(i));</span><br><span class="line">thread.start();</span><br><span class="line">previous = thread;</span><br><span class="line">&#125;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" terminate."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Domino</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Thread thread;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Domino</span><span class="params">(Thread thread)</span> </span>&#123;<span class="comment">//在此处引入别的进程</span></span><br><span class="line"><span class="keyword">this</span>.thread = thread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">thread.join();<span class="comment">// 此处调用Thread.join()</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" terminate."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-ThreadLocal-线程变量"><a href="#3-5-ThreadLocal-线程变量" class="headerlink" title="3.5. ThreadLocal 线程变量"></a>3.5. ThreadLocal 线程变量</h3><p>ThreadLocal线程变量：是一个以 <strong>\&lt;ThreadLocal为键，任意Object为值></strong> 的key-value结构(Entry)，存放在线程自己的ThreadLocalMap中。（一个线程可以拥有多个ThreadLocal变量）</p><p>这个Map被附带绑定在线程上，也就是说一个线程可以通过一个ThreadLocal对象查询到绑定在该线程上的一个值。（每个线程的static ThreadLocal都不一样）</p><p>构造后，需先使用set(T)设置值，再使用get()方法获取值，若不调用set(T)，会抛出空指针异常。 如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法：这样如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回。</p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line"><span class="comment">//重写initialValue()方法，第一次get()方法调用时会进行初始化（前提是若set方法没有调用），每个线程会调用一次</span></span><br><span class="line"><span class="comment">// 可以不重写，那么声明ThreadLocal变量写作不用括号重写：XX = new ThreadLocal&lt;Long&gt;();</span></span><br><span class="line">        <span class="comment">// 并且不重写时，不调用set就get的话，会抛出NullPointerException</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">TIME_THREADLOCAL.set(System.currentTimeMillis());<span class="comment">// set(T)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get(); <span class="comment">//get()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Profiler.begin();<span class="comment">// set(T)</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);<span class="comment">//get()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><p>书P106-P117说明了：基本的数据库连接池实现、线程池的基本实现、基于线程池的Web项目实现。注意查看</p><h3 id="4-1-数据库连接池"><a href="#4-1-数据库连接池" class="headerlink" title="4.1. 数据库连接池"></a>4.1. 数据库连接池</h3><h3 id="4-2-线程池"><a href="#4-2-线程池" class="headerlink" title="4.2. 线程池"></a>4.2. 线程池</h3><h3 id="4-3-基于线程池技术的简单Web服务器"><a href="#4-3-基于线程池技术的简单Web服务器" class="headerlink" title="4.3. 基于线程池技术的简单Web服务器"></a>4.3. 基于线程池技术的简单Web服务器</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本章主要讲解Java的线程Thread，线程的6个状态，Daemon守护线程，线程的生存周期操作（构造、启动、中断、终止），以及线程的几种通信方式：volatile和synchronized提供的内存可见性保障，等待/通知机制wait/notify，管道流，Thread.join() 以及 ThreadLocal变量。&lt;/p&gt;
&lt;p&gt;最后还示例了线程池、数据库连接池的简单实现，篇幅较大，暂时未补充，需要自己阅读书本。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java并发编程艺术" scheme="https://uncleaaron.github.io/Blog/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="并发编程" scheme="https://uncleaaron.github.io/Blog/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件体系结构复习</title>
    <link href="https://uncleaaron.github.io/Blog/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://uncleaaron.github.io/Blog/课程学习/软件体系结构/</id>
    <published>2018-05-31T16:05:10.000Z</published>
    <updated>2018-07-16T11:47:39.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>总结了最近软件体系结构及设计模式的所学以及考试要点, 但是不是很严谨, 日后还需补充, 仅作参考</p></blockquote><a id="more"></a><h1 id="4-1视图"><a href="#4-1视图" class="headerlink" title="4+1视图"></a>4+1视图</h1><h2 id="逻辑视图"><a href="#逻辑视图" class="headerlink" title="逻辑视图"></a>逻辑视图</h2><p>功能需求（功能调用关系）(可以根据菜单设计)</p><p>最终用户</p><h2 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h2><p>拓扑结构</p><p>系统工程人员</p><h2 id="开发视图"><a href="#开发视图" class="headerlink" title="开发视图"></a>开发视图</h2><p>软件各层模块设计（页面-业务-底层(DB,网络,安全…)）</p><p>编程人员</p><h2 id="进程视图"><a href="#进程视图" class="headerlink" title="进程视图"></a>进程视图</h2><p>画出一个流程的从前端到后端的各个可能产生关系的进程调用关系。</p><p>系统集成人员</p><h2 id="场景视图"><a href="#场景视图" class="headerlink" title="场景视图"></a>场景视图</h2><p>某个功能场景下，从用户操作到系统内部顺序的整个过程描述</p><h1 id="软件体系结构"><a href="#软件体系结构" class="headerlink" title="软件体系结构"></a>软件体系结构</h1><p>软件体系结构是对系统的高层设计，是指<strong>系统的基本组织结构</strong>，包括：组成系统的<strong>构件</strong>、<strong>构件之间的连接关系</strong>、以及系统需满足的<strong>约束</strong>、原则等。</p><h1 id="软件体系结构风格"><a href="#软件体系结构风格" class="headerlink" title="软件体系结构风格"></a>软件体系结构风格</h1><p>软件体系结构风格是<strong>对软件体系结构的分类</strong>，<strong>总结和描述</strong>一类<strong>系统组织方式</strong>的惯用模式。</p><p>体系结构风格定义一个<strong>词汇表</strong>和<strong>一组约束</strong>。</p><p><strong>词汇表</strong>：包含<strong>构件</strong>和<strong>连接件</strong>类型</p><p><strong>约束</strong>：指出系统是<strong>如何将这些构件和连接件组合</strong>起来的。</p><p>体系结构风格<strong>反映</strong>了众多系统所<strong>共有的结构</strong>和语义特性，并<strong>指导</strong>如何将各个模块<strong>有效地组织成一个完整的系统</strong>。</p><h2 id="面向对象设计风格"><a href="#面向对象设计风格" class="headerlink" title="面向对象设计风格"></a>面向对象设计风格</h2><p>这种风格建立在数据抽象和面向对象的基础上，<strong>数据的表示</strong>和<strong>操作封装</strong>在一个<strong>抽象数据类型或对象</strong>中。</p><p>这种风格的<strong>构件是对象</strong>，或者说是抽象数据类型的实例。对象是一种被称作管理者的构件，因为它负责保持资源的完整性。对象是<strong>通过函数和过程的调用来交互</strong>的。</p><h2 id="结构化设计风格"><a href="#结构化设计风格" class="headerlink" title="结构化设计风格"></a>结构化设计风格</h2><p>模块化设计，采用<strong>自顶向下</strong>的方法，将<strong>问题划分</strong>为多个<strong>相对独立、功能单一的模块</strong>，以<strong>功能块为单位进行程序设计</strong>。降低了<strong>程序复杂度</strong>，提高<strong>代码的重用性</strong>，使程序<strong>易于调试和维护、扩充</strong>。</p><h2 id="管道过滤器风格"><a href="#管道过滤器风格" class="headerlink" title="管道过滤器风格"></a>管道过滤器风格</h2><p>每个<strong>构件（过滤器）</strong>都<strong>有一组输入和输出</strong>，构件读输入的数据流，经过<strong>内部处理</strong>，然后<strong>产生输出</strong>数据流。这里的构件被称为<strong>过滤器</strong>，这种风格的<strong>连接件</strong>是数据流传输的<strong>管道</strong>，将一个<strong>过滤器的输出传到另一过滤器的输入</strong>。</p><p><code>过滤器 → 管道 → 过滤器</code></p><h2 id="层次风格"><a href="#层次风格" class="headerlink" title="层次风格"></a>层次风格</h2><p>层次系统组织成一个层次结构，<strong>每一层为上层服务，并作为下层客户</strong>。在一些层次系统中，<strong>内部的层只对相邻的层可见。</strong>这种风格支持基于可增加抽象层的设计。允许将一个复杂问题分解成一个增量<strong>步骤序列的实现</strong>。</p><p><strong>构件</strong>在一些层实现了虚拟机 </p><p><strong>连接件</strong>通过决定<strong>层间如何交互</strong>的协议来定义</p><p>拓扑<strong>约束</strong>包括对<strong>相邻层间交互</strong>的约束。 </p><p>//由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件重用提供了强大的支持。</p><h2 id="CS风格"><a href="#CS风格" class="headerlink" title="CS风格"></a>CS风格</h2><p>C/S软件体系结构是基于资源不对等，且<strong>为实现共享</strong>而提出来的。</p><p>C/S体系结构<strong>定义了工作站如何与服务器相连，以实现数据和应用分布到多个处理机上</strong>。 </p><p>C/S体系结构有三个主要组成部分：<strong>数据库服务器</strong>、<strong>客户端程序</strong> 和 <strong>网络</strong>。</p><p><strong>客户端</strong>，服务请求者。<strong>不共享任何资源</strong>，但需要<strong>获取服务器</strong>的<strong>内容</strong>或<strong>功能</strong>。 </p><p><strong>服务器</strong>运行一个或多个服务器计划，与客户<strong>分享他们的资源</strong>。  </p><h2 id="BS风格"><a href="#BS风格" class="headerlink" title="BS风格"></a>BS风格</h2><p>浏览器/服务器（B/S）风格就是上述三层C/S结构的一种实现方式，其具体结构为：<strong>浏览器</strong>/<strong>Web服务器</strong>/<strong>数据库服务器</strong>。B/S体系结构主要是利用不断成熟的<strong>WWW浏览器技术</strong>，结合<strong>浏览器的多种脚本语言</strong>，用<strong>通用浏览器</strong>就实现了原来需要复杂的专用软件才能实现的强大功能，并<strong>节约了开发成本</strong>。</p><h2 id="CS、BS混合风格"><a href="#CS、BS混合风格" class="headerlink" title="CS、BS混合风格"></a>CS、BS混合风格</h2><p>CS和BS各有优缺点，标准在不同地方也有不同的地位，使用习惯不同，还有遗留代码，所以会使用混合</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><ol><li>对<strong>扩展是开放的</strong>。模块的<strong>行为可以扩展</strong>，当需求改变时，可以对模块进行扩展，<strong>增加新的功能</strong>。</li><li>对<strong>修改是封闭的</strong>。在对模块行为进行扩展时，<strong>不允许修改模块中已经存在的类的源代码</strong>。</li></ol><h2 id="接口编程"><a href="#接口编程" class="headerlink" title="接口编程"></a>接口编程</h2><p>所有的<strong>定义与实现分离</strong>。把业务抽象出来，具体实现通过该接口的实现完成。</p><p>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象<strong>内部实现显得不那么重要</strong>；而各个对象之间的<strong>协作关系</strong>则成为<strong>系统设计的关键</strong>。小到不同类之间的<strong>通信</strong>，大到各模块之间的<strong>交互</strong>，是系统设计的主要工作内容。</p><p>好处：<strong>业务逻辑清晰</strong>，代码易懂，<strong>方便扩展</strong>，可维护性强，符合<strong>开闭原则</strong> 。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式是对<strong>软件设计经验的总结</strong>，是对软件设计中<strong>反复出现的设计问题的成功解决方案</strong>的描述。设计模式可以用于软件体系结构的设计，以实现体系结构级的<strong>设计复用</strong>。设计模式可以使设计者<strong>更加方便地借鉴并直接使用</strong>已经经过证实的成功设计方案，不必花时间进行重复设计。帮助设计者<strong>更快更好地完成软件系统的设计工作</strong>。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>无论是单例还是多例，对象属性和方法都不static。</p><p>而static的应该是获取单例/多例对象相关的方法或属性，</p><p><strong>构造器</strong>都应该是<strong>私有的</strong>，因为不允许从getInstance外的其他方式构造对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChairMan</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ChairMan chairmanInstance;<span class="comment">//单例对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">// 私有构造器，因为不允许外部初始化。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ChairMan</span><span class="params">(String name)</span></span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 单例在第一次调用时初始化单例的static对象，后续不允许初始化。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ChairMan <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (chairmanInstance == <span class="keyword">null</span>) &#123;<span class="comment">//检查是否已经被初始化，未初始化则创建，否则已存在，跳过</span></span><br><span class="line">chairmanInstance = <span class="keyword">new</span> ChairMan(<span class="string">"习近平"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> chairmanInstance;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//对象实例方法，不静态处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> name + <span class="keyword">super</span>.toString(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h2><p>多个对象在类加载时就已经进行内部初始化，通过getInstance从static对象中获取对象，在构造器中限制类初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Marshal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用一个Map对象存放多例的对象，以便用key随机查找</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Marshal&gt; marshalInstances = <span class="keyword">new</span> HashMap&lt;String, Marshal&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//已初始化对象的数量，在构造方法中自增</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = <span class="number">5</span>;<span class="comment">//限制的多例对象数量上限，在构造方法中限制，超出则异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//实例对象的属性，不采取static</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//类加载时执行代码块，初始化多个对象</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">String[] marshals = &#123;<span class="string">"陈毅"</span>,<span class="string">"罗荣桓"</span>,<span class="string">"徐向前"</span>,<span class="string">"聂荣臻"</span>,<span class="string">"叶剑英"</span>,<span class="string">"刘德华"</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (String name : marshals) &#123;</span><br><span class="line">i++;</span><br><span class="line">marshalInstances.put(name,<span class="keyword">new</span> Marshal(name));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123; System.out.println(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line">    <span class="comment">// 是私有的，因为不允许外部初始化</span></span><br><span class="line">    <span class="comment">// 并通过已存在多例对象数量和已设上限来禁止超出上限数量后的初始化。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Marshal</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (count &gt;= MAX_COUNT) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"不可继续创建新的元帅"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">count ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从Map中获取多例对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Marshal <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> marshalInstances.get(name);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//对象实例方法，不用静态处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> name + <span class="string">"元帅"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂方法模式"><a href="#简单工厂方法模式" class="headerlink" title="简单工厂方法模式"></a>简单工厂方法模式</h2><p>思想：在工厂类中用一个switch-case分辨需要的是哪一个类的对象，用一个父类型的引用获取新建的子类型对象。</p><p><img src="/Blog/课程学习/软件体系结构/工厂模式-简单工厂模式.png" alt="工厂模式-简单工厂模式"></p><p>缺点：</p><ol><li>工厂类必须知道怎么样创建每个子类的对象，所以每次增加产品的时候，都需要修改工厂类代码，不符合开闭原则。</li><li>简单工厂类的工厂方法是静态的，不能被继承，只能是一个单独的类。</li></ol><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><img src="/Blog/课程学习/软件体系结构/工厂模式-工厂模式.png" alt="工厂模式-工厂模式"></p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>对同结构的产品抽象成父类，不同的公司工厂生产其对应的产品。</p><p>有两种情况：</p><p><strong>拓展产品不符合开闭原则</strong></p><p><strong>拓展工厂符合开闭原则</strong></p><p><img src="/Blog/课程学习/软件体系结构/工厂模式-抽象工厂模式.png" alt="工厂模式-抽象工厂模式"></p><h2 id="安全组合模式"><a href="#安全组合模式" class="headerlink" title="安全组合模式"></a>安全组合模式</h2><p><img src="/Blog/课程学习/软件体系结构/组合模式-安全组合模式.png" alt="组合模式-安全组合模式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         *           composite1 </span></span><br><span class="line"><span class="comment">         *           /      \ </span></span><br><span class="line"><span class="comment">         *        leaf1   composite2 </span></span><br><span class="line"><span class="comment">         *                  /   \ </span></span><br><span class="line"><span class="comment">         *               leaf2  leaf3         </span></span><br><span class="line"><span class="comment">         *                </span></span><br><span class="line"><span class="comment">         * */</span>  </span><br><span class="line">        Component leaf1=<span class="keyword">new</span> Leaf();  </span><br><span class="line">        Component leaf2=<span class="keyword">new</span> Leaf();  </span><br><span class="line">        Component leaf3=<span class="keyword">new</span> Leaf();  </span><br><span class="line">        Composite composite1=<span class="keyword">new</span> Composite();  </span><br><span class="line">        Composite composite2=<span class="keyword">new</span> Composite();  </span><br><span class="line">          </span><br><span class="line">        composite2.add(leaf2);  </span><br><span class="line">        composite2.add(leaf3);  </span><br><span class="line">        composite1.add(leaf1);  </span><br><span class="line">        composite1.add(composite2);  </span><br><span class="line">          </span><br><span class="line">        composite1.doSomething();  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一致型组合模式"><a href="#一致型组合模式" class="headerlink" title="一致型组合模式"></a>一致型组合模式</h2><p>与安全组合模式的区别在于所有的构建类都有相同的接口，各个类在接口上是没有区别的，客户端可以等同对待所有的对象。不必区分叶子节点和树枝节点，不需要强制类型转换。</p><p>缺点在于不够安全，Leaf(Person)需要屏蔽一些方法，并且抛出适当的异常。这样在客户类调用Leaf方法的时候可以做到部分方法可以什么都不做。</p><p><img src="/Blog/课程学习/软件体系结构/组合模式-一致性组合模式.png" alt="组合模式-安全组合模式"></p><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p><img src="/Blog/课程学习/软件体系结构/适配器模式-对象适配器.png" alt="适配器模式-类适配器"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象适配器模式的适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Ps2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 依赖于USB类，在构造时存放一个USB的实例引用（这里体现了“对象”适配器模式）</span></span><br><span class="line">    <span class="keyword">private</span> Usb usb;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Usb usb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.usb = usb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Target类的方法重写，调用了USB类的方法返回。（这里体现了适配）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isPs2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        usb.isUsb();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clienter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ps2 p = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Usber());<span class="comment">//这里实例Target类时在Adaptor构造器里传入实例</span></span><br><span class="line">        p.isPs2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p><img src="/Blog/课程学习/软件体系结构/适配器模式-类适配器.png" alt="适配器模式-类适配器"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Usber</span> <span class="keyword">implements</span> <span class="title">Ps2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里继承了被适配类USB，可以直接作为USB被构造和使用USB的方法</span></span><br><span class="line">    <span class="comment">//由于实现了Target类，同时也可以作为Target类使用，但是实现是USB类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isPs2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isUsb();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clienter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接作为Adapter被实例化，因为是继承了USB，所以不需要new USB，直接作为USB</span></span><br><span class="line">        Ps2 p = <span class="keyword">new</span> Adapter();</span><br><span class="line">        p.isPs2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ORM模式"><a href="#ORM模式" class="headerlink" title="ORM模式"></a>ORM模式</h2><p>对象-关系映射（Object Relational Mapping），把对象映射到关系模型数据库结构中去。在操作对象的时候，不需要再去和复杂的SQL语句打交道，只需简单的操作实体对象的属性和方法。</p><p>ORM技术是在对象和关系之间提供了一条桥梁，对象数据和数据库中的关系型的数据通过ORM来相互转化 。</p><div id="flowchart-0" class="flow-chart"></div><h2 id="IOC模式"><a href="#IOC模式" class="headerlink" title="IOC模式"></a>IOC模式</h2><p>控制反转</p><p>IoC模式，系统中通过<strong>IoC容器</strong>来<strong>管理对象</strong>的<strong>生命周期</strong>、<strong>依赖关系</strong>等，使程序的配置和依赖性规范<strong>与实际的代码分开</strong>。<strong>通过文本配置</strong>文件进行<strong>程序组件间相互关系</strong>的配置，而<strong>不用修改编译具体的代码</strong>。</p><p>IoC是把以前在工厂方法里写死的对象生成代码，改变为由XML文件来定义，<strong>利用Java反射，根据XML生成相应的对象</strong>。也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p><p>// IOC模式把耦合从代码中移出去，放到统一的XML 文件中，通过一个容器在需要的时候把这个依赖关系形成，即把需要的接口实现注入到需要它的类中，也就是所谓“依赖注入DI”。</p><h2 id="Spring框架基本原理和使用"><a href="#Spring框架基本原理和使用" class="headerlink" title="Spring框架基本原理和使用"></a>Spring框架基本原理和使用</h2><p>Spring在Spring上下文中存放bean对象，对象在配置文件中声明。</p><p>使用时先从配置文件中获取上下文，然后可以用上下文content.getBean()获取bean对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span> <span class="comment">&lt;!-- 省略beans引用的头信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"teacher"</span> <span class="attr">class</span>=<span class="string">"cn.edu.scau.cmi.huangyanrong.spring.domain.Teacher"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"liangzaoqing"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"梁早清"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"男"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"cn.edu.scau.cmi.huangyanrong.spring.domain.Student"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"huangyanrong"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"黄彦荣"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"男"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tutor"</span> <span class="attr">ref</span>=<span class="string">"teacher"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"codes/spring/config/applicationContext.xml"</span>);</span><br><span class="line">Student student = (Student)context.getBean(<span class="string">"student"</span>);</span><br><span class="line">System.out.println(student);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hibernate框架基本原理和使用"><a href="#Hibernate框架基本原理和使用" class="headerlink" title="Hibernate框架基本原理和使用"></a>Hibernate框架基本原理和使用</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"domain.Course"</span> <span class="attr">table</span>=<span class="string">"course"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"java.lang.Long"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"assigned"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"students"</span> <span class="attr">inverse</span>=<span class="string">"true"</span> <span class="attr">table</span>=<span class="string">"select"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"course"</span> <span class="attr">not-null</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">entity-name</span>=<span class="string">"domain.Student"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"student"</span> <span class="attr">not-null</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">many-to-many</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">A=>operation: 数据库连接工具类B=>operation: DAO类C=>operation: Service业务类D=>operation: ClientD(right)->C(bottom)->B(bottom)->A</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;总结了最近软件体系结构及设计模式的所学以及考试要点, 但是不是很严谨, 日后还需补充, 仅作参考&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="课程学习" scheme="https://uncleaaron.github.io/Blog/tags/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>第3章 Java内存模型</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC3%E7%AB%A0-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java并发编程艺术/第3章-Java内存模型/</id>
    <published>2018-05-29T12:46:25.000Z</published>
    <updated>2018-07-21T13:58:01.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本章主要通过Java的内存模型来讲解汇编代码的重排序现象，顺序一致性，happens-before原则，volatile内存语义和synchronized，final，锁，双重检查锁等在内存模型中的体现和原理表达。</p></blockquote><a id="more"></a><h1 id="第3章-Java内存模型"><a href="#第3章-Java内存模型" class="headerlink" title="第3章 Java内存模型"></a>第3章 Java内存模型</h1><p>内存模型</p><p>内存模型中的顺序一致性，重排序以及顺序一致性内存模型</p><p>同步原语：synchronized，volatile，final</p><h2 id="一、Java内存模型的基础"><a href="#一、Java内存模型的基础" class="headerlink" title="一、Java内存模型的基础"></a>一、Java内存模型的基础</h2><h4 id="1-1-并发编程模型的两个关键问题（通信、同步）："><a href="#1-1-并发编程模型的两个关键问题（通信、同步）：" class="headerlink" title="1.1. 并发编程模型的两个关键问题（通信、同步）："></a>1.1. 并发编程模型的两个关键问题（通信、同步）：</h4><ul><li>线程之间如何<strong>通信</strong></li><li>线程之间如何<strong>同步</strong></li></ul><p>线程之间<strong>通信</strong>机制有两种：共享内存、消息传递</p><p><strong>同步</strong>：<strong>程序中用于控制不同线程间操作发生相对顺序的机制</strong>。</p><p>两种并发模型：</p><ul><li><p><strong>共享内存</strong>：（Java采用该并发模型）</p><p>通信：线程之间共享程序的公共状态，通过写-读内存中的公共状态进行<u>隐式</u>通信。</p><p>同步：<u>显式</u>进行，程序员必须<u>显式指定</u>某个方法或某段代码需要在线程之间互斥执行。</p></li><li><p><strong>消息传递</strong>：</p><p>通信：显式，线程之间没有公共状态，线程之间必须通过发送消息来<u>显式</u>通信。</p><p>同步：隐式，由于消息发送必须先于接收，所以同步是隐式进行的。</p></li></ul><p><u>Java采用的是<strong>共享内存</strong>模型</u></p><h3 id="1-2-Java内存模型的抽象结构"><a href="#1-2-Java内存模型的抽象结构" class="headerlink" title="1.2. Java内存模型的抽象结构"></a>1.2. Java内存模型的抽象结构</h3><p><img src="/Blog/Java/Java并发编程艺术/第3章-Java内存模型/图3-1 Java内存模型的抽象结构示意图.jpg" alt="Java内存模型的抽象结构示意图"></p><p>Java线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入合适对另一个线程可见。</p><p>抽象角度看：</p><p>线程之间的<strong>共享变量存储在主内存</strong>（Main Memory）；每个<strong>线程都有一个私有的本地内存</strong>（抽象概念，不真实存在）；<strong>本地内存中存储了该线程以读/写共享变量的副本</strong>。</p><p>A–&gt;B的通信步骤：</p><ol><li>线程A把本地内存A中<strong>更新过的共享变量刷新到主内存</strong>中。</li><li>线程B<strong>到主内存中读取</strong>线程A之前已更新过的共享变量。</li></ol><p><strong>实质</strong>：线程A在向线程B发消息，而且<strong>必须经过主内存</strong>。</p><p><u>JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</u></p><h3 id="1-3-从源代码到指令序列的重排序"><a href="#1-3-从源代码到指令序列的重排序" class="headerlink" title="1.3. 从源代码到指令序列的重排序"></a>1.3. 从源代码到指令序列的重排序</h3><p>为了提高执行程序的性能，编译器和处理器常常会对指令做重排序(3种)。</p><div id="flowchart-0" class="flow-chart"></div><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，重新安排语句执行顺序。</li><li>指令级并行的重排序。处理器采用指令级并行技术将多条指令重叠执行。（如无数据依赖可改变执行顺序）</li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去是在乱序执行。</li></ol><p>每个处理器写缓冲区仅对自己可见，这会导致处理器执行内存操作的顺序会与内存实际的操作执行顺序不一致。因此现代的处理器都会允许对写-读操作进行重排序。</p><p>JMM通过禁止某些编译器重排序（插入内存屏障）和处理器重排序，为程序员提供一致的内存可见性保证。</p><h3 id="1-4-happens-before"><a href="#1-4-happens-before" class="headerlink" title="1.4. happens-before"></a>1.4. happens-before</h3><p>Java的JSR-133内存模型使用happens-before的概念来阐述操作之间的内存可见性。</p><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。（两个操作可以是同一线程内，也可以是不同线程之间）</p><ul><li><strong>happens-before</strong>仅仅要求<strong>前一个操作执行的结果对后一个操作可见</strong>，且前一个操作按<strong>顺序</strong>排在第二个操作之前。<strong>并不意味</strong>着前一个操作必须在后一个操作前执行！</li></ul><p>与<strong>程序员密切相关的happens-before规则</strong>如下：</p><ul><li><strong>程序顺序规则</strong>：一个线程中的<strong>每个操作</strong>，<strong>happens-before于</strong>该线程中的任意<strong>后续操作</strong>。（同一线程内顺序排序）</li><li><strong>监视器锁规则</strong>：对一个锁的<strong>解锁</strong>，<strong>happens-before于</strong>随后对其<strong>加锁</strong>。（解锁–&gt;加锁）</li><li><strong>volatile变量规则</strong>：对一个<strong>volatile域的写</strong>，<strong>happens-before于</strong>任意后续对这个<strong>volatile域的读</strong>。（写–&gt;读）</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C</li></ul><p>happens-before与JMM的关系：</p><div id="flowchart-1" class="flow-chart"></div><h2 id="二、重排序"><a href="#二、重排序" class="headerlink" title="二、重排序"></a>二、重排序</h2><p>重排序是指编译器和处理器优化程序性能而对指令序列进行重新排序的一种手段。</p><h3 id="2-1-数据依赖性"><a href="#2-1-数据依赖性" class="headerlink" title="2.1. 数据依赖性"></a>2.1. 数据依赖性</h3><p>两个操作访问同一个变量，其中一个是写操作，则存在数据依赖性。</p><p>分为：</p><ul><li>写后读</li><li>写后写</li><li>读后写</li></ul><p>上述三种情况，只要重排序两个操作，执行结果就会被改变。</p><p>编译器和处理器会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序（仅针对单个处理器和单个线程中的操作，不同处理器之间和不同线程之间的数据依赖性不被考虑）</p><p>###2.2. as-if-serial语义</p><p><strong>as-if-serial：不管怎么重排序，（单线程）程序的执行结果不能被改变。</strong></p><p>编译器、runtime、处理器都<strong>必须遵守</strong>as-if-serial语义，因此它们<strong>不会对存在数据依赖关系的操作</strong>做重排序。</p><p>as-if-serial语义<strong>保护了单线程</strong>程序。使单线程程序员无需担心重排序会干扰到程序和内存可见性问题。</p><h3 id="2-3-程序顺序规则"><a href="#2-3-程序顺序规则" class="headerlink" title="2.3. 程序顺序规则"></a>2.3. 程序顺序规则</h3><p>软件和硬件技术准求的目标：在<strong>不改变程序执行结果</strong>的前提下，尽可能<strong>提高并行度</strong>。</p><p>编译器和处理器遵从这一目标，JMM也同样遵从这一目标(happens-before)</p><h3 id="2-4-重排序对多线程的影响"><a href="#2-4-重排序对多线程的影响" class="headerlink" title="2.4. 重排序对多线程的影响"></a>2.4. 重排序对多线程的影响</h3><p>控制依赖：（if(xxxx) yyyy;    //x与y操作之间存在控制依赖关系）</p><p>当代码中存在控制依赖性时，会影响序列执行的并行度。编译器和处理器会采用猜测执行来客服控制相关性对并行度的影响。（猜测：在控制条件前提前读取数据并计算，将计算结果临时保存到名为重排序缓冲的硬件缓冲中）</p><p><strong>单线程</strong>中对存在<strong>控制依赖</strong>的操作进行重排序<strong>不影响</strong>结果（所以as-if-serial语义允许对其重排序）</p><p>但在<strong>多线程中，对存在控制依赖的操作重排序可能会<u>改变</u>程序的执行结果</strong>。</p><h2 id="三、顺序一致性"><a href="#三、顺序一致性" class="headerlink" title="三、顺序一致性"></a>三、顺序一致性</h2><h3 id="3-1-JMM的内存一致性保证"><a href="#3-1-JMM的内存一致性保证" class="headerlink" title="3.1. JMM的内存一致性保证"></a>3.1. JMM的内存一致性保证</h3><p>JMM对正确同步的多线程程序的内存一致性做了如下保证：</p><p>如果程序是正确同步的，程序的执行将具有顺序一致性（执行结果与顺序一致性模型相同）//（这里的同步适用于同步原语synchronized、volatile、final的正确使用）。</p><h3 id="3-2-顺序一致性模型"><a href="#3-2-顺序一致性模型" class="headerlink" title="3.2. 顺序一致性模型"></a>3.2. 顺序一致性模型</h3><p>顺序一致性模型是一个<strong>理想化</strong>的理论参考模型（实际上完全实现的代价很大），它为程序员提供了极强的内存可见性保证。</p><p><img src="/Blog/Java/Java并发编程艺术/第3章-Java内存模型/图3-2 顺序一致性内存模型的视图.jpg" alt="图3-2 顺序一致性内存模型的视图"></p><p><strong>顺序一致性内存模型</strong>的视图（如上图）：<strong>任意时间点最多只有任意一个线程可以连接到内存</strong>，当多个线程并发执行时，能把所有线程的所有内存读写都串行化。</p><p>它有<strong>两大特性</strong>：</p><ol><li><p>单个线程中的所有操作必须按照程序的顺序来执行<strong>（JMM没有保证这点，临界区内可以重排序）</strong></p></li><li><p>（不管程序是否同步）<strong>所有线程都只看得到唯一的操作执行顺序，</strong>每个操作都必须<strong>原子执行</strong>且<strong>立即对所有线程可见</strong>。</p><p>对此，<strong>JMM只保证同步程序的顺序一致性</strong>，<u>这是由Java内存模型决定的</u>：在未同步程序中，不但整体的执行顺序是无序的，线程锁看到的操作执行顺序也可能不一致：A线程写到A本地内存后，自以为执行结束，实际上还没刷入主内存，这相对于B线程是不立即可见的，即看到的执行顺序不一致（这里要结合上面的JAVA内存模型思考）</p><p>此外，<strong>JMM不保证对64位long和double变量的写操作具有原子性</strong>（读操作有原子性）（这是由总线带宽决定的，在32位处理器上，64位可能会被拆成2个32位执行。）（这点可以用锁来保证原子性）</p></li></ol><h3 id="3-3-Java同步程序的顺序一致性效果"><a href="#3-3-Java同步程序的顺序一致性效果" class="headerlink" title="3.3. Java同步程序的顺序一致性效果"></a>3.3. Java同步程序的顺序一致性效果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;<span class="comment">//获得锁</span></span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="comment">//释放锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;<span class="comment">//获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;<span class="comment">//临界区，其内可以重排序（JMM会在临界区创建顺序一致性模型内存视图）</span></span><br><span class="line">            <span class="keyword">int</span> i = a;<span class="comment">//由于监视器互斥执行的特性，</span></span><br><span class="line">            ......<span class="comment">//其他线程无法得知该线程访问临界区内的重排序</span></span><br><span class="line">        &#125;<span class="comment">//这种重排序能够提高执行效率而且保证执行结果</span></span><br><span class="line">    &#125;<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-未同步程序的执行特性"><a href="#3-4-未同步程序的执行特性" class="headerlink" title="3.4. 未同步程序的执行特性"></a>3.4. 未同步程序的执行特性</h3><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行读到的值，要么是之前某线程写入的值，要么是默认值（0，Null，False），JMM只保证线程读取到的值不会无中生有冒出来。</p><h2 id="四、volatile"><a href="#四、volatile" class="headerlink" title="四、volatile"></a>四、volatile</h2><p><u>volatile可以看作为使用同一个锁对volatile变量进行单个读或写做了同步。</u></p><p>volatile可以告知程序任何对该变量的访问必须要从共享内存中获取，并且其修改必须同步刷新到共享内存，以保证该变量在线程之间的可见性。</p><p>volatile变量的<strong>特性</strong>：</p><ul><li><strong>可见性</strong>：对一个volatile变量的<strong>读，总是能看到（任意线程）对这个volatile变量最后的写入</strong>。</li><li><strong>仅对单一读/写有原子性</strong>：对任意<strong>单个</strong>volatile变量的<strong>读/写</strong>具有原子性（无论是64位还是32位数据），<u>但类似于volatile++这种<strong>复合操作不具有原子性</strong>。</u><strong>总体上不保证原子性</strong></li></ul><p>从内存语义的角度来说，volatile变量的写-读 与 锁的释放-获取 有相同的内存效果。</p><ul><li>volatile写和锁的释放具有相同的内存语义；</li><li>volatile读与锁的获取具有相同的内存语义</li></ul><p>举例分析一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i = a;<span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据程序次序规则：1 happens-before 2; 3 happens-before 4</p><p>根据volatile规则：2 happens-before 3</p><p>根据happens-before的传递性：1 happens-before 4</p><p>也就是：</p><div id="flowchart-2" class="flow-chart"></div><p>A写了一个volatile变量之后，B读同一个volatile变量。</p><p>A线程在写volatile变量之前所有可见的共享变量，在B线程读了同一个volatile变量之后，立即变得对B线程可见。（这句话可以用下面的内存语义结合内存模型理解）</p><ul><li>（个人理解：写volatile变量即为解锁，读volatile即为加锁，因为任何线程都可以原子性地单独读/写volatile变量，所以volatile不会造成死锁）</li></ul><h3 id="3-2-volatile-写-读的内存语义（与锁的释放-获取内存语义相似）"><a href="#3-2-volatile-写-读的内存语义（与锁的释放-获取内存语义相似）" class="headerlink" title="3.2. volatile 写-读的内存语义（与锁的释放-获取内存语义相似）"></a>3.2. volatile 写-读的内存语义（与锁的释放-获取内存语义相似）</h3><p>volatile<strong>写</strong>的内存语义：（同释放锁）</p><ul><li><strong>写一个volatile变量时</strong>，JMM会把该线程对应的本地内存中的<strong>共享变量值刷新到主内存</strong>）</li></ul><p>volatile<strong>读</strong>的内存语义：（同获取锁）</p><ul><li><strong>读一个volatile变量时</strong>，JMM会把该线程对应的<strong>本地内存置为无效</strong>，线程接下来将<strong>从主内存中读取共享变量</strong>。</li></ul><h4 id="3-2-1-写-读volatile变量的内存语义实质：（与锁的释放-获取内存语义相似）"><a href="#3-2-1-写-读volatile变量的内存语义实质：（与锁的释放-获取内存语义相似）" class="headerlink" title="3.2.1. 写-读volatile变量的内存语义实质：（与锁的释放-获取内存语义相似）"></a>3.2.1. 写-读volatile变量的内存语义实质：（与锁的释放-获取内存语义相似）</h4><ul><li>线程A<strong>写</strong>一个volatile变量，实质上是线程A向接下来要读这个volatile变量的某个线程<strong>发出了（其对共享变量所做出的修改）的消息</strong>。</li><li>线程B<strong>读</strong>一个volatile变量，实质上是线程B<strong>接受了</strong>之前某个线程发出的<strong>（在写这个volatile变量之前对共享变量所做的修改）的消息</strong>。</li><li>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程<strong>实质</strong>上是线程A<strong>通过主内存</strong>向线程B<strong>发消息</strong>。</li></ul><h3 id="3-3-volatile-内存语义的实现"><a href="#3-3-volatile-内存语义的实现" class="headerlink" title="3.3. volatile 内存语义的实现"></a>3.3. volatile 内存语义的实现</h3><p>JMM对volatile制定的重排序规则：</p><ul><li>volatile写之前的操作绝对不会重排序到其之后。</li><li>volatile读之后的操作不会重排序到其之前。</li><li>volatile写在volatile读之前时，不会重排序。</li></ul><p>这些规则都是使用插入内存屏障来解决的（编译器会适当减少不必要、重复的内存屏障）。</p><h2 id="五、锁的内存语义"><a href="#五、锁的内存语义" class="headerlink" title="五、锁的内存语义"></a>五、锁的内存语义</h2><p>锁可以让临界区互斥执行，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;<span class="comment">//1 获得锁</span></span><br><span class="line">        a++;   <span class="comment">//2 执行临界区代码</span></span><br><span class="line">    &#125; <span class="comment">//3 释放锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;<span class="comment">//4</span></span><br><span class="line">        <span class="keyword">int</span> i = a;   <span class="comment">//5</span></span><br><span class="line">    &#125;  <span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A执行writer，然后线程B执行reader。根据happens-before原则推导得出：2 happends-before 5</p><p>因此，线程A在释放锁之前的所有可见的共享变量，在线程B获取同一个锁之后将立刻变得对B线程可见。</p><h3 id="内存语义：（与volatile具有相同的内存语义）"><a href="#内存语义：（与volatile具有相同的内存语义）" class="headerlink" title="内存语义：（与volatile具有相同的内存语义）"></a><strong>内存语义</strong>：（与volatile具有相同的内存语义）</h3><ul><li><strong>释放锁</strong>时，JMM把该线程的本地内存中的<strong>共享变量会刷新到主内存</strong>中</li><li><strong>获得锁</strong>时，JMM将该线程对应的<strong>本地内存置为无效</strong>，并且<strong>从主内存中读取共享变量</strong>。</li></ul><p>实质上也是在<strong>通过主内存发送消息</strong>。</p><h3 id="5-3-ReentrantLock的实现方式（以此例讲锁的内存语义实现方式）"><a href="#5-3-ReentrantLock的实现方式（以此例讲锁的内存语义实现方式）" class="headerlink" title="5.3. ReentrantLock的实现方式（以此例讲锁的内存语义实现方式）"></a>5.3. ReentrantLock的实现方式（以此例讲锁的内存语义实现方式）</h3><p>ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer(简称AQS)。AQS<strong>使用一个整形的volatile变量（state）来维护同步状态</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrankLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    ReetrantLock lock = <span class="keyword">new</span> ReetrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>公平锁：</strong><ul><li>获取锁：读volatile变量</li><li>释放锁：写volatile变量</li></ul></li><li><strong>非公平锁：</strong><ul><li>获取锁：用原子性的CAS（compareAndSet）操作更新volatile变量（<strong>CAS同时具有volatile读和写的内存语义</strong>）</li><li>释放锁：写volatile变量</li></ul></li></ul><h3 id="5-4-锁内存语义的两种实现方式"><a href="#5-4-锁内存语义的两种实现方式" class="headerlink" title="5.4. 锁内存语义的两种实现方式"></a>5.4. 锁内存语义的两种实现方式</h3><ul><li>利用<strong>volatile的写-读所具有的内存语义</strong>。</li><li>利用<strong>CAS所同时附带的volatile读和volatile写的内存语义</strong>。</li></ul><p>这两种方式可以实现线程之间的通信。</p><h3 id="5-5-concurrent包的实现"><a href="#5-5-concurrent包的实现" class="headerlink" title="5.5. concurrent包的实现"></a>5.5. concurrent包的实现</h3><ul><li>A线程写volatile变量，随后B线程读这个volatile变量</li><li>A线程写volatile变量，随后B线程CAS更新这个volatile变量</li><li>A线程CAS更新volatile变量，随后B线程CAS更新这个volatile变量</li><li>A线程CAS更新volatile变量，随后B线程读这个volatile变量</li></ul><p>（其实就是利用锁语义的实现方式做了个排列组合）</p><p><strong>通用的实现模式：</strong></p><ol><li>声明共享变量为volatile；</li><li>使用CAS的原子条件更新来实现线程之间的同步；</li><li>配合以volatile读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li></ol><h2 id="六、final域的内存语义"><a href="#六、final域的内存语义" class="headerlink" title="六、final域的内存语义"></a>六、final域的内存语义</h2><p>与锁和volatile相比，对final域的读写更像是普通变量的访问。</p><h3 id="6-1-final域的重排序规则"><a href="#6-1-final域的重排序规则" class="headerlink" title="6.1. final域的重排序规则"></a>6.1. final域的重排序规则</h3><ul><li>写：禁止把final域的写重排序到构造函数之外。这可以保证在对象引用为任意线程可见之前，该对象的final域已经被正确初始化了（普通域不具有这个保证）</li><li>读：初次读对象的<u>引用</u> 限定在 初次读该对象<u>包含的final域</u> 之前。（确保在读一个<u>对象的final域</u>之前，一定会先读包含了这个final域的对象的<u>引用</u>。</li><li>只要对象是正确构造的（不在构造函数中逸出），那么不需要使用同步（volatile和lock）就可以保证任意线程都可以看到这个final域在构造函数中被初始化之后的值。</li></ul><h3 id="6-2-当final域为引用类型时"><a href="#6-2-当final域为引用类型时" class="headerlink" title="6.2. 当final域为引用类型时"></a>6.2. 当final域为引用类型时</h3><ul><li>对final域为引用类型的多线程读写时，就像对普通域一样读写，是存在数据竞争的，这时候需要用同步原语（lock和volatile）来确保内存可见性。</li></ul><p>final引用不能从构造函数内溢出：</p><p>写final域的保证：这可以保证在对象引用为任意线程可见之前，该对象的final域已经被正确初始化了</p><p>前提：构造函数内部，不能让这个被构造函数的引用为其他线程可见，也就是说对象应用不能在构造函数中“溢出”。（因为此时的final域肯恩给还没有被初始化）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误的构造示例 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;<span class="comment">//写final域</span></span><br><span class="line">        obj = <span class="keyword">this</span>;<span class="comment">//this引用再次溢出了（对外可见了）这是不正确的构造</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;<span class="comment">//A线程写</span></span><br><span class="line">        <span class="keyword">new</span> FinalReferenceEscapeExample();<span class="comment">//创建一个实例，调用了构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;<span class="comment">//B线程读</span></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = obj.i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，A线程写调用构造函数返回前，该对象的引用就变得对线程B可见了，这可能会导致i在被初始化之前就被读取。（虽然final保证final的写不被重排序到构造函数之外，但构造函数结束之前就被暴露了出来，可能会被B线程在final域未被初始化前提前读取）。</p><h2 id="七、happens-before"><a href="#七、happens-before" class="headerlink" title="七、happens-before"></a>七、happens-before</h2><p>happens-before是JMM最核心的概念。对于程序员来说，理解happens-before是理解JMM的关键。</p><h3 id="7-1-JMM的设计"><a href="#7-1-JMM的设计" class="headerlink" title="7.1. JMM的设计"></a>7.1. JMM的设计</h3><p><img src="/Blog/Java/Java并发编程艺术/第3章-Java内存模型/图3-3 JMM的设计示意图.png" alt="图3-3 JMM的设计示意图"></p><ul><li>程序员希望内存模型易于理解和编程，是个强内存模型。JMM对此向程序员提供happens-before规则保证了内存可见性。</li><li>编译器和处理器对内存模型的实现希望束缚越少越好以提高性能，是个弱内存模型。JMM规定只要不改变程序（单线程）的执行结果，编译器和处理器怎么优化都行。</li></ul><h3 id="7-2-happens-before的定义"><a href="#7-2-happens-before的定义" class="headerlink" title="7.2. happens-before的定义"></a>7.2. happens-before的定义</h3><ul><li>如果一个操作happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。（JMM对程序员的保证）</li><li>两个操作之间存在happens-before 关系，并不意味着执行顺序一定是happens-before指定的顺序。（JMM对编译器和处理器的保证）</li></ul><h3 id="7-3-as-if-serial"><a href="#7-3-as-if-serial" class="headerlink" title="7.3. as-if-serial"></a>7.3. as-if-serial</h3><ul><li>as-if-serial保证单线程内程序的执行结果不改变，happens-before关系保证了多线程程序执行结果不被改变。</li><li>as-if-serial让程序员感受到单线程程序是按照程序的顺序执行的，happens-before让程序员感觉正确同步的多线程程序是按照happens-before指定的顺序来执行的。</li></ul><h3 id="7-4-happens-before规则"><a href="#7-4-happens-before规则" class="headerlink" title="7.4. happens-before规则"></a>7.4. happens-before规则</h3><ul><li><strong>程序顺序规则</strong>：一个线程中的<strong>每个操作</strong>，<strong>happens-before于</strong>该线程中的任意<strong>后续操作</strong>。（同一线程内顺序排序）</li><li><strong>监视器锁规则</strong>：对一个锁的<strong>解锁</strong>，<strong>happens-before于</strong>随后对其<strong>加锁</strong>。（解锁–&gt;加锁）（解锁的写入一定能被加锁的线程看到）</li><li><strong>volatile变量规则</strong>：对一个<strong>volatile域的写</strong>，<strong>happens-before于</strong>任意后续对这个<strong>volatile域的读</strong>。（写–&gt;读）</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C</li><li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么<strong>A线程的ThreadB.start()操作happens-before于线程B中的任意操作</strong>。</li><li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么<strong>线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回</strong>。</li></ul><h2 id="八、双重检查锁定与延迟初始化"><a href="#八、双重检查锁定与延迟初始化" class="headerlink" title="八、双重检查锁定与延迟初始化"></a>八、双重检查锁定与延迟初始化</h2><h2 id="九、JMM综述"><a href="#九、JMM综述" class="headerlink" title="九、JMM综述"></a>九、JMM综述</h2><p>JMM是语言级的内存模型，处理器内存模型是硬件及的内存模型（更弱）。</p><h3 id="9-1-JMM的内存可见性保证："><a href="#9-1-JMM的内存可见性保证：" class="headerlink" title="9.1. JMM的内存可见性保证："></a>9.1. JMM的内存可见性保证：</h3><ul><li>单线程程序：单线程程序不会出现内存可见性问题。</li><li>正确同步的多线程程序：正确同步的多线程程序的执行见具有顺序一致性（程序的执行结果与顺序一致性内存模型中的结果相同）（JMM用限制重排序来保证）</li><li>未同步/未正确同步的多线程程序：最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op1=>operation: 源代码op2=>operation: 1：编译器优化重排序op3=>operation: 2：指令级并行重排序op4=>operation: 3：内存系统重排序op5=>operation: 4：最终执行的指令序列op1(right)->op2(right)->op3(right)->op4(right)->op5</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">op1=>start: 程序员op2=>operation: happens-before 规则(JMM呈现给程序员的视图部分）op3=>operation: 禁止某种类型的编译器/处理器重排序( JMM的实现 )op4=>operation: 处理器/编译器重排序规则(JMM定义的规则)op1(right)->op2(right)->op3(right)->op4</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">op1=>operation: 1: 线程A修改共享变量op2=>operation: 2: 线程A写volatile变量op3=>operation: 3: 线程B读同一个volatile变量op4=>operation: 4: 线程B读共享变量op1->op2(right)->op3->op4</textarea><textarea id="flowchart-2-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本章主要通过Java的内存模型来讲解汇编代码的重排序现象，顺序一致性，happens-before原则，volatile内存语义和synchronized，final，锁，双重检查锁等在内存模型中的体现和原理表达。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java并发编程艺术" scheme="https://uncleaaron.github.io/Blog/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="并发编程" scheme="https://uncleaaron.github.io/Blog/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>第2章 Java并发编程机制的底层实现原理</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC2%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java并发编程艺术/第2章-Java并发编程机制的底层实现原理/</id>
    <published>2018-05-28T12:46:25.000Z</published>
    <updated>2018-07-16T12:43:43.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本章主要讲解了volatile以及synchronized的原理和语义，以及Java中的原子操作CAS等。</p></blockquote><a id="more"></a><h1 id="第2章-Java并发编程机制的底层实现原理"><a href="#第2章-Java并发编程机制的底层实现原理" class="headerlink" title="第2章 Java并发编程机制的底层实现原理"></a>第2章 Java并发编程机制的底层实现原理</h1><h2 id="一、volatile"><a href="#一、volatile" class="headerlink" title="一、volatile"></a>一、volatile</h2><p>volatile是<strong>轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。</strong>（<strong>当一个程序修改一个共享变量时，另外一个线程能读到这个修改的值</strong>）</p><p>Java规范定义：允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。</p><p>volatile使用恰当的话，它比synchronized的使用和执行成本更低，因为它<strong>不会引起线程上下文切换和调度。</strong></p><h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对volatile进行写操作 */</span></span><br><span class="line">instance = <span class="keyword">new</span> Singleton();<span class="comment">//instance是volatile变量</span></span><br></pre></td></tr></table></figure><p>转化成汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x01a3de1d: movb $0x0,0x1004800(%esi)</span><br><span class="line">0x01a3de24: lock addl $0x0,(%esp)</span><br></pre></td></tr></table></figure></p><p>有volatile变量修饰的共享变量进行写操作的额时候会多出第二行汇编代码。<br>Lock前缀的指令在多核处理器下会发生两件事：</p><ol><li>Lock前缀指令会引起处理器缓存回写到内存。</li><li>一个处理器的缓存回写到内存会使在其他CPU里的该缓存数据无效（个人理解：可以保证数据一致性）</li></ol><h4 id="volatile使用优化"><a href="#volatile使用优化" class="headerlink" title="volatile使用优化"></a>volatile使用优化</h4><p>例：JDK7的并发包新增的队列集合类LinkedTransferQueue在使用volatile变量时，采用追加字节的方式来优化队列出入队的性能。他将共享变量追加到64字节，原因是现在许多CPU缓存行的大小是64字节宽，不支持部分填充缓存行， 当一个处理器试图修改缓存行的时候会将整个缓存行锁定，若字节数小于64，则头尾节点可能会缓存到同一个缓存行，这样会互相锁定降低修改效率。</p><h2 id="二、synchronized"><a href="#二、synchronized" class="headerlink" title="二、synchronized"></a>二、synchronized</h2><p>利用 <strong>synchronized</strong>实现同步的基础：<strong>Java中的每一个对象都可以作为锁</strong>，具体表现为以下三种形式：</p><ul><li>对于<strong>普通同步方法</strong>：锁是当前<strong>实例对象</strong>。</li><li>对于<strong>静态同步方法</strong>：锁是<strong>当前类的Class对象</strong>。</li><li>对于<strong>同步方法块</strong>：锁是<strong>synchronized括号里配置的对象</strong>。</li></ul><p>而<strong>synchronized用的锁是存在Java对象头里的</strong></p><h3 id="2-1-Java对象头"><a href="#2-1-Java对象头" class="headerlink" title="2.1. Java对象头"></a>2.1. Java对象头</h3><p>synchronized用的锁是存在Java对象头里的</p><p>对象头里的Mark Word默认存对象的HashCode，分代年龄和锁标记位</p><table><thead><tr><th style="text-align:center">锁状态</th><th style="text-align:center">25bit</th><th style="text-align:center">4bit</th><th style="text-align:center">1bit 是否偏向锁</th><th style="text-align:center">2bit 锁标志位</th></tr></thead><tbody><tr><td style="text-align:center">重量级锁</td><td style="text-align:center">-</td><td style="text-align:center">指向互斥量（重量级锁）的指针</td><td style="text-align:center">-</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">轻量锁</td><td style="text-align:center">-</td><td style="text-align:center">指向栈中锁的指针</td><td style="text-align:center"></td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">偏向锁</td><td style="text-align:center">线程ID</td><td style="text-align:center">对象分代年龄对象分代年龄</td><td style="text-align:center">1</td><td style="text-align:center">01</td></tr><tr><td style="text-align:center">无锁状态</td><td style="text-align:center">对象的HashCode</td><td style="text-align:center">对象分代年龄</td><td style="text-align:center">0</td><td style="text-align:center">11</td></tr><tr><td style="text-align:center">GC标记</td><td style="text-align:center"></td><td style="text-align:center">空</td><td style="text-align:center">-</td><td style="text-align:center">11</td></tr></tbody></table><h3 id="2-2-锁的升级和对比"><a href="#2-2-锁的升级和对比" class="headerlink" title="2.2. 锁的升级和对比"></a>2.2. 锁的升级和对比</h3><p>为了减少获得锁和释放锁的性能消耗，引入“偏向锁”和“轻量级锁”</p><p>锁从低到高的4个状态：无锁 –&gt; 偏向锁 –&gt; 轻量级锁 –&gt; 重量级锁</p><p>这几个状态会随着竞争逐渐升级（不可以降级，目的是为了提高获得/释放锁的效率）</p><h4 id="1-偏向锁"><a href="#1-偏向锁" class="headerlink" title="1. 偏向锁"></a>1. 偏向锁</h4><p>存在现象：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得，为了让线程获得锁的代价更低而引入偏向锁。</p><p>原理：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进出同步块时不需要进行CAS操作来加锁或解锁，只需要简单的测试一下对象头的MarkWord里是否存储着指向当前线程的偏向锁。（偏向锁在Java6和Java7内是默认启用的）</p><p>撤销偏向锁：直到竞争出现才会释放锁。流程：①暂停拥有偏向锁的线程 ②解锁，将线程ID设置为空 ③恢复线程</p><p><em>（注意撤销偏向锁与解锁不同：撤销偏向锁是指将偏向锁的偏向线程改为别的线程或空，解锁是释放锁）</em></p><h4 id="2-轻量级锁"><a href="#2-轻量级锁" class="headerlink" title="2. 轻量级锁"></a>2. 轻量级锁</h4><p>加锁：JVM在当前线程的栈帧中创建用于存储锁的空间，并拷贝对象头中的MarkWord到锁记录中，再由线程尝试将对象头中的MarkWord替换为指向锁的指针。成功则获得锁，失败则有竞争，线程会采用自旋来获得锁（消耗CPU，为了避免无用的自旋，有必要升级为重量级锁）</p><p>解锁：使用CAS将拷贝的MarkWord替换回对象头。如果成功，表示没有竞争发生；如果失败，则当前锁存在竞争，锁会膨胀成重量级锁。</p><h4 id="3-重量级锁"><a href="#3-重量级锁" class="headerlink" title="3. 重量级锁"></a>3. 重量级锁</h4><p>线程试图获取重量级锁的时候，都会被阻塞，当持有锁的线程释放锁后会唤醒这些线程，然后进行新一轮的竞争</p><h4 id="锁的优缺点和对比"><a href="#锁的优缺点和对比" class="headerlink" title="锁的优缺点和对比"></a>锁的优缺点和对比</h4><table><thead><tr><th style="text-align:center">锁</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center">偏向锁</td><td style="text-align:center">加锁解锁不需要额外的消耗，和非同步的方法执行只有纳秒级的差距</td><td style="text-align:center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td style="text-align:center">适用于只有一个线程访问同步块的场景</td></tr><tr><td style="text-align:center">轻量级锁</td><td style="text-align:center">竞争的线程不会阻塞，提高了程序的响应速度</td><td style="text-align:center">如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td><td style="text-align:center">追求响应时间<br>同步块执行速度非常快</td></tr><tr><td style="text-align:center">重量级锁</td><td style="text-align:center">线程竞争不使用自旋，不消耗CPU</td><td style="text-align:center">线程阻塞，响应时间慢</td><td style="text-align:center">追求吞吐量<br>同步块执行速度较长</td></tr></tbody></table><h2 id="三、原子操作的实现原理"><a href="#三、原子操作的实现原理" class="headerlink" title="三、原子操作的实现原理"></a>三、原子操作的实现原理</h2><h4 id="3-1-实现方法："><a href="#3-1-实现方法：" class="headerlink" title="3.1. 实现方法："></a>3.1. 实现方法：</h4><ol><li>缓存加锁/总线加锁：保证基本内存操作原子性</li><li>缓存锁定/总线锁定：保证跨缓存行或跨页表访问等复杂的内存操作的原子性</li></ol><h4 id="3-2-Java中实现原子操作"><a href="#3-2-Java中实现原子操作" class="headerlink" title="3.2. Java中实现原子操作"></a>3.2. Java中实现原子操作</h4><p>从Java1.5开始，JDK并发包里提供了一些类来支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger、AtomicLong等。</p><h5 id="3-2-1-使用循环CAS实现原子操作"><a href="#3-2-1-使用循环CAS实现原子操作" class="headerlink" title="3.2.1. 使用循环CAS实现原子操作"></a>3.2.1. 使用循环CAS实现原子操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicI = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 使用CAS实现线程安全计数器</span></span><br><span class="line"><span class="comment">* CAS:Compare and set(switch)</span></span><br><span class="line"><span class="comment">* 在操作前先比较旧值有没有变化，没变化才换成新值，否则不替换（可以保证数据一致性）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = atomicI.get();</span><br><span class="line">        <span class="comment">//CAS操作(旧值,新值)：旧值相同才替换为新值，否则不替换</span></span><br><span class="line">        <span class="keyword">boolean</span> suc = atomicI.compareAndSet(i, i++);</span><br><span class="line">        <span class="keyword">if</span> (suc) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//修改成功则break，否则继续循环到操作成功（可能会由于长时间不成功带来巨额开销）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 非线程安全计数器 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-2-使用锁实现原子操作"><a href="#3-2-2-使用锁实现原子操作" class="headerlink" title="3.2.2. 使用锁实现原子操作"></a>3.2.2. 使用锁实现原子操作</h5><p>锁机制保证了只有获得锁的线程才能操作锁定的内存区域（但其实Java除了偏向锁，其他的锁都用了循环CAS的机制获取和释放锁）</p><h5 id="3-2-3-CAS实现原子操作的三大问题："><a href="#3-2-3-CAS实现原子操作的三大问题：" class="headerlink" title="3.2.3. CAS实现原子操作的三大问题："></a>3.2.3. CAS实现原子操作的三大问题：</h5><ol><li><p>ABA问题。一个值反复从A到B，B到A，使用CAS检查时以为没有变化，实际上却发生了变化。</p><p>解决思路：使用版本号</p><p>JDK的Atomic包里提供了AtomicStampedRefence来解决ABA问题</p></li><li><p>循环时间长开销大。如果CAS长时间不成功，CPU开销会很大。</p></li><li><p>只能保证一个共享变量的原子操作。</p><p>解决办法：</p><ol><li>使用锁</li><li>将多个共享变量合并成一个共享变量来操作。JDK提供了AtomicReference，把多个变量放在同一个对象里进行CAS操作。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本章主要讲解了volatile以及synchronized的原理和语义，以及Java中的原子操作CAS等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java并发编程艺术" scheme="https://uncleaaron.github.io/Blog/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="并发编程" scheme="https://uncleaaron.github.io/Blog/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>第1章 并发编程的挑战</title>
    <link href="https://uncleaaron.github.io/Blog/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/%E7%AC%AC1%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98/"/>
    <id>https://uncleaaron.github.io/Blog/Java/Java并发编程艺术/第1章-并发编程的挑战/</id>
    <published>2018-05-27T12:46:25.000Z</published>
    <updated>2018-07-17T01:49:12.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>近日补充学习了《Java并发编程艺术》这本书，精读后自己做出总结，把书读薄，能加深印象。</p><p>本章主要讲解了Java并发编程需要面对和解决的挑战：上下文切换的消耗，死锁 以及 资源的限制</p></blockquote><a id="more"></a><h1 id="第1章-并发编程的挑战"><a href="#第1章-并发编程的挑战" class="headerlink" title="第1章 并发编程的挑战"></a>第1章 并发编程的挑战</h1><p>并发编程以后多种挑战需要面临：例如上下文切换问题、死锁问题、受限于硬件/软件资源限制的问题</p><h2 id="一、上下文切换"><a href="#一、上下文切换" class="headerlink" title="一、上下文切换"></a>一、上下文切换</h2><ul><li>过多的上下文切换会影响效率。</li><li>在较少数量级的运算中，因为线程的创建以及上下文切换，可能导致并行比串行执行还慢。</li></ul><h3 id="减少上下文切换的方法："><a href="#减少上下文切换的方法：" class="headerlink" title="减少上下文切换的方法："></a>减少上下文切换的方法：</h3><ol><li><strong>无锁并发编程</strong>：（多线程竞争锁的时候会导致上下文切换）<strong>采用一些方法避免使用锁</strong>，比如：用hash算法将数据ID取模分段，然后不同线程处理不同段的数据</li><li><strong>CAS算法</strong>：Java的Atomic包使用CAS算法更新数据，不需要加锁</li><li><strong>使用最少线程</strong>：<strong>避免创建不需要的线程</strong>（过多线程的等待状态会导致上下文切换增加）（换言之要减少等待状态的线程）</li><li><strong>协程</strong>：<strong>在单线程内实现多任务调度</strong>，并在单线程内维持多任务切换。</li></ol><h2 id="二、死锁"><a href="#二、死锁" class="headerlink" title="二、死锁"></a>二、死锁</h2><h3 id="避免死锁的几种常见方法"><a href="#避免死锁的几种常见方法" class="headerlink" title="避免死锁的几种常见方法"></a>避免死锁的几种常见方法</h3><ul><li><strong>避免一个线程同时获得多个锁</strong></li><li><strong>避免一个线程在锁内同时占用多个资源</strong>，尽量保证每个所只占用一个资源</li><li>尝试<strong>使用定时锁</strong>（用lock.tryLock(timeout) 来替代内部锁机制）</li><li><strong>数据库锁的加锁和解锁必须在一个数据库连接里</strong>，否则会出现解锁失败的情况。</li></ul><h2 id="三、资源限制"><a href="#三、资源限制" class="headerlink" title="三、资源限制"></a>三、资源限制</h2><ul><li>资源限制分为<strong>软件资源</strong>（数据库连接数，socket连接数等）和<strong>硬件资源</strong>（CPU处理速度，硬盘读写速度等）的限制</li><li>资源限制<strong>导致的问题</strong>：有时候受限于资源，导致程序仍然在串行执行，加上上下文切换和资源调度，会更慢</li><li>解决资源限制的问题：<strong>集群并行执行</strong>（多机运行程序（不同机器处理不同数据））（也就是加服务器）</li><li>在资源限制的情况下并发编程：需要<strong>根据不同的资源限制调整程序的并发度</strong> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;近日补充学习了《Java并发编程艺术》这本书，精读后自己做出总结，把书读薄，能加深印象。&lt;/p&gt;
&lt;p&gt;本章主要讲解了Java并发编程需要面对和解决的挑战：上下文切换的消耗，死锁 以及 资源的限制&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java并发编程艺术" scheme="https://uncleaaron.github.io/Blog/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://uncleaaron.github.io/Blog/tags/Java/"/>
    
      <category term="并发编程" scheme="https://uncleaaron.github.io/Blog/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://uncleaaron.github.io/Blog/hello-world/"/>
    <id>https://uncleaaron.github.io/Blog/hello-world/</id>
    <published>2018-05-20T12:46:25.000Z</published>
    <updated>2018-07-17T01:16:45.744Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">or</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
