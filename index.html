<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/Blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/Blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/Blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/Blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="StormAaron的技术站">
<meta property="og:url" content="https://uncleaaron.github.io/Blog/index.html">
<meta property="og:site_name" content="StormAaron的技术站">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="StormAaron的技术站">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/Blog/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://uncleaaron.github.io/Blog/"/>





  <title>StormAaron的技术站</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/Blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">StormAaron的技术站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/Blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/Blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/Blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/Blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/Blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uncleaaron.github.io/Blog/Blog/2018/06/20/软件体系结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron.H">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StormAaron的技术站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Blog/2018/06/20/软件体系结构/" itemprop="url">软件体系结构复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-20T00:05:10+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="4-1视图"><a href="#4-1视图" class="headerlink" title="4+1视图"></a>4+1视图</h1><h2 id="逻辑视图"><a href="#逻辑视图" class="headerlink" title="逻辑视图"></a>逻辑视图</h2><p>功能需求（功能调用关系）(可以根据菜单设计)</p>
<p>最终用户</p>
<h2 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h2><p>拓扑结构</p>
<p>系统工程人员</p>
<h2 id="开发视图"><a href="#开发视图" class="headerlink" title="开发视图"></a>开发视图</h2><p>软件各层模块设计（页面-业务-底层(DB,网络,安全…)）</p>
<p>编程人员</p>
<h2 id="进程视图"><a href="#进程视图" class="headerlink" title="进程视图"></a>进程视图</h2><p>画出一个流程的从前端到后端的各个可能产生关系的进程调用关系。</p>
<p>系统集成人员</p>
<h2 id="场景视图"><a href="#场景视图" class="headerlink" title="场景视图"></a>场景视图</h2><p>某个功能场景下，从用户操作到系统内部顺序的整个过程描述</p>
<h1 id="软件体系结构"><a href="#软件体系结构" class="headerlink" title="软件体系结构"></a>软件体系结构</h1><p>软件体系结构是对系统的高层设计，是指系统的基本组织结构，包括</p>
<p>组成系统的<strong>构件</strong>、<strong>构件之间的连接关系</strong>、以及系统需满足的<strong>约束</strong>、原则等。</p>
<h1 id="软件体系结构风格"><a href="#软件体系结构风格" class="headerlink" title="软件体系结构风格"></a>软件体系结构风格</h1><p>软件体系结构风格是描述某一特定应用领域中系统组织方式的惯用模式。</p>
<p>体系结构风格定义一个<strong>词汇表</strong>和<strong>一组约束</strong>。</p>
<p><strong>词汇表</strong>：包含<strong>构件</strong>和<strong>连接件</strong>类型，</p>
<p><strong>约束</strong>：指出系统是<strong>如何将这些构件和连接件组合</strong>起来的。</p>
<p>体系结构风格<strong>反映</strong>了众多系统所<strong>共有的结构</strong>和语义特性，并<strong>指导</strong>如何将各个模块<strong>有效地组织成一个完整的系统</strong>。</p>
<h2 id="面向对象设计风格"><a href="#面向对象设计风格" class="headerlink" title="面向对象设计风格"></a>面向对象设计风格</h2><p>这种风格建立在数据抽象和面向对象的基础上，数据的表示方法和它们的相应操作封装在一个抽象数据类型或对象中。</p>
<p>这种风格的构件是对象，或者说是抽象数据类型的实例。对象是一种被称作管理者的构件，因为它负责保持资源的完整性。对象是通过函数和过程的调用来交互的。</p>
<h2 id="结构化设计风格"><a href="#结构化设计风格" class="headerlink" title="结构化设计风格"></a>结构化设计风格</h2><p>模块化？非结构化？</p>
<p>模块化设计，采用自顶向下的方法，将问题划分为多个相对独立、功能单一的模块，以功能块为单位进行程序设计，实现其求解算法的方法称为模块化。降低了程序复杂度，提高代码的重用性，使程序易于调试和维护、扩充。</p>
<h2 id="管道过滤器风格"><a href="#管道过滤器风格" class="headerlink" title="管道过滤器风格"></a>管道过滤器风格</h2><p>每个<strong>构件（过滤器）</strong>都<strong>有一组输入和输出</strong>，构件读输入的数据流，经过<strong>内部处理</strong>，然后<strong>产生输出</strong>数据流。这里的构件被称为<strong>过滤器</strong>，这种风格的<strong>连接件</strong>是数据流传输的<strong>管道</strong>，将一个<strong>过滤器的输出传到另一过滤器的输入</strong>。</p>
<p><code>过滤器 → 管道 → 过滤器</code></p>
<h2 id="层次风格"><a href="#层次风格" class="headerlink" title="层次风格"></a>层次风格</h2><p>层次系统组织成一个层次结构，<strong>每一层为上层服务，并作为下层客户</strong>。在一些层次系统中，<strong>内部的层只对相邻的层可见。</strong>这种风格支持基于可增加抽象层的设计。允许将一个复杂问题分解成一个增量<strong>步骤序列的实现</strong>。</p>
<p>//由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件重用提供了强大的支持。</p>
<h2 id="CS风格"><a href="#CS风格" class="headerlink" title="CS风格"></a>CS风格</h2><p>C/S软件体系结构是基于资源不对等，且为实现共享而提出来的，C/S体系结构<strong>定义了工作站如何与服务器相连，以实现数据和应用分布到多个处理机上</strong>。 </p>
<p>C/S体系结构有三个主要组成部分：<strong>数据库服务器</strong>、<strong>客户端程序</strong> 和 <strong>网络</strong>。</p>
<p><strong>客户端</strong>，服务请求者。<strong>不共享任何资源</strong>，但需要<strong>获取服务器</strong>的<strong>内容</strong>或<strong>功能</strong>。 </p>
<p><strong>服务器</strong>运行一个或多个服务器计划，与客户<strong>分享他们的资源</strong>。  </p>
<h2 id="BS风格"><a href="#BS风格" class="headerlink" title="BS风格"></a>BS风格</h2><p>浏览器/服务器（B/S）风格就是上述三层C/S结构的一种实现方式，其具体结构为：<strong>浏览器</strong>/<strong>Web服务器</strong>/<strong>数据库服务器</strong>。B/S体系结构主要是利用不断成熟的<strong>WWW浏览器技术</strong>，结合<strong>浏览器的多种脚本语言</strong>，用<strong>通用浏览器</strong>就实现了原来需要复杂的专用软件才能实现的强大功能，并<strong>节约了开发成本</strong>。</p>
<h2 id="CS、BS混合风格"><a href="#CS、BS混合风格" class="headerlink" title="CS、BS混合风格"></a>CS、BS混合风格</h2><p>CS和BS各有优缺点，标准在不同地方也有不同的地位，使用习惯不同，还有遗留代码，所以会使用混合</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><ol>
<li>对<strong>扩展是开放的</strong>。模块的<strong>行为可以扩展</strong>，当需求改变时，可以对模块进行扩展，<strong>增加新的功能</strong>。</li>
<li>对<strong>修改是封闭的</strong>。在对模块行为进行扩展时，<strong>不允许修改模块中已经存在的类的源代码</strong>。</li>
</ol>
<h2 id="接口编程"><a href="#接口编程" class="headerlink" title="接口编程"></a>接口编程</h2><p>所有的<strong>定义与实现分离</strong>。把业务抽象出来，具体实现通过该接口的实现完成。</p>
<p>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象<strong>内部实现显得不那么重要</strong>；而各个对象之间的<strong>协作关系</strong>则成为<strong>系统设计的关键</strong>。小到不同类之间的<strong>通信</strong>，大到各模块之间的<strong>交互</strong>，是系统设计的主要工作内容。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式是对<strong>软件设计经验的总结</strong>，是对软件设计中<strong>反复出现的设计问题的成功解决方案</strong>的描述。设计模式可以用于软件体系结构的设计，以实现体系结构级的<strong>设计复用</strong>。设计模式可以使设计者<strong>更加方便地借鉴并直接使用</strong>已经经过证实的成功设计方案，不必花时间进行重复设计。帮助设计者<strong>更快更好地完成软件系统的设计工作</strong>。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>无论是单例还是多例，对象属性和方法都不static。</p>
<p>而static的应该是获取单例/多例对象相关的方法或属性，</p>
<p><strong>构造器</strong>都应该是<strong>私有的</strong>，因为不允许从getInstance外的其他方式构造对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChairMan</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ChairMan chairmanInstance;	<span class="comment">//单例对象</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="comment">// 私有构造器，因为不允许外部初始化。</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">ChairMan</span><span class="params">(String name)</span></span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 单例在第一次调用时初始化单例的static对象，后续不允许初始化。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ChairMan <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (chairmanInstance == <span class="keyword">null</span>) &#123;	<span class="comment">//检查是否已经被初始化，未初始化则创建，否则已存在，跳过</span></span><br><span class="line">			chairmanInstance = <span class="keyword">new</span> ChairMan(<span class="string">"习近平"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> chairmanInstance;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//对象实例方法，不静态处理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> name + <span class="keyword">super</span>.toString(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h2><p>多个对象在类加载时就已经进行内部初始化，通过getInstance从static对象中获取对象，在构造器中限制类初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Marshal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用一个Map对象存放多例的对象，以便用key随机查找</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Marshal&gt; marshalInstances = <span class="keyword">new</span> HashMap&lt;String, Marshal&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;	<span class="comment">//已初始化对象的数量，在构造方法中自增</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = <span class="number">5</span>;	<span class="comment">//限制的多例对象数量上限，在构造方法中限制，超出则异常</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> String name;	<span class="comment">//实例对象的属性，不采取static</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//类加载时执行代码块，初始化多个对象</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		String[] marshals = &#123;<span class="string">"陈毅"</span>,<span class="string">"罗荣桓"</span>,<span class="string">"徐向前"</span>,<span class="string">"聂荣臻"</span>,<span class="string">"叶剑英"</span>,<span class="string">"刘德华"</span>&#125;;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">			<span class="keyword">for</span> (String name : marshals) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				marshalInstances.put(name,<span class="keyword">new</span> Marshal(name));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123; System.out.println(ex); &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">    <span class="comment">// 是私有的，因为不允许外部初始化</span></span><br><span class="line">    <span class="comment">// 并通过已存在多例对象数量和已设上限来禁止超出上限数量后的初始化。</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Marshal</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (count &gt;= MAX_COUNT) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"不可继续创建新的元帅"</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			count ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从Map中获取多例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Marshal <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> marshalInstances.get(name);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//对象实例方法，不用静态处理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> name + <span class="string">"元帅"</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单工厂方法模式"><a href="#简单工厂方法模式" class="headerlink" title="简单工厂方法模式"></a>简单工厂方法模式</h2><p>思想：在工厂类中用一个switch-case分辨需要的是哪一个类的对象，用一个父类型的引用获取新建的子类型对象。</p>
<p><img src="/Blog/2018/06/20/软件体系结构/工厂模式-简单工厂模式.png" alt="工厂模式-简单工厂模式"></p>
<p>缺点：</p>
<ol>
<li>工厂类必须知道怎么样创建每个子类的对象，所以每次增加产品的时候，都需要修改工厂类代码，不符合开闭原则。</li>
<li>简单工厂类的工厂方法是静态的，不能被继承，只能是一个单独的类。</li>
</ol>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><img src="/Blog/2018/06/20/软件体系结构/工厂模式-工厂模式.png" alt="工厂模式-工厂模式"></p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>对同结构的产品抽象成父类，不同的公司工厂生产其对应的产品。</p>
<p>有两种情况：</p>
<p><strong>拓展产品不符合开闭原则</strong></p>
<p><strong>拓展工厂符合开闭原则</strong></p>
<p><img src="/Blog/2018/06/20/软件体系结构/工厂模式-抽象工厂模式.png" alt="工厂模式-抽象工厂模式"></p>
<h2 id="安全组合模式"><a href="#安全组合模式" class="headerlink" title="安全组合模式"></a>安全组合模式</h2><p><img src="/Blog/2018/06/20/软件体系结构/组合模式-安全组合模式.png" alt="组合模式-安全组合模式"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         *           composite1 </span></span><br><span class="line"><span class="comment">         *           /      \ </span></span><br><span class="line"><span class="comment">         *        leaf1   composite2 </span></span><br><span class="line"><span class="comment">         *                  /   \ </span></span><br><span class="line"><span class="comment">         *               leaf2  leaf3         </span></span><br><span class="line"><span class="comment">         *                </span></span><br><span class="line"><span class="comment">         * */</span>  </span><br><span class="line">        Component leaf1=<span class="keyword">new</span> Leaf();  </span><br><span class="line">        Component leaf2=<span class="keyword">new</span> Leaf();  </span><br><span class="line">        Component leaf3=<span class="keyword">new</span> Leaf();  </span><br><span class="line">        Composite composite1=<span class="keyword">new</span> Composite();  </span><br><span class="line">        Composite composite2=<span class="keyword">new</span> Composite();  </span><br><span class="line">          </span><br><span class="line">        composite2.add(leaf2);  </span><br><span class="line">        composite2.add(leaf3);  </span><br><span class="line">        composite1.add(leaf1);  </span><br><span class="line">        composite1.add(composite2);  </span><br><span class="line">          </span><br><span class="line">        composite1.doSomething();  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一致型组合模式"><a href="#一致型组合模式" class="headerlink" title="一致型组合模式"></a>一致型组合模式</h2><p>与安全组合模式的区别在于所有的构建类都有相同的接口，各个类在接口上是没有区别的，客户端可以等同对待所有的对象。不必区分叶子节点和树枝节点，不需要强制类型转换。</p>
<p>缺点在于不够安全，Leaf(Person)需要屏蔽一些方法，并且抛出适当的异常。这样在客户类调用Leaf方法的时候可以做到部分方法可以什么都不做。</p>
<p><img src="/Blog/2018/06/20/软件体系结构/组合模式-一致性组合模式.png" alt="组合模式-安全组合模式"></p>
<h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p><img src="/Blog/2018/06/20/软件体系结构/适配器模式-对象适配器.png" alt="适配器模式-类适配器"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象适配器模式的适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Ps2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 依赖于USB类，在构造时存放一个USB的实例引用（这里体现了“对象”适配器模式）</span></span><br><span class="line">    <span class="keyword">private</span> Usb usb;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Usb usb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.usb = usb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Target类的方法重写，调用了USB类的方法返回。（这里体现了适配）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isPs2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        usb.isUsb();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clienter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ps2 p = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Usber());	<span class="comment">//这里实例Target类时在Adaptor构造器里传入实例</span></span><br><span class="line">        p.isPs2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p><img src="/Blog/2018/06/20/软件体系结构/适配器模式-类适配器.png" alt="适配器模式-类适配器"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Usber</span> <span class="keyword">implements</span> <span class="title">Ps2</span> </span>&#123;	</span><br><span class="line">    <span class="comment">//这里继承了被适配类USB，可以直接作为USB被构造和使用USB的方法</span></span><br><span class="line">    <span class="comment">//由于实现了Target类，同时也可以作为Target类使用，但是实现是USB类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isPs2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isUsb();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clienter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接作为Adapter被实例化，因为是继承了USB，所以不需要new USB，直接作为USB</span></span><br><span class="line">        Ps2 p = <span class="keyword">new</span> Adapter();	</span><br><span class="line">        p.isPs2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ORM模式"><a href="#ORM模式" class="headerlink" title="ORM模式"></a>ORM模式</h2><p>对象-关系映射（Object Relational Mapping），把对象映射到基于S Q L 的关系模型数据库结构中去。这样，我们在具体的操作实体对象的时候，就不需要再去和复杂的 SQ L 语句打交道，只需简单的操作实体对象的属性和方法。</p>
<p>ORM技术是在对象和关系之间提供了一条桥梁，前台的对象型数据和数据库中的关系型的数据通过这个桥梁来相互转化 。</p>
<div id="flowchart-0" class="flow-chart"></div>

<h2 id="IOC模式"><a href="#IOC模式" class="headerlink" title="IOC模式"></a>IOC模式</h2><p>控制反转</p>
<p>IoC模式，系统中通过<strong>IoC容器</strong>来<strong>管理对象</strong>的<strong>生命周期</strong>、<strong>依赖关系</strong>等，使程序的配置和依赖性规范<strong>与实际的代码分开</strong>。<strong>通过文本配置</strong>文件进行<strong>程序组件间相互关系</strong>的配置，而<strong>不用修改编译具体的代码</strong>。</p>
<p>IoC是把以前在工厂方法里写死的对象生成代码，改变为由XML文件来定义，<strong>利用Java反射，根据XML生成相应的对象</strong>。也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p>
<p>// IOC模式把耦合从代码中移出去，放到统一的XML 文件中，通过一个容器在需要的时候把这个依赖关系形成，即把需要的接口实现注入到需要它的类中，也就是所谓“依赖注入DI”。</p>
<h2 id="Spring框架基本原理和使用"><a href="#Spring框架基本原理和使用" class="headerlink" title="Spring框架基本原理和使用"></a>Spring框架基本原理和使用</h2><p>Spring在Spring上下文中存放bean对象，对象在配置文件中声明。</p>
<p>使用时先从配置文件中获取上下文，然后可以用上下文content.getBean()获取bean对象。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span> <span class="comment">&lt;!-- 省略beans引用的头信息 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"teacher"</span> <span class="attr">class</span>=<span class="string">"cn.edu.scau.cmi.huangyanrong.spring.domain.Teacher"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"liangzaoqing"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"梁早清"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"男"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"cn.edu.scau.cmi.huangyanrong.spring.domain.Student"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"huangyanrong"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"黄彦荣"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"男"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tutor"</span> <span class="attr">ref</span>=<span class="string">"teacher"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">		ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"codes/spring/config/applicationContext.xml"</span>);</span><br><span class="line">		Student student = (Student)context.getBean(<span class="string">"student"</span>);</span><br><span class="line">		System.out.println(student);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hibernate框架基本原理和使用"><a href="#Hibernate框架基本原理和使用" class="headerlink" title="Hibernate框架基本原理和使用"></a>Hibernate框架基本原理和使用</h2><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">A=>operation: 数据库连接工具类
B=>operation: DAO类
C=>operation: Service业务类
D=>operation: Client
D(bottom)->C(right)->B(right)->A</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uncleaaron.github.io/Blog/Blog/2018/06/17/Linux/Linux程序设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron.H">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StormAaron的技术站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Blog/2018/06/17/Linux/Linux程序设计/" itemprop="url">Linux程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T00:05:10+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Shell程序设计"><a href="#Shell程序设计" class="headerlink" title="Shell程序设计"></a>Shell程序设计</h1><h2 id="bash程序执行步骤"><a href="#bash程序执行步骤" class="headerlink" title="bash程序执行步骤"></a>bash程序执行步骤</h2><ol>
<li>编辑保存<code>vi</code></li>
<li>赋可执行权限<code>chmod</code></li>
<li><code>./filename.sh</code>执行</li>
</ol>
<h2 id="bash程序结构"><a href="#bash程序结构" class="headerlink" title="bash程序结构"></a>bash程序结构</h2><p># file.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash		****Shell类型****</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释</span></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">funn</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....	<span class="comment"># 主过程</span></span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量=值	<span class="comment"># "="两边不能留空格</span></span><br></pre></td></tr></table></figure>
<p>变量都会被默认成字符串</p>
<h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><p>用户自定义变量要加<code>$</code>，加<code>{}</code>可以同其他字符分开（建议添加）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;xxx&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h4><p><strong>会替换</strong><code>$</code><strong>变量</strong>成值。参数中包含空格也要用双引号。</p>
<h4 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h4><p><strong>字符串</strong>值，不会替换<code>$</code>变量</p>
<h4 id="倒引号"><a href="#倒引号" class="headerlink" title="倒引号 "></a>倒引号 <code></code></h4><p><strong>替换命令</strong>为其执行结果</p>
<h3 id="特定变量"><a href="#特定变量" class="headerlink" title="特定变量"></a>特定变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$@</span>		<span class="comment"># 参数列表（数组）</span></span><br><span class="line">$*		<span class="comment"># 参数列表（字符串）</span></span><br><span class="line"><span class="variable">$#</span>		<span class="comment"># 参数个数</span></span><br><span class="line"><span class="variable">$n</span>		<span class="comment"># 位置参数$1，$2，$3...$n</span></span><br><span class="line"><span class="variable">$0</span>		<span class="comment"># 本脚本文件名</span></span><br><span class="line">$$		<span class="comment"># 本程序进程号</span></span><br><span class="line">$?		<span class="comment"># 上一条命令或函数的返回值</span></span><br><span class="line"><span class="variable">$HOME</span>	<span class="comment"># 用户主目录</span></span><br></pre></td></tr></table></figure>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><h3 id="expr-命令"><a href="#expr-命令" class="headerlink" title="expr 命令"></a>expr 命令</h3><p>计算算术表达式，支持 <code>+</code>、<code>-</code>、<code>\*</code>、<code>/</code>、<code>%</code>（<em>要<code></code>\</em><code></code>进行转移，否则会错误）</p>
<p>支持<code>|</code>，<code>&amp;</code>，<code>&gt;</code>，<code>&gt;=</code>，<code>!=</code>，<code>=</code>等逻辑运算，<code>|</code>,<code>&gt;</code>,<code>&lt;</code>要用<code>\</code>转义才能使用</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr arg</span><br></pre></td></tr></table></figure>
<p>数字符 和 符号 间要<strong>空格</strong></p>
<p>要改变运算次序的话需要使用<code></code>倒引号</p>
<figure class="highlight plain"><figcaption><span>`expr 5 \* 7` + 5```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### let 命令</span><br><span class="line"></span><br><span class="line">**语法**：给a赋值（语法中**不用空格**！）</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">let a=(5+7)/3</span><br></pre></td></tr></table></figure>
<h3 id="…-运算"><a href="#…-运算" class="headerlink" title="$((…))运算"></a>$((…))运算</h3><p>直接运算得出结果</p>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $((5+7))</span><br></pre></td></tr></table></figure>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p><strong>0真，1假</strong>（与熟知C语言判断相反）</p>
<p><strong>语法：</strong>注意！<strong>中括号</strong>两边<strong>要空格</strong>！！！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 条件判断语句 ]</span><br></pre></td></tr></table></figure>
<p><strong>多重条件判断组合</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-a	<span class="comment"># 与</span></span><br><span class="line">-o	<span class="comment"># 或</span></span><br><span class="line">!	<span class="comment"># 非</span></span><br></pre></td></tr></table></figure>
<p><strong>算术比较：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a -eq b		<span class="comment"># 相等（equal）</span></span><br><span class="line">a -ne b		<span class="comment"># 不相等（not equal）</span></span><br><span class="line">a -gt b		<span class="comment"># a大于b（greater then）</span></span><br><span class="line">a -ge b		<span class="comment"># a大于等于b（greater equal）</span></span><br><span class="line">a -lt b		<span class="comment"># a小于b（less then）</span></span><br><span class="line">a -le b		<span class="comment"># a小于或等于b（less equal）</span></span><br><span class="line">!expr		<span class="comment"># 假则真，真则假</span></span><br></pre></td></tr></table></figure>
<p><strong>字符比较：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = s2		<span class="comment"># 字符串相同</span></span><br><span class="line">s1 != s2	<span class="comment"># 字符串不同</span></span><br><span class="line">-n str1		<span class="comment"># 字符串不为空</span></span><br><span class="line">-z str1		<span class="comment"># 字符串为空</span></span><br></pre></td></tr></table></figure>
<p><strong>文件判断</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-d file		<span class="comment"># 是目录</span></span><br><span class="line">-e file		<span class="comment"># 存在</span></span><br><span class="line">-f file		<span class="comment"># 是文件</span></span><br></pre></td></tr></table></figure>
<h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uncleaaron.github.io/Blog/Blog/2018/06/11/Linux/Vim简易笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron.H">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StormAaron的技术站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Blog/2018/06/11/Linux/Vim简易笔记/" itemprop="url">Linux Vi</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-11T14:37:58+08:00">
                2018-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/Blog/2018/06/11/Linux/Vim简易笔记/Vi.png" alt="Vi"></p>
<h2 id="末行模式（进出、搜索、替换）"><a href="#末行模式（进出、搜索、替换）" class="headerlink" title="末行模式（进出、搜索、替换）"></a>末行模式（进出、搜索、替换）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:w	<span class="comment"># 保存</span></span><br><span class="line">:w filename	<span class="comment"># 另存为</span></span><br><span class="line">:q	<span class="comment"># 退出</span></span><br><span class="line">:q!	<span class="comment"># 退出不保存</span></span><br><span class="line">:wq	<span class="comment"># 退出保存</span></span><br><span class="line">:x	<span class="comment"># 加密保存</span></span><br></pre></td></tr></table></figure>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/&lt;pattern&gt;	<span class="comment"># 从光标向下搜索</span></span><br><span class="line">?&lt;pattern&gt;	<span class="comment"># 从光标向上搜索</span></span><br></pre></td></tr></table></figure>
<p>n：向下遍历光标</p>
<p>N：向上遍历光标</p>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>(:s/x/y普通替换本行第一个。最后加/g替换本行全部 , :%s/x/y 替换全部行第一个，这基础上加/g替换全文)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:s/old/new		<span class="comment"># 替换本行首次出现的old</span></span><br><span class="line">:s/old/new/g	<span class="comment"># 替换本行全部</span></span><br><span class="line">:%s/old/new/g	<span class="comment"># 替换全文（全部行全部）</span></span><br><span class="line">:n,m s/old/new/g	<span class="comment">#替换n-m行的全部old</span></span><br></pre></td></tr></table></figure>
<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><table>
<thead>
<tr>
<th style="text-align:center">h</th>
<th style="text-align:center">j</th>
<th style="text-align:center">k</th>
<th style="text-align:center">l</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">左</td>
<td style="text-align:center">下</td>
<td style="text-align:center">上</td>
<td style="text-align:center">右</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">k j h l	<span class="comment"># 上下左右</span></span><br><span class="line">0	<span class="comment"># 行首</span></span><br><span class="line">^	<span class="comment"># 行首</span></span><br><span class="line">$	<span class="comment"># 行尾</span></span><br><span class="line">w	<span class="comment"># 下一个字首</span></span><br><span class="line">b	<span class="comment"># 当前字首，已经在字首则到上个字首</span></span><br><span class="line">e	<span class="comment"># 当前字尾，已经在字尾则到下个字尾</span></span><br><span class="line">nw	<span class="comment"># 右移n字</span></span><br><span class="line">nb	<span class="comment"># 左移n字</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">H	<span class="comment"># 当前屏幕最顶端（Highest）</span></span><br><span class="line">nH	<span class="comment"># 当前屏第n行</span></span><br><span class="line">gg	<span class="comment"># 文首</span></span><br><span class="line">G	<span class="comment"># 文末</span></span><br><span class="line">n+	<span class="comment"># 后跳n行</span></span><br><span class="line">n-	<span class="comment"># 前跳n行</span></span><br><span class="line">nG	<span class="comment"># 跳到第n行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(	<span class="comment"># 本句首</span></span><br><span class="line">)	<span class="comment"># 下一句首</span></span><br><span class="line">&#123;	<span class="comment"># 本段首</span></span><br><span class="line">&#125;	<span class="comment"># 本段末</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+b	<span class="comment"># 向上翻一页(back)</span></span><br><span class="line">Ctrl+f	<span class="comment"># 向下翻一页（front）</span></span><br><span class="line">Ctrl+u	<span class="comment"># 向前翻半页（up）</span></span><br><span class="line">Ctrl+d	<span class="comment"># 向下翻半页（down）</span></span><br></pre></td></tr></table></figure>
<h2 id="编辑指令"><a href="#编辑指令" class="headerlink" title="编辑指令"></a>编辑指令</h2><h3 id="删除（x-d）"><a href="#删除（x-d）" class="headerlink" title="删除（x, d）"></a>删除（x, d）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x	<span class="comment"># 删除字符</span></span><br><span class="line">nx	<span class="comment"># 删除从光标开始的n个字符</span></span><br><span class="line">dd	<span class="comment"># 删除行</span></span><br><span class="line">ndd	<span class="comment">#删除包括当前行的n行</span></span><br></pre></td></tr></table></figure>
<h3 id="复制（y）"><a href="#复制（y）" class="headerlink" title="复制（y）"></a>复制（y）</h3><p>可配合光标移动使用（w, n, ^, $）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yy	<span class="comment">#当前行复制</span></span><br><span class="line">nyy	<span class="comment">#n行复制</span></span><br><span class="line">yw	<span class="comment">#复制到到字胃</span></span><br><span class="line">nyw	<span class="comment">#复制光标及其后的n个单词</span></span><br><span class="line">y^	<span class="comment">#复制光标到行首</span></span><br><span class="line">y$	<span class="comment">#复制光标到行尾</span></span><br></pre></td></tr></table></figure>
<h3 id="粘贴（p）"><a href="#粘贴（p）" class="headerlink" title="粘贴（p）"></a>粘贴（p）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p	<span class="comment"># 光标后粘贴</span></span><br><span class="line">P	<span class="comment"># 光标前粘贴</span></span><br></pre></td></tr></table></figure>
<h3 id="撤销（u）"><a href="#撤销（u）" class="headerlink" title="撤销（u）"></a>撤销（u）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u	<span class="comment"># 撤销一步</span></span><br><span class="line">U	<span class="comment"># 撤销本行操作(其实是增加了全局操作，会被u撤销)</span></span><br></pre></td></tr></table></figure>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> nu		<span class="comment"># 显示行号</span></span><br><span class="line">:<span class="built_in">set</span> nonu	<span class="comment"># 取消显示行号</span></span><br><span class="line">:nu		<span class="comment"># 取得该行行号</span></span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Vim编辑异常退出后，会无法正常进行编辑，这时候就要删除一个同名的.swap文件，即可编辑。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uncleaaron.github.io/Blog/Blog/2018/06/07/Linux/Linux总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron.H">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StormAaron的技术站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Blog/2018/06/07/Linux/Linux总结/" itemprop="url">Linux总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T00:05:10+08:00">
                2018-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Linux目录"><a href="#Linux目录" class="headerlink" title="Linux目录"></a>Linux目录</h1><table>
<thead>
<tr>
<th>目录</th>
<th>功能</th>
<th>助记</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin</td>
<td>常用系统程序目录</td>
<td>binary</td>
</tr>
<tr>
<td>/boot</td>
<td>开技设定目录</td>
<td>boot</td>
</tr>
<tr>
<td>/dev</td>
<td>系统设备装置文件目录</td>
<td>device</td>
</tr>
<tr>
<td>/etc</td>
<td>系统配置文件，尤其是passwd，shadow文件</td>
<td>Edit Text Configuration</td>
</tr>
<tr>
<td>/home</td>
<td>系统使用者的目录</td>
<td></td>
</tr>
<tr>
<td>/lib</td>
<td>Linux执行或编译程序函数库的目录</td>
<td>Libary</td>
</tr>
<tr>
<td>/mnt</td>
<td>软驱和光驱接入挂载的地方</td>
<td></td>
</tr>
<tr>
<td>/proc</td>
<td>系统核心与程序的一些信息</td>
<td></td>
</tr>
<tr>
<td>/tmp</td>
<td>临时文件目录</td>
<td>Temporary 临时的</td>
</tr>
<tr>
<td>/sbin</td>
<td>系统管理员常用指令集</td>
<td></td>
</tr>
<tr>
<td>/usr</td>
<td>/usr/sbin 系统管理员常用指令集<br>/usr/bin 一般执行文件摆放的地方</td>
<td></td>
</tr>
<tr>
<td>/var</td>
<td>摆放系统日志文件</td>
</tr>
</tbody>
</table>
<h1 id="系统启动或关闭"><a href="#系统启动或关闭" class="headerlink" title="系统启动或关闭"></a>系统启动或关闭</h1><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>暂时更改系统运行级别</p>
<p><strong>权限：</strong>root</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init [0123456]</span><br></pre></td></tr></table></figure>
<p><strong>重要参数</strong></p>
<p>0：关机级别</p>
<p>1：单用户运行级别</p>
<p>2：多用户</p>
<p>3：多用户，字符模式</p>
<p>4：用户自定义</p>
<p>5：图形界面</p>
<p>6：重启</p>
<hr>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>关闭或重启系统</p>
<p><strong>权限：</strong>root</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown [选项] [时间] [警告信息]</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-r: shutdown之后重启</span><br><span class="line">-h: 关机后不重启</span><br></pre></td></tr></table></figure>
<p><strong>时间：</strong>now 或者 +时间值</p>
<hr>
<h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><p>关闭系统和关闭电源</p>
<p><strong>权限：</strong>所有用户</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff [选项]</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p: 关闭计算机后再关闭电源</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="用户和组管理"><a href="#用户和组管理" class="headerlink" title="用户和组管理"></a>用户和组管理</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>超级用户：UID 0    （默认为root）</p>
<p>系统用户：UID 100以下</p>
<p>普通用户：UID 500+</p>
<p>/etc/passwd：账号文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaron:x:1002:1002:aaron:/home/aaron:/bin/bash</span><br><span class="line">用户名:加密密码:用户ID:组ID:用户信息:用户主目录:登陆Shell</span><br><span class="line">（默认创建用户下，GID会和UID相同）</span><br></pre></td></tr></table></figure>
<p>/etc/shadow：口令文件</p>
<p>/etc/group：用户组信息文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaron:x:500:a1,a2</span><br><span class="line">组名:密码:GID:用户列表（逗号分隔）</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>添加用户</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [选项] [参数] &lt;newUsername&gt;</span><br></pre></td></tr></table></figure>
<p><strong>选项/参数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d: 指定主目录	(directory)</span><br><span class="line">-u: 指定UID		(UID)</span><br><span class="line">-g: 指定用户组	(group)</span><br><span class="line">-G: 指定用户组列表	(Groups)</span><br><span class="line">-s: 指定Shell		(Shell)</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># useradd aaron</span></span><br></pre></td></tr></table></figure>
<p>默认条件下：系统自动分配一个500以上的UID和GID，默认创建一个与UID同名的GID组，默认在home目录下创建同名文件夹为主目录。</p>
<hr>
<h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>修改密码（root可以修改所有的密码，普通用户只能修改自己的密码）</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [选项] &lt;Username&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><p>修改用户属性</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod [选项] [参数] &lt;Username&gt;</span><br></pre></td></tr></table></figure>
<p><strong>选项/参数：</strong>（同useradd）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d: 指定主目录	(directory)</span><br><span class="line">-u: 指定UID		(UID)</span><br><span class="line">-g: 指定用户组	(group)</span><br><span class="line">-G: 指定用户组列表	(Groups)</span><br><span class="line">-s: 指定Shell		(Shell)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><p>删除用户</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel [选项] &lt;Username&gt;</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-r: 删除用户的同时删除主目录</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><hr>
<h3 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h3><p>添加用户组</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd [选项] &lt;GroupName&gt;</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g: 设定组ID</span><br><span class="line">-r: 添加系统组(GID小于500)</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 501 worker</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h3><p>修改组属性</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod [选项] &lt;GroupName&gt;</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g GID：设定组ID</span><br><span class="line">-n &lt;GroupName&gt;: 设定新组名</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="账号查看"><a href="#账号查看" class="headerlink" title="账号查看"></a>账号查看</h2><hr>
<h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>显示系统中有哪些用户正在使用</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who [选项]</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-u: 显示详细的用户状态</span><br><span class="line">-H: 显示表头</span><br><span class="line">-a: 显示所有用户</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ who -uH</span><br><span class="line">NAME     LINE         TIME             IDLE          PID COMMENT</span><br><span class="line">aaron    pts/0        2018-06-07 11:35   .         21837 (125.88.24.125)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="w"><a href="#w" class="headerlink" title="w"></a>w</h3><p>显示系统中用户使用情况，是who的增强版</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w [选项] [user]</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s: 简短模式</span><br><span class="line">user: 指定用户</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h3><p>显示当前用户名</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>显示用户信息</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id [选项]</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g: 只显示GID</span><br><span class="line">-u: 只显示UID</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>切换用户身份</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [选项] [username]</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-l: 同时切换用户主目录</span><br><span class="line">-: 同时切换环境变量</span><br><span class="line">-m: 保留环境变量</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>以root身份执行指令</p>
<p><strong>权限：</strong>在 /etc/sudoers 中有出现的使用者</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>/etc/shells: 查看系统支持的shell</p>
<p>一般shell都在/bin/xxx目录下（xx为shell名，例如/bin/bash ）</p>
<p>root 提示符# 其他用户提示符$</p>
<h1 id="输入-输出重定向"><a href="#输入-输出重定向" class="headerlink" title="输入/输出重定向"></a>输入/输出重定向</h1><h2 id="文件描述符（0-1-2）"><a href="#文件描述符（0-1-2）" class="headerlink" title="文件描述符（0, 1, 2）"></a>文件描述符（0, 1, 2）</h2><p><strong>0：标准输入</strong></p>
<p><strong>1：标准输出</strong></p>
<p><strong>2：标准错误输出</strong></p>
<h2 id="重定向控制符"><a href="#重定向控制符" class="headerlink" title="重定向控制符"></a>重定向控制符</h2><p><strong>&lt; 文件</strong> ：输入重定向控制符，输入内容从文件获取</p>
<p><strong>> 文件</strong>：输出重定向控制符（覆盖）</p>
<p><strong>>> 文件</strong>：输出重定向控制符（追加）</p>
<h2 id="重定向高级用法"><a href="#重定向高级用法" class="headerlink" title="重定向高级用法"></a>重定向高级用法</h2><ul>
<li>文件描述符[0,1,2] 重定向控制符[&gt;,&lt;,&lt;&lt;] 文件</li>
</ul>
<p>例：重定向标准输出到文件中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> xxx 1&gt;文件</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><strong>符号：</strong><code>&quot;|&quot;</code></p>
<p>用于连接进程，通过管道连接的进程可以同时运行，并且随着数据流在她们之间传递可以自动地进行协调。</p>
<hr>
<h1 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h1><h2 id="文件权限属性"><a href="#文件权限属性" class="headerlink" title="文件权限属性"></a>文件权限属性</h2><p><img src="/Blog/2018/06/07/Linux/Linux总结/文件权限属性.png" alt="文件权限属性"></p>
<p>文件类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-：普通文件</span><br><span class="line">d：目录</span><br><span class="line">l：链接文件</span><br><span class="line">p：管道文件</span><br></pre></td></tr></table></figure>
<p>权限码（rwx）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r = 4	<span class="comment"># 读</span></span><br><span class="line">w = 2	<span class="comment"># 写</span></span><br><span class="line">x = 1	<span class="comment"># 执行</span></span><br><span class="line">- = 0	<span class="comment"># 无权限</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="文件-目录-属性操作"><a href="#文件-目录-属性操作" class="headerlink" title="文件/目录/属性操作"></a>文件/目录/属性操作</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>显示指定目录下的目录和文件</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [选项] 目录名</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a：显示隐藏文件（<span class="string">"."</span>开头）</span><br><span class="line">-l：列出文件详细信息</span><br><span class="line">-S：以文件大小排序</span><br><span class="line">-t：以时间排序</span><br><span class="line">-i：显示索引节点</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">-drwxr-xr-x	1	root	root	969	May	29	17:02	dir1</span><br><span class="line">文件权限:链接数:拥有者:所属组:文件大小(B):修改日期:文件名</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>切换工作目录</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 目录名</span><br></pre></td></tr></table></figure>
<p><strong>参数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ : 用户主目录</span><br><span class="line">. : 当前目录</span><br><span class="line">.. : 父目录</span><br><span class="line">- : 返回上一次目录</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>查看当前工作目录</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建目录</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项] 目录</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-p：确保目录名称存在，不存在则创建一个</span><br><span class="line">-m：在创建目录的同时设置目录的权限</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>删除<strong>空目录</strong></p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p：当子目录被删除后也成为空目录时，也一并删除</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>用于修改文件的时间属性，包括存取时间和更改时间。<strong>若文件不存在，系统会建立一个新的文件</strong> </p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [选项] 文件1 [文件2...]</span><br></pre></td></tr></table></figure>
<p>不加选项的话修改时间记录为当前系统时间</p>
<hr>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p><strong>删除</strong>文件或目录（删除目录要 -r）</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] 文件名或目录名</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r：递归删除目录一下文件</span><br><span class="line">-i：交互模式，删除前逐一询问（interactive）</span><br><span class="line">-f：强制模式，即使属性为只读，也直接删除，无需逐一确认（force）</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p><strong>复制</strong>文件或目录（目录用 -a）</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [选项] 源文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a：复制目录时使用，保留链接、文件属性，且递归复制目录下所有内容，相当于-pdr</span><br><span class="line">-p：复制属性</span><br><span class="line">-d：复制链接的话，只复制链接而非期文件</span><br><span class="line">-r：递归复制目录</span><br><span class="line">-i：覆盖之前询问</span><br><span class="line">-f：覆盖且不询问</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p><strong>移动</strong>或<strong>更名</strong>指定的文件或目录</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [选项] 源文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure>
<p><strong>mv参数设置与运行结果：</strong></p>
<table>
<thead>
<tr>
<th>命令格式</th>
<th>运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>mv  文件名  文件名</td>
<td>将源文件名改为目标文件名</td>
</tr>
<tr>
<td>mv  文件名  目录名</td>
<td>移动文件到目录</td>
</tr>
<tr>
<td>mv  目录名  目录名</td>
<td>目标目录存在，将源目录移动到目标目录<br>目标目录不存在，则改名</td>
</tr>
<tr>
<td>mv  目录名  文件名</td>
<td>错误</td>
</tr>
</tbody>
</table>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-i：交互模式，覆盖询问</span><br><span class="line">-f：强制模式，覆盖不提示</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>从指定目录开始递归查找文件，并可以对其进行操作</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 起始目录 &lt;选项查找条件&gt;</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-name &lt;name&gt;：正则匹配字符串（-iname 忽略大小写）</span><br><span class="line">-<span class="built_in">type</span> &lt;d/c/b/p/f/l/s&gt;：文件类型</span><br><span class="line">-ls：详细列出所找到的文件</span><br><span class="line">-<span class="built_in">exec</span>：执行期间不询问；用&#123;&#125;表示找到的文件，对其进行命令操作，命令末尾必须以 <span class="string">"\;"</span> 结束</span><br><span class="line">-ok：同<span class="built_in">exec</span>，但会询问。</span><br><span class="line">-size &lt;n&gt;：文件大小是n，可用b，c（char），k(kB)表示</span><br><span class="line">对查询条件做逻辑运算：</span><br><span class="line">-a：与</span><br><span class="line">-o：或</span><br><span class="line">！：非</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># find ~ -name &quot;test*&quot; -ls -exec rm &#123;&#125; \;</span><br><span class="line">393291    0 -rw-rw-r--   1 aaron    aaron           0 Jun  8 13:40 /home/aaron/test3</span><br><span class="line">393290    0 -rw-rw-r--   1 aaron    aaron           0 Jun  8 13:40 /home/aaron/test2</span><br><span class="line">393236    0 -rw-rw-r--   1 aaron    aaron           0 Jun  8 13:40 /home/aaron/test1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>为源文件创建一个链接，但不复制源文件</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [选项] 源对象 目的对象</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s：进行软链接</span><br><span class="line">不用-s：进行硬链接</span><br></pre></td></tr></table></figure>
<p><strong>硬链接</strong>：文件的副本（别名），同时两者存在连接关系，<strong>修改其中一个另一个也会一同被修改，删除一个，另一个不受影响</strong>。两者在<strong>硬盘上只有一份数据</strong>，只存在于同一个文件系统中。</p>
<p><strong>软链接</strong>：<strong>一个快捷方式</strong>，是一个内容指向另一个文件位置的特殊文件。删了源文件就没用了。可以跨越文件系统。</p>
<p>个人理解：</p>
<p><img src="/Blog/2018/06/07/Linux/Linux总结/硬链接和软链接图示.png" alt="硬链接和软链接图示"></p>
<hr>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>改变目录或文件的权限</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [选项] &lt;mode&gt; &lt;文件名或目录&gt;</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R：递归对目录下的所有子文件与子目录进行相同的权限变更</span><br></pre></td></tr></table></figure>
<p><strong>权限修改：</strong></p>
<ol>
<li>用数字修改</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4:r</span><br><span class="line">2:w</span><br><span class="line">1:x</span><br><span class="line">例如775就是rwxrwxr-x</span><br><span class="line">示例：chmod 775 file.txt</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用指令修改权限</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u：所有者user</span><br><span class="line">g：组group</span><br><span class="line">o：其他other</span><br><span class="line">+：增加权限</span><br><span class="line">-：取消权限</span><br><span class="line">示例：chmod g+w,o+w,o-r file.txt</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>改变指定目录或文件(用-R)的所属用户、所属组</p>
<p><strong>权限：</strong>root</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [选项] 用户名[：组名] 文件或目录名</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R：递归对子文件或目录操作</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>改变文件/目录的所属组</p>
<p><strong>权限：</strong>所有使用者</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [选项] 组名 文件或目录名</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R：递归对子文件或目录操作</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="文字显示-文件操作"><a href="#文字显示-文件操作" class="headerlink" title="文字显示/文件操作"></a>文字显示/文件操作</h2><hr>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>显示文件内容</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [选项] 文件名</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-n：显示行号</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>分页显示文件内容</p>
<p>b上一页，空格下一页，回车下一行，</p>
<p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [选项参数] 文件名</span><br></pre></td></tr></table></figure>
<p><strong>选项参数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&lt;数字&gt;：指定每屏显示的行数</span><br><span class="line">+&lt;数字&gt;：从指定数字的行开始显示</span><br><span class="line">-c：不进行滚屏操作。每次刷新这个屏幕</span><br><span class="line">-s：将多个空行压缩成一行</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>分页显示文件内容，与more十分相似，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。more读的时候会全部加载，而less部分加载，所以less有时候会更快。</p>
<p>PageUp键上翻页，PageDown向下翻。Q键退出。 </p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [选项] 文件</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n：显示行号</span><br><span class="line">-s：多个空行压缩成一行</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>显示文件前N行内容或前N个字节，默认为前10行</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [选项] 文件</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-n&lt;数字&gt; ：显示前N行</span><br><span class="line">-c&lt;数字&gt; ：显示前N个字节</span><br><span class="line">-v：同时显示文件名</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>显示文件后N行内容或前N个字节，默认为前10行</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [选项] 文件</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-n&lt;数字&gt; ：显示后N行</span><br><span class="line">-c&lt;数字&gt; ：显示后N个字节</span><br><span class="line">-v：同时显示文件名</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>从文件中过滤或提取特定内容并显示</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut [选项] 文件名</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-d&lt;分隔符&gt;：指定分隔符号（可用引号包起来）</span><br><span class="line">-f&lt;list&gt;：指定提取的列（可以是-f1，也可以是 -f2-5，-f2,4 这样的范围）</span><br><span class="line">-c&lt;list&gt;：仅显示行中指定范围的字符</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost text]<span class="comment"># cut -f2,4 -d";" test.txt </span></span><br><span class="line">Name Mark</span><br><span class="line">tom 69</span><br><span class="line">jack 71</span><br><span class="line">alex 68</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>（wordcount）统计一个文件多少字/字节/行</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [选项] 文件名</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c：只显示字节Bytes数；（char（字节)）</span><br><span class="line">-l：只显示列数；（line）</span><br><span class="line">-w：只显示字数。（word）</span><br><span class="line">无参数默认统计行、字、字节数</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>对输出的内容进行排序（不改变文件）</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [选项] 文件名</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r：反向排序(reverse)</span><br><span class="line">-n：数字排序（number）</span><br><span class="line">-f：不区分大小写</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>显示文字</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> [选项] 字符串</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n：最后不换行</span><br><span class="line">-e：输出一个空行</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p>日历显示</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal [选项] [[月] 年]</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无参数则本月日历</span><br><span class="line">-y：显示今年日历</span><br><span class="line">-m：周一为第一天</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>显示系统时间 或 设定系统时间</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date [选项] [+format]</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-d &lt;dateStr&gt;：显示 字符串所指的日期与时间。字符串须加双引号；</span><br><span class="line">-s &lt;dateStr&gt;：设置 字符串表示的日期与时间。字符串须加双引号；</span><br></pre></td></tr></table></figure>
<p><strong>日期格式字符串列表</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">%H 小时，24小时制（00~23）</span><br><span class="line">%I 小时，12小时制（01~12）</span><br><span class="line">%k 小时，24小时制（0~23）</span><br><span class="line">%l 小时，12小时制（1~12）</span><br><span class="line">%M 分钟（00~59）</span><br><span class="line">%p 显示出AM或PM</span><br><span class="line">%r 显示时间，12小时制（hh:mm:ss %p）</span><br><span class="line">%s 从1970年1月1日00:00:00到目前经历的秒数</span><br><span class="line">%S 显示秒（00~59）</span><br><span class="line">%T 显示时间，24小时制（hh:mm:ss）</span><br><span class="line">%X 显示时间的格式（%H:%M:%S）</span><br><span class="line">%Z 显示时区，日期域（CST）</span><br><span class="line">%a 星期的简称（Sun~Sat）</span><br><span class="line">%A 星期的全称（Sunday~Saturday）</span><br><span class="line">%b 月的简称（Jan~Dec）</span><br><span class="line">%B 月的全称（January~December）</span><br><span class="line">%c 日期和时间（Tue Nov 20 14:12:58 2012）</span><br><span class="line">%d 一个月的第几天（01~31）</span><br><span class="line">%x,%D 日期（mm/dd/yy）</span><br><span class="line">%j 一年的第几天（001~366）</span><br><span class="line">%m 月份（01~12）</span><br><span class="line">%w 一个星期的第几天（0代表星期天）</span><br><span class="line">%W 一年的第几个星期（00~53，星期一为第一天）</span><br><span class="line">%y 年的最后两个数字（00-99）</span><br><span class="line">%Y 完整年份(0000-9999)</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<p>格式化输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date +<span class="string">"%Y-%m-%d"</span></span><br><span class="line">2009-12-07</span><br></pre></td></tr></table></figure>
<p>设置时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date -s 20120523               //设置成20120523，这样会把具体时间设置成空00:00:00</span><br><span class="line">date -s 01:01:01               //设置具体时间，不会对日期做更改</span><br><span class="line">date -s <span class="string">"01:01:01 2012-05-23"</span>  //这样可以设置全部时间</span><br></pre></td></tr></table></figure>
<hr>
<p>###grep</p>
<p>行搜索工具</p>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v	<span class="comment"># 不包含</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>对标准输入的字符进行替换、压缩和删除 </p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr [选项] 字符串1 字符串2</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-d	<span class="comment"># 删除字符1中出现的输入字符</span></span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tr <span class="string">'a-z'</span> <span class="string">'A-Z'</span> &lt; works.txt</span><br><span class="line">LINUX</span><br><span class="line">UNIX</span><br><span class="line">MAC OS</span><br><span class="line"></span><br><span class="line">$ cat works.txt | tr <span class="string">"abc"</span> <span class="string">"xyz"</span></span><br><span class="line">Linux</span><br><span class="line">Unix</span><br><span class="line">Mxz OS</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] 目录或文件</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-zcvf	<span class="comment"># 压缩</span></span><br><span class="line">-zxvf	<span class="comment"># 解压</span></span><br><span class="line">-z	<span class="comment"># 用gzip压缩/解压(.gz)</span></span><br><span class="line">-c	<span class="comment"># 打包（create）</span></span><br><span class="line">-x	<span class="comment"># 解压</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip [选项] 文件名</span><br></pre></td></tr></table></figure>
<p><strong>压缩：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip File</span><br></pre></td></tr></table></figure>
<p><strong>解压：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d file.gz</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><p>解压zip文件</p>
<p><strong>解压：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -x File.zip</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="联机、帮助指令"><a href="#联机、帮助指令" class="headerlink" title="联机、帮助指令"></a>联机、帮助指令</h2><p>获取命令的帮助</p>
<h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man [选项] 命令或配置文件</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ls</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info &lt;命令名&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> [命令名]</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="–help参数"><a href="#–help参数" class="headerlink" title="–help参数"></a>–help参数</h3><p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;命令&gt; --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="文本格式转换"><a href="#文本格式转换" class="headerlink" title="文本格式转换"></a>文本格式转换</h2><h3 id="unix2dos-dos2unix"><a href="#unix2dos-dos2unix" class="headerlink" title="unix2dos, dos2unix"></a>unix2dos, dos2unix</h3><table>
<thead>
<tr>
<th>系统</th>
<th>换行符</th>
</tr>
</thead>
<tbody>
<tr>
<td>windows</td>
<td>^M^J<br>(回车换行)</td>
</tr>
<tr>
<td>Linux</td>
<td>^J<br>(换行)</td>
</tr>
</tbody>
</table>
<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="磁盘设备描述"><a href="#磁盘设备描述" class="headerlink" title="磁盘设备描述"></a>磁盘设备描述</h2><p>前两个字母：设备类型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hd	<span class="comment"># IDE硬盘</span></span><br><span class="line">sd	<span class="comment"># SCSI硬盘(U盘)</span></span><br></pre></td></tr></table></figure>
<p>第三个字母：设备编号</p>
<p>数字：分区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sda2：第1块SCSI硬盘的第1个分区</span><br><span class="line">sdb1：第2块SCSI硬盘的第1个分区</span><br></pre></td></tr></table></figure>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ol>
<li><p><strong>FAT</strong></p>
<p>早期<strong>Windows</strong>的文件系统</p>
</li>
<li><p><strong>NTFS</strong></p>
<p>目前<strong>Windows</strong>普遍的文件系统</p>
</li>
<li><p><strong>Ext</strong></p>
<p><strong>Linux</strong>引入的可扩展文件系统</p>
</li>
<li><p><strong>VFS</strong></p>
<p><strong>Linux的虚拟文件系统</strong>，（接口层），屏蔽不同的文件系统，实现对各种文件系统的支持。</p>
</li>
</ol>
<h2 id="fdisk-l"><a href="#fdisk-l" class="headerlink" title="fdisk -l"></a>fdisk -l</h2><p>查看本机硬盘及分区情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x0008de3e</span><br><span class="line"></span><br><span class="line">Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048    83884031    41940992   83  Linux</span><br></pre></td></tr></table></figure>
<h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p>挂载设备</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [选项] 设备名 挂载点</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-t &lt;文件系统类型&gt;</span><br><span class="line">-o &lt;选项&gt; 如ro, rw, auto, iocharset等</span><br></pre></td></tr></table></figure>
<h2 id="挂载过程"><a href="#挂载过程" class="headerlink" title="挂载过程"></a>挂载过程</h2><ol>
<li><strong>获取设备名</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">查看设备名</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>建立挂载点目录</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/目录名</span><br><span class="line">建立mnt目录下的挂载点</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>mount 命令挂载</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount 设备名 挂载点</span><br></pre></td></tr></table></figure>
<h2 id="umount-卸载设备命令"><a href="#umount-卸载设备命令" class="headerlink" title="umount 卸载设备命令"></a>umount 卸载设备命令</h2><p>卸载挂载的设备</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount 挂载点/设备名</span><br></pre></td></tr></table></figure>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="mkfs"><a href="#mkfs" class="headerlink" title="mkfs"></a>mkfs</h3><p>格式化硬盘分区（创建文件系统）(mkFileSystem)</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t 文件系统 设备名</span><br></pre></td></tr></table></figure>
<h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>查看磁盘使用情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [选项]</span><br></pre></td></tr></table></figure>
<h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>统计目录或文件所占磁盘空间大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [选项] 目录名</span><br></pre></td></tr></table></figure>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><p><strong>交互进程：</strong>由Shell启动的进程</p>
<p><strong>守护进程：</strong>在后台运行的进程</p>
<p><strong>批处理进程：</strong>管理进程的序列</p>
<p>进程的属性：PID, PPID(父进程ID), UID, GID, 状态, 优先级, 资源占用</p>
<p>杀终止父进程会连带终止子进程</p>
<p>系统的第一个进程init(PID=1)（所有进程的父进程）</p>
<h2 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h2><h3 id="手工启动线程"><a href="#手工启动线程" class="headerlink" title="手工启动线程"></a>手工启动线程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxx &amp;	<span class="comment"># 后台运行程序加"&amp;"</span></span><br></pre></td></tr></table></figure>
<h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><p>指定时间执行命令序列</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at [选项] TIME</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>显示瞬间进程动态（另外，top指令可以动态监控进程）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [选项]</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e	<span class="comment"># 显示所有进程</span></span><br><span class="line">-a	<span class="comment"># 显示所有进程，包括其他用户的进程</span></span><br><span class="line">-x	<span class="comment"># 显示所有控制终端的进程</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><p>以树状结构显示系统中的所有进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree [选项] [PID|User]</span><br></pre></td></tr></table></figure>
<p>可以指定显示指定PID的信息 或 指定User的进程信息</p>
<hr>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>结束进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-s signal] PID</span><br><span class="line"><span class="built_in">kill</span> -l	<span class="comment"># 列出所有可用的信号</span></span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-s signal	<span class="comment"># 指定信号。重启(1)，强制杀死(9)，结束(10)</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><p>查看后台进程</p>
<h3 id="ctrl-Z"><a href="#ctrl-Z" class="headerlink" title="ctrl+Z"></a>ctrl+Z</h3><p>挂起当前线程</p>
<h3 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h3><p>前台执行进程</p>
<p><code>fg PID</code></p>
<h3 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h3><p>后台执行进程</p>
<hr>
<h2 id="crontab-周期性执行程序"><a href="#crontab-周期性执行程序" class="headerlink" title="crontab 周期性执行程序"></a>crontab 周期性执行程序</h2><p>周期性执行程序</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] &#123;-l | -r | -e&#125;</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e	<span class="comment"># 编辑时程表</span></span><br><span class="line">-r	<span class="comment"># 删除目前时程表</span></span><br><span class="line">-l	<span class="comment"># 列出目前时程表</span></span><br></pre></td></tr></table></figure>
<h3 id="crontab文件编写"><a href="#crontab文件编写" class="headerlink" title="crontab文件编写"></a>crontab文件编写</h3><p><strong>格式：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1 f2 f3 f4 f5 program</span><br><span class="line">m, h, d-M, M-y, d-W program</span><br><span class="line">分钟 小时 月中的天 月 周中的天 program</span><br></pre></td></tr></table></figure>
<p><strong>特殊格式：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*		<span class="comment"># 每个时间点都要执行</span></span><br><span class="line">a-b		<span class="comment"># a-b时间点内都要执行</span></span><br><span class="line">*/n		<span class="comment"># 每n个时间点都要执行1次</span></span><br><span class="line">a,b,c	<span class="comment"># 第a,b,c,个时间点要执行</span></span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每个月每天的12点都要执行wall hello</span><br><span class="line">0 12 * * * wall hello</span><br><span class="line">在12月内，每天早上6点到12点中的每3个小时，每个20分钟执行一次command</span><br><span class="line">*/20 6-12/3 * 12 * command</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="系统监视"><a href="#系统监视" class="headerlink" title="系统监视"></a>系统监视</h1><h2 id="系统监视指令"><a href="#系统监视指令" class="headerlink" title="系统监视指令"></a>系统监视指令</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>动态监视进程和信息指令（进化版的ps）</p>
<p><strong>操作：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">space	<span class="comment"># 刷新</span></span><br><span class="line">h		<span class="comment"># 帮助</span></span><br><span class="line">k		<span class="comment"># 杀死某进程</span></span><br><span class="line">u		<span class="comment"># 显示指定用户</span></span><br><span class="line">P		<span class="comment"># 按CPU使用情况排序</span></span><br><span class="line">q		<span class="comment"># 退出</span></span><br></pre></td></tr></table></figure>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>内存查看命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [选项]</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-b	<span class="comment"># B字节单位显示</span></span><br><span class="line">-k	<span class="comment"># KB单位</span></span><br><span class="line">-m	<span class="comment"># MB单位</span></span><br></pre></td></tr></table></figure>
<h2 id="日志监视"><a href="#日志监视" class="headerlink" title="日志监视"></a>日志监视</h2><p>日志存放于/var/log目录下</p>
<h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p><strong>1. BIOS初始化</strong></p>
<p>加载和引导设备，启动操作系统</p>
<p><strong>2. 内核初始化</strong></p>
<ol>
<li>硬件设备检测</li>
<li>设备驱动初始化</li>
<li>只读挂载文件系统</li>
<li>启动第一个进程init（PID=1，所有进程的父进程，失去父进程的子进程都以init作为父进程）</li>
</ol>
<p><strong>3. 确定系统运行级别</strong></p>
<p>init读取配置文件<strong>/etc/inittab</strong></p>
<p>修改系统默认运行级别：修改其中数字</p>
<p><code>id:5:initdefault</code></p>
<p><strong>4. 运行初始化脚本</strong></p>
<p><strong>5. 运行用户自定义脚本</strong></p>
<p>修改/etc/rc.d/rc.local</p>
<p><strong>6. 激活控制台</strong></p>
<p><strong>7. 启动界面</strong></p>
<h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><h2 id="网络设置文件"><a href="#网络设置文件" class="headerlink" title="网络设置文件"></a>网络设置文件</h2><table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/hosts</td>
<td>域名或主机名与IP的映射文件。本机查询DNS</td>
</tr>
<tr>
<td>/etc/sysconfig/network-scripts/ifcfg-ethN</td>
<td>ethN网卡的配置信息</td>
</tr>
<tr>
<td>/etc/sysconfig/network</td>
<td>最基本的网络配置信息，系统启动时读取</td>
</tr>
<tr>
<td>/etc/resolv.conf</td>
<td>域名服务器配置文件</td>
</tr>
<tr>
<td>/etc/host.conf</td>
<td>域名解析的配置文件，指定如何解析</td>
</tr>
<tr>
<td>/etc/services</td>
<td>网络服务和端口的映射文件，设定主机不同端口号的网络服务</td>
</tr>
<tr>
<td>/etc/protocols</td>
<td>描述网络协议及其对应协议号</td>
</tr>
</tbody>
</table>
<h2 id="网络管理命令"><a href="#网络管理命令" class="headerlink" title="网络管理命令"></a>网络管理命令</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>查看或配置网卡状态</p>
<p><strong>查看状态：</strong><code>ifconfig</code></p>
<p><strong>查看单独显卡状态：</strong><code>ifconfig eth0</code></p>
<p><strong>停止</strong>显卡：<code>down</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure>
<p><strong>激活</strong>显卡： <code>up</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 dp</span><br></pre></td></tr></table></figure>
<p><strong>设置</strong>设备<strong>IP地址和子网掩码</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig &lt;设备名&gt; &lt;IP&gt; netmask &lt;掩码&gt;</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong><code>ifconfig eth0 192.168.0.17 netmask 255.255.255.0</code></p>
<p>以上修改都是临时性的</p>
<hr>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>测试网络是否联通。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [选项] 地址</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>显示数据包到主机之间的路径</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute [选项] 地址</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p>显示路由表 / 添加删除路由记录</p>
<p>显示路由表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route</span><br></pre></td></tr></table></figure>
<p>添加|删除网关</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route &lt;add|del&gt; default gw 网关IP</span><br></pre></td></tr></table></figure>
<p>添加 | 删除路由记录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route &lt;add|del-net&gt; 网络号 netmask 掩码 dev 设备名</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>显示网络状态（端口开放情况）</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [选项]</span><br></pre></td></tr></table></figure>
<p><strong>选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i	<span class="comment"># 列出每个显卡</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="网络服务管理"><a href="#网络服务管理" class="headerlink" title="网络服务管理"></a>网络服务管理</h2><h3 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h3><p>检查和设置系统的各种服务</p>
<p>添加/删除指定的服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add|del 服务名</span><br></pre></td></tr></table></figure>
<p>显示所有或指定的服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list [服务名]</span><br></pre></td></tr></table></figure>
<p>检查指定服务的状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig 服务名</span><br></pre></td></tr></table></figure>
<p>改变服务运行级别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig [--level 运行级别(3/4/5)] 服务名 状态(on/off/reset)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>对系统服务管理（启动、停止、重启、查看状态）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service 服务名 [start|stop|restart|status]</span><br></pre></td></tr></table></figure>
<hr>
<p>chkconfig和service的区别：前者重启后仍然生效，后者不然</p>
<hr>
<h2 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h2><ol>
<li><strong>独立守护进程工作模式：</strong>一个守护进程响应一个特定的端口的服务或连接（每个服务都对应一个守护进程，会导致资源浪费。）(也叫stand-alone模式)</li>
<li><strong>基于xinetd的工作模式：</strong>xinetd进程同时监听多个端口，在接收请求时根据端口号来启动不同的服务进程处理请求。（流量小开销小，流量大时由于频繁启动服务进程导致性能下降）</li>
</ol>
<h3 id="Telnet服务"><a href="#Telnet服务" class="headerlink" title="Telnet服务"></a>Telnet服务</h3><p>远程登陆应用。基于xinetd的服务。</p>
<p><strong>使用：</strong></p>
<ol>
<li>安装krb5-telnet</li>
<li>编辑/etc/xinetd.d/krb5-telnet配置文件（在此之前可能要改xinetd配置文件/etc/xinetd.conf文件），编辑/etc/securetty文件</li>
<li>重启服务 <code>service xinetd restart</code></li>
</ol>
<p>需要用非root普通用户登陆</p>
<p><strong>停止：</strong></p>
<p>关闭xinetd服务（telnet受xinetd管理，所以关闭xinetd即可）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service xinetd stop</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="FTP服务"><a href="#FTP服务" class="headerlink" title="FTP服务"></a>FTP服务</h3><p>FTP文件传输协议，支持standalone模式和xinetd模式。</p>
<p><strong>配置文件：</strong></p>
<ol>
<li>/etc/vsftpd/vsftpd.conf：主配置文件</li>
<li>/etc/vsftpd.ftpusers：禁用用户列表</li>
<li>/etc/vsftpd.user_list：</li>
</ol>
<p><strong>启动vsFTPd</strong></p>
<p><code>service vsftpd [start | stop | restart]</code></p>
<p><strong>需要关闭防火墙</strong></p>
<p><strong>使用操作：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lcd	<span class="comment"># 切换本机目录</span></span><br><span class="line">get &lt;filename&gt;	<span class="comment"># 从FTP下载到本地</span></span><br><span class="line">put &lt;filename&gt;	<span class="comment"># 从本地上传到FTP</span></span><br><span class="line">close	<span class="comment"># 关闭ftp会话</span></span><br><span class="line">open	<span class="comment"># 连接ftp站点</span></span><br><span class="line">quit	<span class="comment"># 断开连接并退出</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="www"><a href="#www" class="headerlink" title="www"></a>www</h3><p>web服务，用的是httpd服务</p>
<p>启动httpd</p>
<p><code>service httpd [start | stop | restart]</code></p>
<p><strong>httpd的配置文件：</strong></p>
<p><strong>/etc/httpd/conf/http.conf</strong></p>
<hr>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uncleaaron.github.io/Blog/Blog/2018/06/06/Java并发编程艺术/第5章-Java中的锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron.H">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StormAaron的技术站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Blog/2018/06/06/Java并发编程艺术/第5章-Java中的锁/" itemprop="url">第5章 Java中的锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T15:03:00+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Java并发编程艺术/" itemprop="url" rel="index">
                    <span itemprop="name">Java并发编程艺术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uncleaaron.github.io/Blog/Blog/2018/06/01/Java并发编程艺术/第4章-Java并发编程基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron.H">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StormAaron的技术站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Blog/2018/06/01/Java并发编程艺术/第4章-Java并发编程基础/" itemprop="url">第4章 Java并发编程基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-01T20:46:25+08:00">
                2018-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Java并发编程艺术/" itemprop="url" rel="index">
                    <span itemprop="name">Java并发编程艺术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第4章-Java并发编程基础"><a href="#第4章-Java并发编程基础" class="headerlink" title="第4章 Java并发编程基础"></a>第4章 Java并发编程基础</h1><h2 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h2><p>线程是现代操作系统调度的最小单位，拥有各自的计数器、堆栈和局部变量等属性，能够访问共享的内存变量。</p>
<p>实际上Java程序天生就是多线程程序，执行main()会启用一个主线程，同时还会启用其他的一些辅助线程。</p>
<h3 id="1-1-线程优先级-priority"><a href="#1-1-线程优先级-priority" class="headerlink" title="1.1. 线程优先级(priority)"></a>1.1. 线程优先级(priority)</h3><p>现代操作系统基本采用时分调度线程，会分出多个时间片，一个线程会分配到若干时间片，时间片用完了就会发生线程调度，等待下次分配。</p>
<p><strong>线程优先级决定分配到的时间片和处理器资源多少的线程属性。优先级高的线程分配的时间片数量更多。</strong></p>
<p>Java线程中使用一个整型的变量priority来控制优先级，范围是1~10，线程构建的时候使用setPriority(int)修改优先级，优先级默认是5。</p>
<p>设置线程优先级的原则：</p>
<ul>
<li>针对频繁阻塞（休眠或I/O操作）的线程需要设置较高优先级。</li>
<li>偏重计算（需要较多CPU时间）的线程设置较低优先级，从而避免处理器被独占。</li>
</ul>
<p>但实际上有些JVM或者操作系统会无视Priority的设定，所以<strong>线程优先级不能作为程序正确性的依赖</strong>。</p>
<h3 id="1-2-线程的状态"><a href="#1-2-线程的状态" class="headerlink" title="1.2. 线程的状态"></a>1.2. 线程的状态</h3><p><strong>表4-1 Java线程的状态（6种）</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">状态名称</th>
<th style="text-align:center">状态</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>NEW</strong></td>
<td style="text-align:center"><strong>初始态</strong></td>
<td style="text-align:left">线程被构建，但是还没调用start()方法</td>
</tr>
<tr>
<td style="text-align:center"><strong>RUNNABLE</strong></td>
<td style="text-align:center"><strong>运行态</strong></td>
<td style="text-align:left">Java线程将操作系统中的就绪态和运行态统称为“运行中”</td>
</tr>
<tr>
<td style="text-align:center"><strong>BLOCKED</strong></td>
<td style="text-align:center"><strong>阻塞态</strong></td>
<td style="text-align:left">线程阻塞于锁（调用同步方法时没获取到锁）（注意：阻塞在current包的Lock接口中的线程是等待态而不是阻塞态）</td>
</tr>
<tr>
<td style="text-align:center"><strong>WAITING</strong></td>
<td style="text-align:center"><strong>等待态</strong></td>
<td style="text-align:left">线程wait()后，当前线程需要等待其他线程做出一些特定动作（通知或中断）才能返回到运行态</td>
</tr>
<tr>
<td style="text-align:center"><strong>TIME_WAITING</strong></td>
<td style="text-align:center"><strong>超时等待态</strong></td>
<td style="text-align:left">可以在指定时间内自行返回的特殊WAITING<br>（其他线程在规定时间内未回复的话则自行返回进行下一步操作）</td>
</tr>
<tr>
<td style="text-align:center"><strong>TERMINGATED</strong></td>
<td style="text-align:center"><strong>终止态</strong></td>
<td style="text-align:left">表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<p><img src="/Blog/2018/06/01/Java并发编程艺术/第4章-Java并发编程基础/图4-1 Java线程状态变迁.jpg" alt="图4-1 Java线程状态变迁"></p>
<h3 id="1-3-Daemon线程-守护线程"><a href="#1-3-Daemon线程-守护线程" class="headerlink" title="1.3. Daemon线程(守护线程)"></a>1.3. Daemon线程(守护线程)</h3><p>Daemon线程是一种支持型线程，主要被用作程序的后台调度和支持性工作。</p>
<p>使用threadA.setDaemon(true)将线程设置为Daemon线程（Daemon需要在启动线程前设置）</p>
<ul>
<li><strong>当JVM中不存在非Daemon线程的时候，JVM会退出。</strong>此时不一定会执行Daemon线程中的finally块，因此不能依靠Daemon线程中的finally来确保逻辑正确。</li>
</ul>
<h2 id="二、启动和终止线程"><a href="#二、启动和终止线程" class="headerlink" title="二、启动和终止线程"></a>二、启动和终止线程</h2><h3 id="2-1-构造线程"><a href="#2-1-构造线程" class="headerlink" title="2.1. 构造线程"></a>2.1. 构造线程</h3><p><strong>运行线程之前首先要构造一个线程对象，并且初始化线程属性</strong>。如线程所属的线程组、线程优先级、是否Daemon线程等信息。</p>
<p>在Thread.init()的源代码中，新构造的线程对象是由其parent线程来进行空间分配的，而<strong>child线程继承了parent的属性</strong>是否为Daemon、优先级和加载资源的contextClassLoader以及科技城ThreadLocal，同时分配一个唯一的线程ID。</p>
<h3 id="2-2-启动线程"><a href="#2-2-启动线程" class="headerlink" title="2.2. 启动线程"></a>2.2. 启动线程</h3><ul>
<li>调用<strong>start()</strong>方法即可启动。</li>
</ul>
<p>含义：当前线程（parent线程）同步告知JVM，只要线程规划器空闲，应立即启动调用start()方法的线程。</p>
<h3 id="2-3-中断（interrupt）"><a href="#2-3-中断（interrupt）" class="headerlink" title="2.3. 中断（interrupt）"></a>2.3. 中断（interrupt）</h3><p><strong>中断可以理解为线程的一个标志位属性</strong>。它表示一个运行中的线程是否被其他的线程<strong><u>通知</u></strong>进行了中断操作（不不会终止线程）。</p>
<p><strong>interrupt()</strong>：其他线程通过调用该线程的interrupt()方法对其进行中断操作。</p>
<p><strong>isInterrupted()</strong>：线程通过检查自身是否被中断来响应，通过调用isInterrupted() 来判断是否被中断。</p>
<p><strong>Thread.interrupted()</strong>：复位当前线程的中断标志位（重置为false）。</p>
<p>如果线程已经处于结束态，则即使该线程被中断过，其中断标志位依旧是false。</p>
<p><strong>InterruptedException</strong>：当线程处于阻塞状态（因被调用了wait()，join()，sleep()而进入阻塞）时，调用interrupt() ，因为没有占用CPU运行的线程是不可能给自己中断状态置位的，JVM会先清楚中断标志位，然后产生InterruptedException异常（不会终止线程）。（可以利用接收这个异常终止阻塞的线程）</p>
<h3 id="2-4-安全地终止线程"><a href="#2-4-安全地终止线程" class="headerlink" title="2.4. 安全地终止线程"></a>2.4. 安全地终止线程</h3><h4 id="2-4-1-终止处于运行状态的线程"><a href="#2-4-1-终止处于运行状态的线程" class="headerlink" title="2.4.1. 终止处于运行状态的线程"></a>2.4.1. 终止处于运行状态的线程</h4><ul>
<li><p>利用中断状态标志位，做中断操作来取消或停止任务。</p>
</li>
<li><p>使用boolean变量控制是否需要停止任务并终止该线程</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="title">implments</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">    privatge <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;	<span class="comment">//volatile的boolean控制标志</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// boolean变量为真时继续执行</span></span><br><span class="line">        <span class="comment">// 线程没被中断(Isterrupted()返回false)之前继续执行</span></span><br><span class="line">        <span class="comment">// 当外部执行cancel()或interrupt()时终止线程</span></span><br><span class="line">        <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted() ) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// boolean取消操作，供外部终止线程使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        on = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-终止处于“阻塞状态”的线程"><a href="#2-4-2-终止处于“阻塞状态”的线程" class="headerlink" title="2.4.2. 终止处于“阻塞状态”的线程"></a>2.4.2. 终止处于“阻塞状态”的线程</h4><ul>
<li><p>同样用interrupt()：</p>
<p>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行任务...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">        <span class="comment">// 由于产生InterruptedException异常，退出while(true)循环，线程终止！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-废弃的suspend-、resume-、和stop"><a href="#2-5-废弃的suspend-、resume-、和stop" class="headerlink" title="2.5. 废弃的suspend()、resume()、和stop()"></a>2.5. 废弃的suspend()、resume()、和stop()</h3><p>suspend：暂停</p>
<p>resume：恢复</p>
<p>stop：终止</p>
<p>由于强制操作导致的资源不完全释放的副作用（死锁等），所以废弃。建议用回以上的等待/通知的机制替代。</p>
<h2 id="三、线程间通信"><a href="#三、线程间通信" class="headerlink" title="三、线程间通信"></a>三、线程间通信</h2><p>让线程之间能后互相配合的完成工作。</p>
<h3 id="3-1-volatile和synchronized关键字"><a href="#3-1-volatile和synchronized关键字" class="headerlink" title="3.1. volatile和synchronized关键字"></a>3.1. volatile和synchronized关键字</h3><p>在程序执行过程中，每个线程可以拥有变量的拷贝，而且看到的不一定是最新的变量值，这时候就需要volatile和synchronized关键字。</p>
<p>volatile可以告知程序任何对该变量的访问必须要从共享内存中获取，并且其修改必须同步刷新到共享内存，以保证该变量在线程之间的可见性。</p>
<p>synchronized确保同一时刻只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。</p>
<p>每个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进去同步块或者同步方法，没有获取到监视器的线程将会被阻塞在入口，进入BLOCKED状态和同步队列（释放操作会唤醒同步队列中的线程，使其重新尝试获取监视器）。</p>
<h2 id="3-2-等待-通知机制"><a href="#3-2-等待-通知机制" class="headerlink" title="3.2.等待/通知机制"></a>3.2.等待/通知机制</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uncleaaron.github.io/Blog/Blog/2018/05/29/Java并发编程艺术/第3章-Java内存模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron.H">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StormAaron的技术站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Blog/2018/05/29/Java并发编程艺术/第3章-Java内存模型/" itemprop="url">第3章 Java内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-29T20:46:25+08:00">
                2018-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Java并发编程艺术/" itemprop="url" rel="index">
                    <span itemprop="name">Java并发编程艺术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第3章-Java内存模型"><a href="#第3章-Java内存模型" class="headerlink" title="第3章 Java内存模型"></a>第3章 Java内存模型</h1><p>内存模型</p>
<p>内存模型中的顺序一致性，重排序以及顺序一致性内存模型</p>
<p>同步原语：synchronized，volatile，final</p>
<h2 id="一、Java内存模型的基础"><a href="#一、Java内存模型的基础" class="headerlink" title="一、Java内存模型的基础"></a>一、Java内存模型的基础</h2><h4 id="1-1-并发编程模型的两个关键问题（通信、同步）："><a href="#1-1-并发编程模型的两个关键问题（通信、同步）：" class="headerlink" title="1.1. 并发编程模型的两个关键问题（通信、同步）："></a>1.1. 并发编程模型的两个关键问题（通信、同步）：</h4><ul>
<li>线程之间如何<strong>通信</strong></li>
<li>线程之间如何<strong>同步</strong></li>
</ul>
<p>线程之间<strong>通信</strong>机制有两种：共享内存、消息传递</p>
<p><strong>同步</strong>：<strong>程序中用于控制不同线程间操作发生相对顺序的机制</strong>。</p>
<p>两种并发模型：</p>
<ul>
<li><p><strong>共享内存</strong>：（Java采用该并发模型）</p>
<p>通信：线程之间共享程序的公共状态，通过写-读内存中的公共状态进行<u>隐式</u>通信。</p>
<p>同步：<u>显式</u>进行，程序员必须<u>显式指定</u>某个方法或某段代码需要在线程之间互斥执行。</p>
</li>
<li><p><strong>消息传递</strong>：</p>
<p>通信：显式，线程之间没有公共状态，线程之间必须通过发送消息来<u>显式</u>通信。</p>
<p>同步：隐式，由于消息发送必须先于接收，所以同步是隐式进行的。</p>
</li>
</ul>
<p><u>Java采用的是<strong>共享内存</strong>模型</u></p>
<h3 id="1-2-Java内存模型的抽象结构"><a href="#1-2-Java内存模型的抽象结构" class="headerlink" title="1.2. Java内存模型的抽象结构"></a>1.2. Java内存模型的抽象结构</h3><p><img src="/Blog/2018/05/29/Java并发编程艺术/第3章-Java内存模型/图3-1 Java内存模型的抽象结构示意图.jpg" alt="Java内存模型的抽象结构示意图"></p>
<p>Java线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入合适对另一个线程可见。</p>
<p>抽象角度看：</p>
<p>线程之间的<strong>共享变量存储在主内存</strong>（Main Memory）；每个<strong>线程都有一个私有的本地内存</strong>（抽象概念，不真实存在）；<strong>本地内存中存储了该线程以读/写共享变量的副本</strong>。</p>
<p>A–&gt;B的通信步骤：</p>
<ol>
<li>线程A把本地内存A中<strong>更新过的共享变量刷新到主内存</strong>中。</li>
<li>线程B<strong>到主内存中读取</strong>线程A之前已更新过的共享变量。</li>
</ol>
<p><strong>实质</strong>：线程A在向线程B发消息，而且<strong>必须经过主内存</strong>。</p>
<p><u>JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</u></p>
<h3 id="1-3-从源代码到指令序列的重排序"><a href="#1-3-从源代码到指令序列的重排序" class="headerlink" title="1.3. 从源代码到指令序列的重排序"></a>1.3. 从源代码到指令序列的重排序</h3><p>为了提高执行程序的性能，编译器和处理器常常会对指令做重排序(3种)。</p>
<div id="flowchart-0" class="flow-chart"></div>

<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，重新安排语句执行顺序。</li>
<li>指令级并行的重排序。处理器采用指令级并行技术将多条指令重叠执行。（如无数据依赖可改变执行顺序）</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去是在乱序执行。</li>
</ol>
<p>每个处理器写缓冲区仅对自己可见，这会导致处理器执行内存操作的顺序会与内存实际的操作执行顺序不一致。因此现代的处理器都会允许对写-读操作进行重排序。</p>
<p>JMM通过禁止某些编译器重排序（插入内存屏障）和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h3 id="1-4-happens-before"><a href="#1-4-happens-before" class="headerlink" title="1.4. happens-before"></a>1.4. happens-before</h3><p>Java的JSR-133内存模型使用happens-before的概念来阐述操作之间的内存可见性。</p>
<p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。（两个操作可以是同一线程内，也可以是不同线程之间）</p>
<ul>
<li><strong>happens-before</strong>仅仅要求<strong>前一个操作执行的结果对后一个操作可见</strong>，且前一个操作按<strong>顺序</strong>排在第二个操作之前。<strong>并不意味</strong>着前一个操作必须在后一个操作前执行！</li>
</ul>
<p>与<strong>程序员密切相关的happens-before规则</strong>如下：</p>
<ul>
<li><strong>程序顺序规则</strong>：一个线程中的<strong>每个操作</strong>，<strong>happens-before于</strong>该线程中的任意<strong>后续操作</strong>。（同一线程内顺序排序）</li>
<li><strong>监视器锁规则</strong>：对一个锁的<strong>解锁</strong>，<strong>happens-before于</strong>随后对其<strong>加锁</strong>。（解锁–&gt;加锁）</li>
<li><strong>volatile变量规则</strong>：对一个<strong>volatile域的写</strong>，<strong>happens-before于</strong>任意后续对这个<strong>volatile域的读</strong>。（写–&gt;读）</li>
<li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C</li>
</ul>
<p>happens-before与JMM的关系：</p>
<div id="flowchart-1" class="flow-chart"></div>

<h2 id="二、重排序"><a href="#二、重排序" class="headerlink" title="二、重排序"></a>二、重排序</h2><p>重排序是指编译器和处理器优化程序性能而对指令序列进行重新排序的一种手段。</p>
<h3 id="2-1-数据依赖性"><a href="#2-1-数据依赖性" class="headerlink" title="2.1. 数据依赖性"></a>2.1. 数据依赖性</h3><p>两个操作访问同一个变量，其中一个是写操作，则存在数据依赖性。</p>
<p>分为：</p>
<ul>
<li>写后读</li>
<li>写后写</li>
<li>读后写</li>
</ul>
<p>上述三种情况，只要重排序两个操作，执行结果就会被改变。</p>
<p>编译器和处理器会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序（仅针对单个处理器和单个线程中的操作，不同处理器之间和不同线程之间的数据依赖性不被考虑）</p>
<p>###2.2. as-if-serial语义</p>
<p><strong>as-if-serial：不管怎么重排序，（单线程）程序的执行结果不能被改变。</strong></p>
<p>编译器、runtime、处理器都<strong>必须遵守</strong>as-if-serial语义，因此它们<strong>不会对存在数据依赖关系的操作</strong>做重排序。</p>
<p>as-if-serial语义<strong>保护了单线程</strong>程序。使单线程程序员无需担心重排序会干扰到程序和内存可见性问题。</p>
<h3 id="2-3-程序顺序规则"><a href="#2-3-程序顺序规则" class="headerlink" title="2.3. 程序顺序规则"></a>2.3. 程序顺序规则</h3><p>软件和硬件技术准求的目标：在<strong>不改变程序执行结果</strong>的前提下，尽可能<strong>提高并行度</strong>。</p>
<p>编译器和处理器遵从这一目标，JMM也同样遵从这一目标(happens-before)</p>
<h3 id="2-4-重排序对多线程的影响"><a href="#2-4-重排序对多线程的影响" class="headerlink" title="2.4. 重排序对多线程的影响"></a>2.4. 重排序对多线程的影响</h3><p>控制依赖：（if(xxxx) yyyy;    //x与y操作之间存在控制依赖关系）</p>
<p>当代码中存在控制依赖性时，会影响序列执行的并行度。编译器和处理器会采用猜测执行来客服控制相关性对并行度的影响。（猜测：在控制条件前提前读取数据并计算，将计算结果临时保存到名为重排序缓冲的硬件缓冲中）</p>
<p><strong>单线程</strong>中对存在<strong>控制依赖</strong>的操作进行重排序<strong>不影响</strong>结果（所以as-if-serial语义允许对其重排序）</p>
<p>但在<strong>多线程中，对存在控制依赖的操作重排序可能会<u>改变</u>程序的执行结果</strong>。</p>
<h2 id="三、顺序一致性"><a href="#三、顺序一致性" class="headerlink" title="三、顺序一致性"></a>三、顺序一致性</h2><h3 id="3-1-JMM的内存一致性保证"><a href="#3-1-JMM的内存一致性保证" class="headerlink" title="3.1. JMM的内存一致性保证"></a>3.1. JMM的内存一致性保证</h3><p>JMM对正确同步的多线程程序的内存一致性做了如下保证：</p>
<p>如果程序是正确同步的，程序的执行将具有顺序一致性（执行结果与顺序一致性模型相同）//（这里的同步适用于同步原语synchronized、volatile、final的正确使用）。</p>
<h3 id="3-2-顺序一致性模型"><a href="#3-2-顺序一致性模型" class="headerlink" title="3.2. 顺序一致性模型"></a>3.2. 顺序一致性模型</h3><p>顺序一致性模型是一个<strong>理想化</strong>的理论参考模型（实际上完全实现的代价很大），它为程序员提供了极强的内存可见性保证。</p>
<p><img src="/Blog/2018/05/29/Java并发编程艺术/第3章-Java内存模型/图3-2 顺序一致性内存模型的视图.jpg" alt="图3-2 顺序一致性内存模型的视图"></p>
<p><strong>顺序一致性内存模型</strong>的视图（如上图）：<strong>任意时间点最多只有任意一个线程可以连接到内存</strong>，当多个线程并发执行时，能把所有线程的所有内存读写都串行化。</p>
<p>它有<strong>两大特性</strong>：</p>
<ol>
<li><p>单个线程中的所有操作必须按照程序的顺序来执行<strong>（JMM没有保证这点，临界区内可以重排序）</strong></p>
</li>
<li><p>（不管程序是否同步）<strong>所有线程都只看得到唯一的操作执行顺序，</strong>每个操作都必须<strong>原子执行</strong>且<strong>立即对所有线程可见</strong>。</p>
<p>对此，<strong>JMM只保证同步程序的顺序一致性</strong>，<u>这是由Java内存模型决定的</u>：在未同步程序中，不但整体的执行顺序是无序的，线程锁看到的操作执行顺序也可能不一致：A线程写到A本地内存后，自以为执行结束，实际上还没刷入主内存，这相对于B线程是不立即可见的，即看到的执行顺序不一致（这里要结合上面的JAVA内存模型思考）</p>
<p>此外，<strong>JMM不保证对64位long和double变量的写操作具有原子性</strong>（读操作有原子性）（这是由总线带宽决定的，在32位处理器上，64位可能会被拆成2个32位执行。）（这点可以用锁来保证原子性）</p>
</li>
</ol>
<h3 id="3-3-Java同步程序的顺序一致性效果"><a href="#3-3-Java同步程序的顺序一致性效果" class="headerlink" title="3.3. Java同步程序的顺序一致性效果"></a>3.3. Java同步程序的顺序一致性效果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;		<span class="comment">//获得锁</span></span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;									<span class="comment">//释放锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;	<span class="comment">//获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;				<span class="comment">//临界区，其内可以重排序（JMM会在临界区创建顺序一致性模型内存视图）</span></span><br><span class="line">            <span class="keyword">int</span> i = a;			<span class="comment">//由于监视器互斥执行的特性，</span></span><br><span class="line">            ......				<span class="comment">//其他线程无法得知该线程访问临界区内的重排序</span></span><br><span class="line">        &#125;						<span class="comment">//这种重排序能够提高执行效率而且保证执行结果</span></span><br><span class="line">    &#125;								<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-未同步程序的执行特性"><a href="#3-4-未同步程序的执行特性" class="headerlink" title="3.4. 未同步程序的执行特性"></a>3.4. 未同步程序的执行特性</h3><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行读到的值，要么是之前某线程写入的值，要么是默认值（0，Null，False），JMM只保证线程读取到的值不会无中生有冒出来。</p>
<h2 id="四、volatile"><a href="#四、volatile" class="headerlink" title="四、volatile"></a>四、volatile</h2><p><u>volatile可以看作为使用同一个锁对volatile变量进行单个读或写做了同步。</u></p>
<p>volatile可以告知程序任何对该变量的访问必须要从共享内存中获取，并且其修改必须同步刷新到共享内存，以保证该变量在线程之间的可见性。</p>
<p>volatile变量的特性：</p>
<ul>
<li><strong>可见性</strong>：对一个volatile变量的<strong>读，总是能看到（任意线程）对这个volatile变量最后的写入</strong>。</li>
<li><strong>原子性</strong>：对任意<strong>单个</strong>volatile变量的<strong>读/写</strong>具有原子性，<u>但类似于volatile++这种复合操作不具有原子性。</u></li>
</ul>
<p>从内存语义的角度来说，volatile变量的写-读 与 锁的释放-获取 有相同的内存效果。</p>
<ul>
<li>volatile写和锁的释放具有相同的内存语义；</li>
<li>volatile读与锁的获取具有相同的内存语义</li>
</ul>
<p>举例分析一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;		 <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;		<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i = a;	<span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据程序次序规则：1 happens-before 2; 3 happens-before 4</p>
<p>根据volatile规则：2 happens-before 3</p>
<p>根据happens-before的传递性：1 happens-before 4</p>
<p>也就是：</p>
<div id="flowchart-2" class="flow-chart"></div>

<p>A写了一个volatile变量之后，B读同一个volatile变量。</p>
<p>A线程在写volatile变量之前所有可见的共享变量，在B线程读了同一个volatile变量之后，立即变得对B线程可见。（这句话可以用下面的内存语义结合内存模型理解）</p>
<ul>
<li>（个人理解：写volatile变量即为解锁，读volatile即为加锁，因为任何线程都可以原子性地单独读/写volatile变量，所以volatile不会造成死锁）</li>
</ul>
<h3 id="3-2-volatile-写-读的内存语义（与锁的释放-获取内存语义相似）"><a href="#3-2-volatile-写-读的内存语义（与锁的释放-获取内存语义相似）" class="headerlink" title="3.2. volatile 写-读的内存语义（与锁的释放-获取内存语义相似）"></a>3.2. volatile 写-读的内存语义（与锁的释放-获取内存语义相似）</h3><p>volatile<strong>写</strong>的内存语义：（同释放锁）</p>
<ul>
<li><strong>写一个volatile变量时</strong>，JMM会把该线程对应的本地内存中的<strong>共享变量值刷新到主内存</strong>）</li>
</ul>
<p>volatile<strong>读</strong>的内存语义：（同获取锁）</p>
<ul>
<li><strong>读一个volatile变量时</strong>，JMM会把该线程对应的<strong>本地内存置为无效</strong>，线程接下来将<strong>从主内存中读取共享变量</strong>。</li>
</ul>
<h4 id="3-2-1-写-读volatile变量的内存语义实质：（与锁的释放-获取内存语义相似）"><a href="#3-2-1-写-读volatile变量的内存语义实质：（与锁的释放-获取内存语义相似）" class="headerlink" title="3.2.1. 写-读volatile变量的内存语义实质：（与锁的释放-获取内存语义相似）"></a>3.2.1. 写-读volatile变量的内存语义实质：（与锁的释放-获取内存语义相似）</h4><ul>
<li>线程A<strong>写</strong>一个volatile变量，实质上是线程A向接下来要读这个volatile变量的某个线程<strong>发出了（其对共享变量所做出的修改）的消息</strong>。</li>
<li>线程B<strong>读</strong>一个volatile变量，实质上是线程B<strong>接受了</strong>之前某个线程发出的<strong>（在写这个volatile变量之前对共享变量所做的修改）的消息</strong>。</li>
<li>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程<strong>实质</strong>上是线程A<strong>通过主内存</strong>向线程B<strong>发消息</strong>。</li>
</ul>
<h3 id="3-3-volatile-内存语义的实现"><a href="#3-3-volatile-内存语义的实现" class="headerlink" title="3.3. volatile 内存语义的实现"></a>3.3. volatile 内存语义的实现</h3><p>JMM对volatile制定的重排序规则：</p>
<ul>
<li>volatile写之前的操作绝对不会重排序到其之后。</li>
<li>volatile读之后的操作不会重排序到其之前。</li>
<li>volatile写在volatile读之前时，不会重排序。</li>
</ul>
<p>这些规则都是使用插入内存屏障来解决的（编译器会适当减少不必要、重复的内存屏障）。</p>
<h2 id="五、锁的内存语义"><a href="#五、锁的内存语义" class="headerlink" title="五、锁的内存语义"></a>五、锁的内存语义</h2><p>锁可以让临界区互斥执行，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;	<span class="comment">//1 获得锁</span></span><br><span class="line">        a++;					 	  <span class="comment">//2 执行临界区代码</span></span><br><span class="line">    &#125;								 <span class="comment">//3 释放锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;	<span class="comment">//4</span></span><br><span class="line">        <span class="keyword">int</span> i = a;					   <span class="comment">//5</span></span><br><span class="line">    &#125;								  <span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设线程A执行writer，然后线程B执行reader。根据happens-before原则推导得出：2 happends-before 5</p>
<p>因此，线程A在释放锁之前的所有可见的共享变量，在线程B获取同一个锁之后将立刻变得对B线程可见。</p>
<h3 id="内存语义：（与volatile具有相同的内存语义）"><a href="#内存语义：（与volatile具有相同的内存语义）" class="headerlink" title="内存语义：（与volatile具有相同的内存语义）"></a><strong>内存语义</strong>：（与volatile具有相同的内存语义）</h3><ul>
<li><strong>释放锁</strong>时，JMM把该线程的本地内存中的<strong>共享变量会刷新到主内存</strong>中</li>
<li><strong>获得锁</strong>时，JMM将该线程对应的<strong>本地内存置为无效</strong>，并且<strong>从主内存中读取共享变量</strong>。</li>
</ul>
<p>实质上也是在<strong>通过主内存发送消息</strong>。</p>
<h3 id="5-3-ReentrantLock的实现方式（以此例讲锁的内存语义实现方式）"><a href="#5-3-ReentrantLock的实现方式（以此例讲锁的内存语义实现方式）" class="headerlink" title="5.3. ReentrantLock的实现方式（以此例讲锁的内存语义实现方式）"></a>5.3. ReentrantLock的实现方式（以此例讲锁的内存语义实现方式）</h3><p>ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer(简称AQS)。AQS<strong>使用一个整形的volatile变量（state）来维护同步状态</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrankLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    ReetrantLock lock = <span class="keyword">new</span> ReetrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>公平锁：</strong><ul>
<li>获取锁：读volatile变量</li>
<li>释放锁：写volatile变量</li>
</ul>
</li>
<li><strong>非公平锁：</strong><ul>
<li>获取锁：用原子性的CAS（compareAndSet）操作更新volatile变量（<strong>CAS同时具有volatile读和写的内存语义</strong>）</li>
<li>释放锁：写volatile变量</li>
</ul>
</li>
</ul>
<h3 id="5-4-锁内存语义的两种实现方式"><a href="#5-4-锁内存语义的两种实现方式" class="headerlink" title="5.4. 锁内存语义的两种实现方式"></a>5.4. 锁内存语义的两种实现方式</h3><ul>
<li>利用<strong>volatile的写-读所具有的内存语义</strong>。</li>
<li>利用<strong>CAS所同时附带的volatile读和volatile写的内存语义</strong>。</li>
</ul>
<p>这两种方式可以实现线程之间的通信。</p>
<h3 id="5-5-concurrent包的实现"><a href="#5-5-concurrent包的实现" class="headerlink" title="5.5. concurrent包的实现"></a>5.5. concurrent包的实现</h3><ul>
<li>A线程写volatile变量，随后B线程读这个volatile变量</li>
<li>A线程写volatile变量，随后B线程CAS更新这个volatile变量</li>
<li>A线程CAS更新volatile变量，随后B线程CAS更新这个volatile变量</li>
<li>A线程CAS更新volatile变量，随后B线程读这个volatile变量</li>
</ul>
<p>（其实就是利用锁语义的实现方式做了个排列组合）</p>
<p><strong>通用的实现模式：</strong></p>
<ol>
<li>声明共享变量为volatile；</li>
<li>使用CAS的原子条件更新来实现线程之间的同步；</li>
<li>配合以volatile读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li>
</ol>
<h2 id="六、final域的内存语义"><a href="#六、final域的内存语义" class="headerlink" title="六、final域的内存语义"></a>六、final域的内存语义</h2><p>与锁和volatile相比，对final域的读写更像是普通变量的访问。</p>
<h3 id="6-1-final域的重排序规则"><a href="#6-1-final域的重排序规则" class="headerlink" title="6.1. final域的重排序规则"></a>6.1. final域的重排序规则</h3><ul>
<li>写：禁止把final域的写重排序到构造函数之外。这可以保证在对象引用为任意线程可见之前，该对象的final域已经被正确初始化了（普通域不具有这个保证）</li>
<li>读：初次读对象的<u>引用</u> 限定在 初次读该对象<u>包含的final域</u> 之前。（确保在读一个<u>对象的final域</u>之前，一定会先读包含了这个final域的对象的<u>引用</u>。</li>
<li>只要对象是正确构造的（不在构造函数中逸出），那么不需要使用同步（volatile和lock）就可以保证任意线程都可以看到这个final域在构造函数中被初始化之后的值。</li>
</ul>
<h3 id="6-2-当final域为引用类型时"><a href="#6-2-当final域为引用类型时" class="headerlink" title="6.2. 当final域为引用类型时"></a>6.2. 当final域为引用类型时</h3><ul>
<li>对final域为引用类型的多线程读写时，就像对普通域一样读写，是存在数据竞争的，这时候需要用同步原语（lock和volatile）来确保内存可见性。</li>
</ul>
<p>final引用不能从构造函数内溢出：</p>
<p>写final域的保证：这可以保证在对象引用为任意线程可见之前，该对象的final域已经被正确初始化了</p>
<p>前提：构造函数内部，不能让这个被构造函数的引用为其他线程可见，也就是说对象应用不能在构造函数中“溢出”。（因为此时的final域肯恩给还没有被初始化）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误的构造示例 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;		<span class="comment">//写final域</span></span><br><span class="line">        obj = <span class="keyword">this</span>;				<span class="comment">//this引用再次溢出了（对外可见了）这是不正确的构造</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;	<span class="comment">//A线程写</span></span><br><span class="line">        <span class="keyword">new</span> FinalReferenceEscapeExample();	<span class="comment">//创建一个实例，调用了构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;		<span class="comment">//B线程读</span></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = obj.i;		</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，A线程写调用构造函数返回前，该对象的引用就变得对线程B可见了，这可能会导致i在被初始化之前就被读取。（虽然final保证final的写不被重排序到构造函数之外，但构造函数结束之前就被暴露了出来，可能会被B线程在final域未被初始化前提前读取）。</p>
<h2 id="七、happens-before"><a href="#七、happens-before" class="headerlink" title="七、happens-before"></a>七、happens-before</h2><p>happens-before是JMM最核心的概念。对于程序员来说，理解happens-before是理解JMM的关键。</p>
<h3 id="7-1-JMM的设计"><a href="#7-1-JMM的设计" class="headerlink" title="7.1. JMM的设计"></a>7.1. JMM的设计</h3><p><img src="/Blog/2018/05/29/Java并发编程艺术/第3章-Java内存模型/图3-3 JMM的设计示意图.png" alt="图3-3 JMM的设计示意图"></p>
<ul>
<li>程序员希望内存模型易于理解和编程，是个强内存模型。JMM对此向程序员提供happens-before规则保证了内存可见性。</li>
<li>编译器和处理器对内存模型的实现希望束缚越少越好以提高性能，是个弱内存模型。JMM规定只要不改变程序（单线程）的执行结果，编译器和处理器怎么优化都行。</li>
</ul>
<h3 id="7-2-happens-before的定义"><a href="#7-2-happens-before的定义" class="headerlink" title="7.2. happens-before的定义"></a>7.2. happens-before的定义</h3><ul>
<li>如果一个操作happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。（JMM对程序员的保证）</li>
<li>两个操作之间存在happens-before 关系，并不意味着执行顺序一定是happens-before指定的顺序。（JMM对编译器和处理器的保证）</li>
</ul>
<h3 id="7-3-as-if-serial"><a href="#7-3-as-if-serial" class="headerlink" title="7.3. as-if-serial"></a>7.3. as-if-serial</h3><ul>
<li>as-if-serial保证单线程内程序的执行结果不改变，happens-before关系保证了多线程程序执行结果不被改变。</li>
<li>as-if-serial让程序员感受到单线程程序是按照程序的顺序执行的，happens-before让程序员感觉正确同步的多线程程序是按照happens-before指定的顺序来执行的。</li>
</ul>
<h3 id="7-4-happens-before规则"><a href="#7-4-happens-before规则" class="headerlink" title="7.4. happens-before规则"></a>7.4. happens-before规则</h3><ul>
<li><strong>程序顺序规则</strong>：一个线程中的<strong>每个操作</strong>，<strong>happens-before于</strong>该线程中的任意<strong>后续操作</strong>。（同一线程内顺序排序）</li>
<li><strong>监视器锁规则</strong>：对一个锁的<strong>解锁</strong>，<strong>happens-before于</strong>随后对其<strong>加锁</strong>。（解锁–&gt;加锁）（解锁的写入一定能被加锁的线程看到）</li>
<li><strong>volatile变量规则</strong>：对一个<strong>volatile域的写</strong>，<strong>happens-before于</strong>任意后续对这个<strong>volatile域的读</strong>。（写–&gt;读）</li>
<li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C</li>
<li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么<strong>A线程的ThreadB.start()操作happens-before于线程B中的任意操作</strong>。</li>
<li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么<strong>线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回</strong>。</li>
</ul>
<h2 id="八、双重检查锁定与延迟初始化"><a href="#八、双重检查锁定与延迟初始化" class="headerlink" title="八、双重检查锁定与延迟初始化"></a>八、双重检查锁定与延迟初始化</h2><h2 id="九、JMM综述"><a href="#九、JMM综述" class="headerlink" title="九、JMM综述"></a>九、JMM综述</h2><p>JMM是语言级的内存模型，处理器内存模型是硬件及的内存模型（更弱）。</p>
<h3 id="9-1-JMM的内存可见性保证："><a href="#9-1-JMM的内存可见性保证：" class="headerlink" title="9.1. JMM的内存可见性保证："></a>9.1. JMM的内存可见性保证：</h3><ul>
<li>单线程程序：单线程程序不会出现内存可见性问题。</li>
<li>正确同步的多线程程序：正确同步的多线程程序的执行见具有顺序一致性（程序的执行结果与顺序一致性内存模型中的结果相同）（JMM用限制重排序来保证）</li>
<li>未同步/未正确同步的多线程程序：最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op1=>operation: 源代码
op2=>operation: 1：编译器
优化重排序
op3=>operation: 2：指令级
并行重排序
op4=>operation: 3：内存系统
重排序
op5=>operation: 4：最终执行的指令序列

op1(right)->op2(right)->op3(right)->op4(right)->op5</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">op1=>start: 程序员
op2=>operation: happens-before 规则
(JMM呈现给程序员的视图部分）
op3=>operation: 禁止某种类型的
编译器/处理器重排序
( JMM的实现 )
op4=>operation: 处理器/编译器重排序规则
(JMM定义的规则)

op1(right)->op2(right)->op3(right)->op4</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">op1=>operation: 1: 线程A修改共享变量
op2=>operation: 2: 线程A写volatile变量
op3=>operation: 3: 线程B读同一个volatile变量
op4=>operation: 4: 线程B读共享变量

op1->op2(right)->op3->op4</textarea><textarea id="flowchart-2-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uncleaaron.github.io/Blog/Blog/2018/05/28/Java并发编程艺术/第2章-Java并发编程机制的底层实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron.H">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StormAaron的技术站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Blog/2018/05/28/Java并发编程艺术/第2章-Java并发编程机制的底层实现原理/" itemprop="url">第2章 Java并发编程机制的底层实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T20:46:25+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Java并发编程艺术/" itemprop="url" rel="index">
                    <span itemprop="name">Java并发编程艺术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第2章-Java并发编程机制的底层实现原理"><a href="#第2章-Java并发编程机制的底层实现原理" class="headerlink" title="第2章 Java并发编程机制的底层实现原理"></a>第2章 Java并发编程机制的底层实现原理</h1><h2 id="一、volatile"><a href="#一、volatile" class="headerlink" title="一、volatile"></a>一、volatile</h2><p>volatile是<strong>轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。</strong>（<strong>当一个程序修改一个共享变量时，另外一个线程能读到这个修改的值</strong>）</p>
<p>Java规范定义：允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。</p>
<p>volatile使用恰当的话，它比synchronized的使用和执行成本更低，因为它<strong>不会引起线程上下文切换和调度。</strong></p>
<h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对volatile进行写操作 */</span></span><br><span class="line">instance = <span class="keyword">new</span> Singleton();		<span class="comment">//instance是volatile变量</span></span><br></pre></td></tr></table></figure>
<p>转化成汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x01a3de1d: movb $0x0,0x1004800(%esi)</span><br><span class="line">0x01a3de24: lock addl $0x0,(%esp)</span><br></pre></td></tr></table></figure></p>
<p>有volatile变量修饰的共享变量进行写操作的额时候会多出第二行汇编代码。<br>Lock前缀的指令在多核处理器下会发生两件事：</p>
<ol>
<li>Lock前缀指令会引起处理器缓存回写到内存。</li>
<li>一个处理器的缓存回写到内存会使在其他CPU里的该缓存数据无效（个人理解：可以保证数据一致性）</li>
</ol>
<h4 id="volatile使用优化"><a href="#volatile使用优化" class="headerlink" title="volatile使用优化"></a>volatile使用优化</h4><p>例：JDK7的并发包新增的队列集合类LinkedTransferQueue在使用volatile变量时，采用追加字节的方式来优化队列出入队的性能。他将共享变量追加到64字节，原因是现在许多CPU缓存行的大小是64字节宽，不支持部分填充缓存行， 当一个处理器试图修改缓存行的时候会将整个缓存行锁定，若字节数小于64，则头尾节点可能会缓存到同一个缓存行，这样会互相锁定降低修改效率。</p>
<h2 id="二、synchronized"><a href="#二、synchronized" class="headerlink" title="二、synchronized"></a>二、synchronized</h2><p>利用 <strong>synchronized</strong>实现同步的基础：<strong>Java中的每一个对象都可以作为锁</strong>，具体表现为以下三种形式：</p>
<ul>
<li>对于<strong>普通同步方法</strong>：锁是当前<strong>实例对象</strong>。</li>
<li>对于<strong>静态同步方法</strong>：锁是<strong>当前类的Class对象</strong>。</li>
<li>对于<strong>同步方法块</strong>：锁是<strong>synchronized括号里配置的对象</strong>。</li>
</ul>
<p>而<strong>synchronized用的锁是存在Java对象头里的</strong></p>
<h3 id="2-1-Java对象头"><a href="#2-1-Java对象头" class="headerlink" title="2.1. Java对象头"></a>2.1. Java对象头</h3><p>synchronized用的锁是存在Java对象头里的</p>
<p>对象头里的Mark Word默认存对象的HashCode，分代年龄和锁标记位</p>
<table>
<thead>
<tr>
<th style="text-align:center">锁状态</th>
<th style="text-align:center">25bit</th>
<th style="text-align:center">4bit</th>
<th style="text-align:center">1bit 是否偏向锁</th>
<th style="text-align:center">2bit 锁标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">重量级锁</td>
<td style="text-align:center">-</td>
<td style="text-align:center">指向互斥量（重量级锁）的指针</td>
<td style="text-align:center">-</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">轻量锁</td>
<td style="text-align:center">-</td>
<td style="text-align:center">指向栈中锁的指针</td>
<td style="text-align:center"></td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">偏向锁</td>
<td style="text-align:center">线程ID</td>
<td style="text-align:center">对象分代年龄对象分代年龄</td>
<td style="text-align:center">1</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">无锁状态</td>
<td style="text-align:center">对象的HashCode</td>
<td style="text-align:center">对象分代年龄</td>
<td style="text-align:center">0</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">GC标记</td>
<td style="text-align:center"></td>
<td style="text-align:center">空</td>
<td style="text-align:center">-</td>
<td style="text-align:center">11</td>
</tr>
</tbody>
</table>
<h3 id="2-2-锁的升级和对比"><a href="#2-2-锁的升级和对比" class="headerlink" title="2.2. 锁的升级和对比"></a>2.2. 锁的升级和对比</h3><p>为了减少获得锁和释放锁的性能消耗，引入“偏向锁”和“轻量级锁”</p>
<p>锁从低到高的4个状态：无锁 –&gt; 偏向锁 –&gt; 轻量级锁 –&gt; 重量级锁</p>
<p>这几个状态会随着竞争逐渐升级（不可以降级，目的是为了提高获得/释放锁的效率）</p>
<h4 id="1-偏向锁"><a href="#1-偏向锁" class="headerlink" title="1. 偏向锁"></a>1. 偏向锁</h4><p>存在现象：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得，为了让线程获得锁的代价更低而引入偏向锁。</p>
<p>原理：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进出同步块时不需要进行CAS操作来加锁或解锁，只需要简单的测试一下对象头的MarkWord里是否存储着指向当前线程的偏向锁。（偏向锁在Java6和Java7内是默认启用的）</p>
<p>撤销偏向锁：直到竞争出现才会释放锁。流程：①暂停拥有偏向锁的线程 ②解锁，将线程ID设置为空 ③恢复线程</p>
<p><em>（注意撤销偏向锁与解锁不同：撤销偏向锁是指将偏向锁的偏向线程改为别的线程或空，解锁是释放锁）</em></p>
<h4 id="2-轻量级锁"><a href="#2-轻量级锁" class="headerlink" title="2. 轻量级锁"></a>2. 轻量级锁</h4><p>加锁：JVM在当前线程的栈帧中创建用于存储锁的空间，并拷贝对象头中的MarkWord到锁记录中，再由线程尝试将对象头中的MarkWord替换为指向锁的指针。成功则获得锁，失败则有竞争，线程会采用自旋来获得锁（消耗CPU，为了避免无用的自旋，有必要升级为重量级锁）</p>
<p>解锁：使用CAS将拷贝的MarkWord替换回对象头。如果成功，表示没有竞争发生；如果失败，则当前锁存在竞争，锁会膨胀成重量级锁。</p>
<h4 id="3-重量级锁"><a href="#3-重量级锁" class="headerlink" title="3. 重量级锁"></a>3. 重量级锁</h4><p>线程试图获取重量级锁的时候，都会被阻塞，当持有锁的线程释放锁后会唤醒这些线程，然后进行新一轮的竞争</p>
<h4 id="锁的优缺点和对比"><a href="#锁的优缺点和对比" class="headerlink" title="锁的优缺点和对比"></a>锁的优缺点和对比</h4><table>
<thead>
<tr>
<th style="text-align:center">锁</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">偏向锁</td>
<td style="text-align:center">加锁解锁不需要额外的消耗，和非同步的方法执行只有纳秒级的差距</td>
<td style="text-align:center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td style="text-align:center">适用于只有一个线程访问同步块的场景</td>
</tr>
<tr>
<td style="text-align:center">轻量级锁</td>
<td style="text-align:center">竞争的线程不会阻塞，提高了程序的响应速度</td>
<td style="text-align:center">如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>
<td style="text-align:center">追求响应时间<br>同步块执行速度非常快</td>
</tr>
<tr>
<td style="text-align:center">重量级锁</td>
<td style="text-align:center">线程竞争不使用自旋，不消耗CPU</td>
<td style="text-align:center">线程阻塞，响应时间慢</td>
<td style="text-align:center">追求吞吐量<br>同步块执行速度较长</td>
</tr>
</tbody>
</table>
<h2 id="三、原子操作的实现原理"><a href="#三、原子操作的实现原理" class="headerlink" title="三、原子操作的实现原理"></a>三、原子操作的实现原理</h2><h4 id="3-1-实现方法："><a href="#3-1-实现方法：" class="headerlink" title="3.1. 实现方法："></a>3.1. 实现方法：</h4><ol>
<li>缓存加锁/总线加锁：保证基本内存操作原子性</li>
<li>缓存锁定/总线锁定：保证跨缓存行或跨页表访问等复杂的内存操作的原子性</li>
</ol>
<h4 id="3-2-Java中实现原子操作"><a href="#3-2-Java中实现原子操作" class="headerlink" title="3.2. Java中实现原子操作"></a>3.2. Java中实现原子操作</h4><p>从Java1.5开始，JDK并发包里提供了一些类来支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger、AtomicLong等。</p>
<h5 id="3-2-1-使用循环CAS实现原子操作"><a href="#3-2-1-使用循环CAS实现原子操作" class="headerlink" title="3.2.1. 使用循环CAS实现原子操作"></a>3.2.1. 使用循环CAS实现原子操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicI = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 使用CAS实现线程安全计数器</span></span><br><span class="line"><span class="comment">* CAS:Compare and set(switch)</span></span><br><span class="line"><span class="comment">* 在操作前先比较旧值有没有变化，没变化才换成新值，否则不替换（可以保证数据一致性）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = atomicI.get();</span><br><span class="line">        <span class="comment">//CAS操作(旧值,新值)：旧值相同才替换为新值，否则不替换</span></span><br><span class="line">        <span class="keyword">boolean</span> suc = atomicI.compareAndSet(i, i++);</span><br><span class="line">        <span class="keyword">if</span> (suc) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//修改成功则break，否则继续循环到操作成功（可能会由于长时间不成功带来巨额开销）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 非线程安全计数器 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-使用锁实现原子操作"><a href="#3-2-2-使用锁实现原子操作" class="headerlink" title="3.2.2. 使用锁实现原子操作"></a>3.2.2. 使用锁实现原子操作</h5><p>锁机制保证了只有获得锁的线程才能操作锁定的内存区域（但其实Java除了偏向锁，其他的锁都用了循环CAS的机制获取和释放锁）</p>
<h5 id="3-2-3-CAS实现原子操作的三大问题："><a href="#3-2-3-CAS实现原子操作的三大问题：" class="headerlink" title="3.2.3. CAS实现原子操作的三大问题："></a>3.2.3. CAS实现原子操作的三大问题：</h5><ol>
<li><p>ABA问题。一个值反复从A到B，B到A，使用CAS检查时以为没有变化，实际上却发生了变化。</p>
<p>解决思路：使用版本号</p>
<p>JDK的Atomic包里提供了AtomicStampedRefence来解决ABA问题</p>
</li>
<li><p>循环时间长开销大。如果CAS长时间不成功，CPU开销会很大。</p>
</li>
<li><p>只能保证一个共享变量的原子操作。</p>
<p>解决办法：</p>
<ol>
<li>使用锁</li>
<li>将多个共享变量合并成一个共享变量来操作。JDK提供了AtomicReference，把多个变量放在同一个对象里进行CAS操作。</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uncleaaron.github.io/Blog/Blog/2018/05/27/Java并发编程艺术/第1章-并发编程的挑战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron.H">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StormAaron的技术站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Blog/2018/05/27/Java并发编程艺术/第1章-并发编程的挑战/" itemprop="url">第1章 并发编程的挑战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-27T20:46:25+08:00">
                2018-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Java并发编程艺术/" itemprop="url" rel="index">
                    <span itemprop="name">Java并发编程艺术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第1章-并发编程的挑战"><a href="#第1章-并发编程的挑战" class="headerlink" title="第1章 并发编程的挑战"></a>第1章 并发编程的挑战</h1><p>并发编程以后多种挑战需要面临：例如上下文切换问题、死锁问题、受限于硬件/软件资源限制的问题</p>
<h2 id="一、上下文切换"><a href="#一、上下文切换" class="headerlink" title="一、上下文切换"></a>一、上下文切换</h2><ul>
<li>过多的上下文切换会影响效率。</li>
<li>在较少数量级的运算中，因为线程的创建以及上下文切换，可能导致并行比串行执行还慢。</li>
</ul>
<h3 id="减少上下文切换的方法："><a href="#减少上下文切换的方法：" class="headerlink" title="减少上下文切换的方法："></a>减少上下文切换的方法：</h3><ol>
<li><strong>无锁并发编程</strong>：（多线程竞争锁的时候会导致上下文切换）<strong>采用一些方法避免使用锁</strong>，比如：用hash算法将数据ID取模分段，然后不同线程处理不同段的数据</li>
<li><strong>CAS算法</strong>：Java的Atomic包使用CAS算法更新数据，不需要加锁</li>
<li><strong>使用最少线程</strong>：<strong>避免创建不需要的线程</strong>（过多线程的等待状态会导致上下文切换增加）（换言之要减少等待状态的线程）</li>
<li><strong>协程</strong>：<strong>在单线程内实现多任务调度</strong>，并在单线程内维持多任务切换。</li>
</ol>
<h2 id="二、死锁"><a href="#二、死锁" class="headerlink" title="二、死锁"></a>二、死锁</h2><h3 id="避免死锁的几种常见方法"><a href="#避免死锁的几种常见方法" class="headerlink" title="避免死锁的几种常见方法"></a>避免死锁的几种常见方法</h3><ul>
<li><strong>避免一个线程同时获得多个锁</strong></li>
<li><strong>避免一个线程在锁内同时占用多个资源</strong>，尽量保证每个所只占用一个资源</li>
<li>尝试<strong>使用定时锁</strong>（用lock.tryLock(timeout) 来替代内部锁机制）</li>
<li><strong>数据库锁的加锁和解锁必须在一个数据库连接里</strong>，否则会出现解锁失败的情况。</li>
</ul>
<h2 id="三、资源限制"><a href="#三、资源限制" class="headerlink" title="三、资源限制"></a>三、资源限制</h2><ul>
<li>资源限制分为<strong>软件资源</strong>（数据库连接数，socket连接数等）和<strong>硬件资源</strong>（CPU处理速度，硬盘读写速度等）的限制</li>
<li>资源限制<strong>导致的问题</strong>：有时候受限于资源，导致程序仍然在串行执行，加上上下文切换和资源调度，会更慢</li>
<li>解决资源限制的问题：<strong>集群并行执行</strong>（多机运行程序（不同机器处理不同数据））（也就是加服务器）</li>
<li>在资源限制的情况下并发编程：需要<strong>根据不同的资源限制调整程序的并发度</strong> </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uncleaaron.github.io/Blog/Blog/2018/05/20/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron.H">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StormAaron的技术站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Blog/2018/05/20/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-20T20:46:25+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Aaron.H</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/Blog/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/Blog/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/Blog/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aaron.H</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/Blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/Blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/Blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/Blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/Blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/Blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/Blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/Blog/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/Blog/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/Blog/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/Blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
